Statement,Description
name arg1 arg2 ... argn = <expr>, "Define a function named 'name' with 'n' arguments and an expression to be evaluated."
name arg1 arg2 ... argn, "Calls the function 'name' with 'n' arguments."
in_range min max x = x >= min && x <= max, "Checks if the value of x is within the range specified by min and max"
sum = foldr (+) 0,"Calculate the sum of a list of numbers using a right fold (foldr) with the addition operator (+) and starting with an initial accumulator value of 0."
sum [] = 0,"Define a function 'sum' that takes an empty list as input and returns 0."
sum (X : XS) = X + sum XS,"Define a function 'sum' that takes a non-empty list as input, where X is the head of the list and XS is the tail. It recursively calculates the sum of the elements in the list by adding the head (X) to the sum of the tail (sum XS)."
let x = func1 arg,"Define a variable 'x' which is assigned the result of calling function 'func1' with argument 'arg'."
y = func2 arg,"Define a variable 'y' which is assigned the result of calling function 'func2' with argument 'arg'."
z = func3 arg,"Define a variable 'z' which is assigned the result of calling function 'func3' with argument 'arg'."
if z then x else y,"Conditional statement that evaluates 'z'. If 'z' is true, evaluates 'x'; otherwise, evaluates 'y'."
int func(int arg) {,"Start the definition of a function named 'func' that takes an integer argument 'arg'."
int x = func1 (arg);,"Define a variable 'x' of type integer which is assigned the result of calling function 'func1' with argument 'arg'."
int y = func2 (arg);,"Define a variable 'y' of type integer which is assigned the result of calling function 'func2' with argument 'arg'."
int z = func3 (arg);,"Define a variable 'z' of type integer which is assigned the result of calling function 'func3' with argument 'arg'."
if (z) {,"Start a conditional statement based on the value of 'z'."
return x;,"Return the value of 'x' if 'z' is true."
} else {,"Handle the else part of the conditional statement."
return y;,"Return the value of 'y' if 'z' is false."
},End the conditional statement and the function definition."
name arg1 arg2 ... argn = "<expr>,Define a function named 'name' with 'n' arguments 'arg1' to 'argn' that evaluates to the expression '<expr>'."
name arg1 arg2 ... argn,"Define a function named 'name' with 'n' arguments 'arg1' to 'argn'."
in_range min max x = x >= min && x <= max,"Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'. It returns true if 'x' is within the range [min, max] (inclusive), otherwise false."
in_range 0 5 3,"Check if the value 3 is within the range [0, 5]."
in_range 4 5 3,"Check if the value 3 is within the range [4, 5]."
name :: <type>,"Declare the type signature of a value or function named 'name' as '<type>'."
x :: Integer,"Declare a variable 'x' with type Integer."
x = 1,"Assign the value 1 to the variable 'x'."
y :: Bool,"Declare a variable 'y' with type Bool."
y = True,"Assign the value True to the variable 'y'."
z :: Float,"Declare a variable 'z' with type Float."
z = 3.1415,"Assign the value 3.1415 to the variable 'z'."
in_range :: Integer -> Integer -> Integer -> Bool,"Declare a function 'in_range' that takes three Integer arguments and returns a Bool."
in_range min max x = x >= min && x <= max,"Define the 'in_range' function to check if 'x' is within the range [min, max]."
in_range 0 5 3 <-- correct,"Call the 'in_range' function with arguments 0, 5, and 3. This is a correct usage."
in_range min max x =,"Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'."
in_lower_bound = min <= x;,"Check if 'x' is greater than or equal to 'min' and assign the result to 'in_lower_bound'."
in_upper_bound = max >= x;,"Check if 'x' is less than or equal to 'max' and assign the result to 'in_upper_bound'."
return (in_lower_bound && in_upper_bound);,"Return true if 'x' is within the range [min, max], otherwise false."
in_range min max x = ilb && iub,"Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x', and returns whether 'x' is within the range [min, max]."
ilb = min <= x,"Check if 'x' is greater than or equal to 'min' and assign the result to 'ilb'."
iub = max >= x,"Check if 'x' is less than or equal to 'max' and assign the result to 'iub'."
in_range min max x = if ilb then iub else False,"Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'. It returns True if 'x' is within the range [min, max], otherwise False."
ilb = min <= x,"Check if 'x' is greater than or equal to 'min' and assign the result to 'ilb'."
iub = max >= x,"Check if 'x' is less than or equal to 'max' and assign the result to 'iub'."
add a b = a+b,"Define a function 'add' that takes two arguments 'a' and 'b' and returns their sum."
add 10 20,"Call the function 'add' with arguments 10 and 20, resulting in the sum of 10 and 20."
name <args> = ... name <args'> ...,"Define a recursive function named 'name' that takes arguments '<args>' and recurses on itself with arguments '<args>'."
fac n = if n <= 1 then 1 else n * fac (n-1),"Define a recursive function 'fac' that calculates the factorial of 'n'. If 'n' is less than or equal to 1, return 1; otherwise, return 'n' multiplied by the factorial of 'n-1'."
fac n | n <= 1  =1 | otherwise = n * fac (n-1),"Define a function 'fac' that calculates the factorial of 'n'. If 'n' is less than or equal to 1, return 1; otherwise, return 'n' multiplied by the factorial of 'n-1'."
is_zero 0 = True | is_zero _ = False,"Define a function 'is_zero' that pattern matches on its argument. If the argument is 0, return True; otherwise, return False."
fac n = aux n 1 where aux n acc | n <= 1 = acc | otherwise = aux (n-1) (n*acc),"Define a function 'fac' that calculates the factorial of 'n' using an accumulator. It initializes the accumulator to 1 and calls the auxiliary function 'aux' with 'n' and the accumulator. The 'aux' function recursively calculates the factorial by updating 'n' and 'acc' until 'n' becomes less than or equal to 1, at which point it returns the accumulator."
"[1,2,3,4,5] :: [Integer]","Define a list containing integers 1 through 5."
[],"Define an empty list."
x:xs,"Represent a list where 'x' is the first element and 'xs' is the rest of the list."
"[1,2,3,4,5]","Define a list containing integers 1 through 5 using the cons operator (:)."
1:2:3:4:5: [],"Construct a list with integers 1 through 5 using the cons operator (:). Each element is separated by the cons operator, and the list is terminated with an empty list."
asc :: Int -> Int -> [Int],"Define a function 'asc' that generates a list of integers in ascending order."
asc n m | m<n = [] | m==n = [m] | m>n = n : asc (n+1) m,"Define the implementation of the 'asc' function using pattern matching. If 'm' is less than 'n', return an empty list. If 'm' equals 'n', return a singleton list containing 'm'. If 'm' is greater than 'n', prepend 'n' to the result of recursively calling 'asc' with 'n+1' and 'm'."
asc 1 3,"Call the 'asc' function with arguments 1 and 3, resulting in the list [1,2,3]."
head :: [a] -> a, "Return the first element of a list."
tail :: [a] -> [a], "Return all elements of a list except the first one."
length :: [a] -> Int, "Return the number of elements in a list."
init :: [a] -> [a], "Return all elements of a list except the last one."
null :: [a] -> Bool, "Return True if a list is empty, otherwise False."
and :: [Bool] -> Bool, "Return True if all elements in the list are True, otherwise False."
or :: [Bool] -> Bool, "Return True if at least one element in the list is True, otherwise False."
[2*x | x <- [1,2,3] ], "Generate a list where each element is obtained by doubling each element of the list [1,2,3]."
[2*x | x <- [1,2,3], x>1 ], "Generate a list where each element is obtained by doubling each element of the list [1,2,3], but only if the element is greater than 1."
[ (x,y) | x <- [1,2,3], y <- ['a','b']], "Generate a list of tuples where each tuple contains an element from the list [1,2,3] paired with each element from the list ['a','b']."
sum :: [Int] -> Int, "Define a function 'sum' that takes a list of integers and returns their sum."
sum [] = 0, "Base case: If the list is empty, the sum is 0."
sum (x:xs) = x + sum xs, "Recursive case: If the list is not empty, sum the head of the list 'x' with the sum of the rest of the list 'xs'."
evens :: [Int] -> [Int], "Define a function 'evens' that takes a list of integers and returns a list containing only the even integers."
evens [] = [], "Base case: If the list is empty, the result is an empty list."
evens (x:xs)
 | mod x 2 == 0 = x : evens xs, "If the head of the list 'x' is even, add to the result list, and the function is called recursively on the rest of the list 'xs'."
 | otherwise = evens xs, "If the head of the list 'x' is odd, it is not added to the result list, and the function is called recursively on the rest of the list 'xs'."
(1,2) :: (Int, Int), "Represent a tuple containing two integers."
"fst :: (a,b) -> a", "Return the first element of a tuple."
"fst (x,_) = x", "Define the function 'fst' which extracts the first element of a tuple."
"snd :: (a,b) -> b", "Return the second element of a tuple."
"snd (_,y) = y", "Define the function 'snd' which extracts the second element of a tuple."
"let (x,y) = (1,2) in x", "Bind the tuple (1,2) to variables x and y, then returns the value of x, which is 1."
"addTuples :: [(Int, Int)] -> [Int]", "Define a function 'addTuples' that takes a list of tuples of integers and returns a list of integers."
addTuples xs = [ x+y | (x,y) <- xs ], "Generate a list by adding the first and second elements of each tuple in the input list."
addTuples [(1,2), (2,3), (100,100)], "Call the function 'addTuples' with a list of tuples [(1,2), (2,3), (100,100)], resulting in [3,5,200]."
app :: (a -> b) -> a->b, "Define a higher-order function 'app' that takes a function 'f' and a value 'x' as arguments, and applies 'f' to 'x'."
app f x = f x, "Implement the 'app' function by applying the function 'f' to the value 'x'."
(\x -> x+1), "Define an anonymous function that takes a parameter 'x' and returns 'x+1'."
add1 = (\x -> x+1), "Bind the anonymous function (\x -> x+1) to the name 'add1'."
(\x y z -> x+y+z), "Define an anonymous function that takes three parameters 'x', 'y', and 'z', and returns their sum."
(\x -> x+1) 1, Applly the anonymous function (\x -> x+1) to the value 1, resulting in 2."
(\x y z -> x+y+z) 1 2 3, Applly the anonymous function (\x y z -> x+y+z) to the values 1, 2, and 3, resulting in 6."
app :: (a -> b) -> a->b, "Define a higher-order function 'app' that takes a function 'f' and a value 'x' as arguments, and applies 'f' to 'x'."
app f x = f x, "Implement the 'app' function by applying the function 'f' to the value 'x'."
app (\x -> x+1) 1, "Applly the anonymous function (\x -> x+1) to the value 1 using the 'app' function, resulting in 2."
map :: (a -> b) -> [a] -> [b], "Define a function 'map' that takes a function 'f' and a list 'xs' as arguments, and applies 'f' to each element of 'xs', returning a list of the results."
map (\x -> x+1) [1,2,3,4,5], "Applly the anonymous function (\x -> x+1) to each element of the list [1,2,3,4,5] using 'map', resulting in [2,3,4,5,6]."
map (\(x,y) -> x+y) [(1,2), (2,3), (3,4)], "Applly the anonymous function (\(x,y) -> x+y) to each tuple in the list [(1,2), (2,3), (3,4)] using 'map', resulting in [3,5,7]."
filter :: (a -> Bool) -> [a] -> [a], "Define a function 'filter' that takes a predicate function 'f' and a list 'xs' as arguments, and returns a list containing only the elements of 'xs' for which 'f' returns True."
filter (\x -> x>2) [1,2,3,4,5], "Filter the list [1,2,3,4,5] using the predicate function (\x -> x>2), resulting in [3,4,5]."
filter (\(x,y) -> x/=y) [(1,2), (2,2)], "Filter the list of tuples [(1,2), (2,2)] using the predicate function (\(x,y) -> x/=y), resulting in [(1,2)]."
f :: a -> b -> c -> d, "Define a function 'f' that takes three arguments of types 'a', 'b', and 'c', and returns a value of type 'd'."
f :: a -> (b -> (c -> d)), "Alternatively define the function 'f' using currying syntax, where it takes an argument of type 'a' and returns a function that takes an argument of type 'b' and returns another function that takes an argument of type 'c' and finally returns a value of type 'd'."
add :: Int -> Int -> Int,"Define a function 'add' which takes two 'Int' arguments and returns an 'Int'."
add x y = x+y,"Define the 'add' function such that it takes two arguments 'x' and 'y', then returns their sum."
add x = (\y -> x+y),"Define the 'add' function where it partially applies 'x' to a lambda function taking 'y' as argument, returning their sum."
add = (\x -> (\y -> x+y)),"Define the 'add' function as a composition of two lambda functions, the outer one taking 'x' and the inner one taking 'y', returning their sum."
add :: Int -> Int -> Int,"Define a function 'add' which takes two 'Int' arguments and returns an 'Int'."
add = (\x -> (\y -> x+y)),"Define the 'add' function as a composition of two lambda functions, the outer one taking 'x' and the inner one taking 'y', returning their sum."
add 1 :: Int -> Int,"Partially apply the 'add' function with '1' as the first argument, resulting in a function that takes an 'Int' and returns an 'Int' by adding '1' to its argument."
map :: (a -> b) -> [a] -> [b],"Define a function 'map' which takes a function from 'a' to 'b' and a list of 'a's, returning a list of 'b's."
doubleList = map (\x -> 2*x),"Define the 'doubleList' function using 'map' with a lambda function that doubles its argument."
descSort = reverse . sort,"Define 'descSort' as the composition of 'reverse' and 'sort' functions."
descSort = (\x -> reverse (sort x)),"Define 'descSort' as a lambda function that reverses the sorted input list 'x'."
descSort x = reverse (sort x),"Define 'descSort' as a function that takes an argument 'x' and returns the reverse of the sorted 'x'."
map2D :: (a -> b) -> [[a]] -> [[b]],"Declare 'map2D' as a function taking a function from 'a' to 'b' and a list of lists of 'a's, returning a list of lists of 'b's."
map2D = map . map,"Define 'map2D' as the composition of 'map' function applied twice."
map2D x = (\xs -> map (\ys -> map x ys) xs),"Define 'map2D' as a function taking an argument 'x' and returning a function that maps 'x' over each element of a list of lists."
f xs = map (\x -> x+1) (filter (\x -> x>1) xs),"Define the function 'f' which takes a list 'xs' and applies a mapping and filtering operation sequentially."
f xs = map (\x -> x+1) $ filter (\x -> x>1) xs,"Define the function 'f' where the '$' operator is used to replace the parentheses, indicating that the result of 'filter' is passed as an argument to 'map'."
sum = foldr (+) 0,"Define 'sum' as a fold operation using the '+' operator and starting with an initial accumulator of '0'."
and = foldr (&&) True,"Define 'and' as a fold operation using the '&&' operator and starting with an initial accumulator of 'True'."
or = foldr (||) False,"Define 'or' as a fold operation using the '||' operator and starting with an initial accumulator of 'False'."
count e = foldr (\x acc -> if e == x then acc+1 else acc) 0,"Define 'count' as a fold operation that counts occurrences of 'e' in a list."
isAll e = foldr (\x acc -> e == x && acc) True,"Define 'isAll' as a fold operation that checks if all elements in the list are equal to 'e'."
length = foldr (\_ acc -> acc + 1) 0,"Define 'length' as a fold operation that counts the length of the list."
map f = foldr ((:) . f) [],"Define 'map' as a fold operation that applies function 'f' to each element of the list and constructs a new list."
foldr (\elem acc -> <term>) <start_acc> <list>,"Define a fold operation where the function takes an element and an accumulator as arguments, starting with an initial accumulator value, and folding from the right over the list."
foldr (\acc elem -> <term>) <start_acc> <list>,"Define a fold operation where the function takes an accumulator and an element as arguments, starting with an initial accumulator value, and folding from the right over the list."
data Calculation = Add Int Int | Sub Int Int | Mul Int Int | Div Int Int,"Define a datatype 'Calculation' with constructors 'Add', 'Sub', 'Mul', and 'Div', each taking two 'Int' arguments."
calc :: Calculation -> Int,"Define a function 'calc' which takes a 'Calculation' and returns an 'Int'."
calc (Add x y) = x+y,"Define the 'calc' function pattern matching on the 'Add' constructor, returning the sum of 'x' and 'y'."
calc (Sub x y) = x-y,"Define the 'calc' function pattern matching on the 'Sub' constructor, returning the difference of 'x' and 'y'."
calc (Mul x y) = x*y,"Define the 'calc' function pattern matching on the 'Mul' constructor, returning the product of 'x' and 'y'."
calc (Div x y) = div x y,"Define the 'calc' function pattern matching on the 'Div' constructor, returning the division of 'x' by 'y'."
data Person = person {name :: String, age :: Int},"Define a datatype 'Person' with record syntax having fields 'name' of type 'String' and 'age' of type 'Int'."
name :: Person -> String,"Define a function 'name' which takes a 'Person' and returns their name."
age :: Person -> Int,"Define a function 'age' which takes a 'Person' and returns their age."
greet :: Person -> String,"Define a function 'greet' which takes a 'Person' and returns a greeting string."
"greet person = ""Hi"" ++ name person","Define 'greet' function to concatenate ""Hi"" with the name of the person passed as argument."
greet (Person name_) = "Hi" ++ name_,"Define 'greet' function pattern matching on 'Person' constructor with 'name_' as its argument, concatenating ""Hi"" with 'name_'."
greet (Person n_) = "Hi" ++ n_,"Define 'greet' function pattern matching on 'Person' constructor with 'n_' as its argument, concatenating ""Hi"" with 'n_'."
data Point = D2 {x :: Int, y :: Int} | D3 {x :: Int, y :: Int, z :: Int},"Define a datatype 'Point' with two constructors: 'D2' taking 'x' and 'y' coordinates, and 'D3' taking 'x', 'y', and 'z' coordinates."
x (D2 1 2),"Access the 'x' coordinate of a 2D point, yielding '1'."
x (D3 1 2 3),"Access the 'x' coordinate of a 3D point, yielding '1'."
(+) :: Num a => a -> a -> a,"Define an operator '+' which takes two arguments of type 'a' belonging to the 'Num' typeclass and returns a value of the same type."
sum :: Num p => [p] -> p,"sum is a function which takes a list of values of type 'p' belonging to the 'Num' typeclass and returns a single value of type 'p'."
sum [] = 0,"Define the base case of the sum function where an empty list is given, it returns 0."
sum (x:xs) = x + sum xs,"Define the recursive case of the sum function where a non-empty list is given. It adds the first element 'x' to the result of recursively summing the rest of the list 'xs'."
Class Num a where,"Declare a typeclass 'Num' which represents numeric types."
(+) :: a -> a -> a,"Define the addition operation '+' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
(-) :: a -> a -> a,"Define the subtraction operation '-' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
(*) :: a -> a -> a,"Define the multiplication operation '*' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
negate :: a -> a,"Define the negation operation 'negate' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
abs :: a -> a,"Define the absolute value operation 'abs' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
signum :: a -> a,"Define the signum operation 'signum' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
fromInteger :: Integer-> a,"Define a conversion function 'fromInteger' within the 'Num' typeclass which takes an Integer and returns a value of type 'a'."
Class Show a where,"Declare a typeclass 'Show' which represents types that can be converted to strings."
showsPrec :: Int -> a -> ShowS,"Define a function 'showsPrec' within the 'Show' typeclass which takes an integer and a value of type 'a', and returns a 'ShowS' function."
show :: a -> String,"Define a function 'show' within the 'Show' typeclass which takes a value of type 'a' and returns a string representation."
showList :: [a] -> ShowS,"Define a function 'showList' within the 'Show' typeclass which takes a list of values of type 'a' and returns a 'ShowS' function."
data Temperature = C Float | F Float,"Define a datatype 'Temperature' with two constructors 'C' and 'F' representing temperatures in Celsius and Fahrenheit respectively."
instance Eq Temperature where,"Declare an instance of the 'Eq' typeclass for the 'Temperature' datatype."
(==) (C n) (C m) = n == m,"Define the equality operator '==' for comparing two temperatures in Celsius. It returns true if their values are equal."
(==) (F n) (F m) = n == m,"Define the equality operator '==' for comparing two temperatures in Fahrenheit. It returns true if their values are equal."
(==) (C c) (F f) = (1.8*c + 32) == f,"Define the equality operator '==' for comparing a temperature in Celsius with a temperature in Fahrenheit. It returns true if the Celsius temperature, when converted to Fahrenheit, is equal to the given Fahrenheit temperature."
(==) (F f) (C c) = (1.8*c + 32) == f,"Define the equality operator '==' for comparing a temperature in Fahrenheit with a temperature in Celsius. It returns true if the Celsius temperature, when converted to Fahrenheit, is equal to the given Fahrenheit temperature."
data Temperature = C Float | F Float deriving (Show, Eq),"Define a datatype 'Temperature' with two constructors 'C' and 'F' representing temperatures in Celsius and Fahrenheit respectively. Also, derive instances for the 'Show' and 'Eq' typeclasses for the Temperature datatype."
Derived equivalence:,"Describe the derived equivalence for the 'Eq' instance of the 'Temperature' datatype."
(==) (C n) (C m) = n == m,"Define the equality operator '==' for comparing two temperatures in Celsius. It returns true if their values are equal."
(==) (F n) (F m) = n == m,"Define the equality operator '==' for comparing two temperatures in Fahrenheit. It returns true if their values are equal."
(==)  _ _ = False,"Define a catch-all case for the equality operator '==' which returns false for any other combination of temperatures."
import Data.Maybe,"Import the 'Data.Maybe' module to access functions related to the 'Maybe' datatype."
isJust :: Maybe a -> Bool,"Define a function 'isJust' which takes a 'Maybe' value and returns 'True' if it is a 'Just' value, otherwise returns 'False'."
isNothing :: Maybe a -> Bool,"Define a function 'isNothing' which takes a 'Maybe' value and returns 'True' if it is a 'Nothing' value, otherwise returns 'False'."
fromJust :: Maybe a -> a,"Define a function 'fromJust' which extracts the value from a 'Just' constructor. Caution: This function throws an error if given a 'Nothing' value, so it should be used with care."
fromMaybe :: a -> Maybe a  -> a,"Define a function 'fromMaybe' which takes a default value and a 'Maybe' value. If the 'Maybe' value is 'Just', it returns the contained value, otherwise it returns the default value."
putStrLn "Hello World","Prints 'Hello World' to the console."
hw = putStrLn "Hello World","Define a function 'hw' that prints 'Hello World' to the console when called."
hw :: IO (),"Declares the type of 'hw' as IO action that returns nothing."
getLine :: IO String,"Define an IO action 'getLine' that reads a line of input from the user and returns it as a String."
greet :: IO (),"Declares a function 'greet' that performs IO actions."
greet = do\n   putStrLn "What is your name?"\n   name <- getLine\n   putStrLn ("Hello " ++ name ++ "."),"Define 'greet' function which prompts the user for their name, reads the input, and prints a greeting message."
greet = do\n   putStrLn "What is your name?"\n   name <- getLine\n   let uname = map toUpper name\n   putStrLn ("Hello " ++ uname ++ "."),"Define 'greet' function which prompts the user for their name, reads the input, converts it to uppercase, and prints a greeting message."
main :: IO (),"Declares the main function."
main = do\n i <- getLine\n if i /= "quit" then do\n    putStrLn ("Input: "++ i)\n    main\n else\n    return (),"Define the main function which repeatedly prompts the user for input until 'quit' is entered, then terminates."
count :: Int -> Int -> IO (),"Declares a function 'count' that takes two integers and performs IO actions."
count n m = do\n  putStrLn (show n)\n  if n<m then\n      count (n+1) m\n  else\n      return (),"Define 'count' function which prints numbers from 'n' to 'm', inclusively."
f :: [a] -> [a],"Declare a function `f` which takes a list of type `a` and returns a list of the same type."
f = reverse . sort,"Define `f` as a composition of `reverse` and `sort` functions."
add :: (Num d) => d -> d -> [d] -> [d],"Declares a function `add` which takes three arguments of type `d` and returns a list of type `[d]`."
add x y z = (x + y) : z,"Define the `add` function to add `x` and `y`, then prepend the result to list `z`."
f :: Ord a => [a] -> [a],"Specify the type of `f` to be a function taking a list of `Ord` type `a` and returning a list of the same type."
f X = X : X,"Define a function `f` which takes an argument `X` and prepends it twice to itself, which results in a type error due to infinite recursion."
class Applicative m => Monad (m :: * -> *) where,"Declare the Monad type class, which extends the Applicative type class."
  (>>=) :: m a -> (a -> m b) -> m b,"Define the bind operator `(>>=)` which sequences two monadic actions."
  (>>) :: m a -> m b -> m b,"Define the sequencing operator `(>>)`, which discards the result of the first action and executes the second action."
  return :: a -> m a,"Wrap a value into the monadic context."
  fail :: String -> m a,"Handle failure within a monadic computation."
  {-# MINIMAL (>>=) #-},"Specify that the `bind` operator is the minimal complete definition for a Monad instance."
instance Monad (Either e),"Define a Monad instance for the Either type constructor."
instance Monad [],"Define a Monad instance for lists."
instance Monad Maybe,"Define a Monad instance for Maybe type."
instance Monad IO,"Define a Monad instance for IO actions."
instance Monad ((->)),"Define a Monad instance for functions."
instance Monad a => Monad ((,) a),"Define a Monad instance for pairs."
(>>=) :: Monad m => m a -> (a -> m b) -> m b,"Define the bind operator `(>>=)` which sequences two monadic actions."
Just 1 >>= (\x -> Just x),"Bind the value `1` wrapped in a Just context to the function `(\x -> Just x)`, resulting in Just 1."
Nothing >>= (\x -> Just x),"Bind `Nothing` to the function `(\x -> Just x)`, resulting in Nothing."
maybeadd :: Num b => Maybe b -> b -> Maybe b,"Define a function `maybeadd` that adds a value to a Maybe-wrapped value."
maybeadd mx y = mx >>= (\x -> Just $ x+y),"Use bind operator `(>>=)` to extract the value from `mx`, adds `y` to it, and wraps the result in a Just context."
maybeadd Nothing 1,"Applly `maybeadd` function with `Nothing` and `1`, resulting in Nothing."
maybeadd (Just 1) 1,"Applly `maybeadd` function with `Just 1` and `1`, resulting in Just 2."
maybeadd :: Num b => Maybe b -> Maybe b -> Maybe b,"Redefine `maybeadd` to accept two Maybe-wrapped values and add them."
maybeadd mx my = mx >>= (\x -> my >>= (\y -> Just $ x+y)),"Use nested bind operators to sequentially extract values from `mx` and `my`, adds them, and wraps the result in a Just context."
maybeadd Nothing (Just 1),"Applly `maybeadd` function with `Nothing` and `Just 1`, resulting in Nothing."
maybeadd (Just 2) (Just 1),"Applly `maybeadd` function with `Just 2` and `Just 1`, resulting in Just 3."
monadd :: (Monad m, Num b) => m b -> m b -> m b,"Define a function `monadd` that adds two monadic values."
monadd mx y = mx >>= (\x -> my >>= (\y -> return $ x+y)),"Use bind operator `(>>=)` and `return` to sequentially extract values from `mx` and `my`, add them, and wrap the result in the monadic context."
monadd mx my = do,"Define `monadd"
instance Monad Maybe where,"Declare an instance of the Monad type class for the Maybe type."
m >>= f = case m of,"Define a function (>>=) which takes a Maybe value m and a function f, and performs a case analysis on m."
Nothing -> Nothing,"If m is Nothing, then return Nothing."
Just x -> f x,"If m is Just x, then apply the function f to the value x inside the Just constructor."
return v = Just v,"Define the return function for the Maybe monad, which takes a value v and wraps it in a Just constructor."
(>>) :: Monad m => m a -> m b -> m b,"Define the (>>) operator for any monad, taking two monadic values of types m a and m b respectively, and producing a monadic value of type m b."
m>>n = m >>= \_-> n,"Define the implementation of (>>) operator, which sequences two monadic computations. It applies the first computation m, discards its result using a lambda function, and then proceeds to execute the second computation n."
Nothing >> Just 1,"Perform the (>>) operation with Nothing and Just 1, resulting in Nothing."
Just 1 >> Just 2,"Perform the (>>) operation with Just 1 and Just 2, resulting in Just 2."
Just 1 >> Nothing,"Perform the (>>) operation with Just 1 and Nothing, resulting in Nothing."
prop a b = (a+b) == (b+a),"Define a property named prop that checks if the sum of two numbers a and b is equal to the sum of b and a."
prop xs = (length $ tail xs) == ((length xs) -1),"Define a property named prop that checks if the length of the tail of a list xs is equal to the length of xs minus one."
prop xs = not (null xs) ==> (length xs) -1),"Define a property named prop that states if xs is not null, then the length of xs minus one is equal to itself."
prop xs = not (null xs) ==> (length $ tail xs) === ((length xs) -1),"Define a property named prop that states if xs is not null, then the length of the tail of xs is equal to the length of xs minus one."
rev xs = rev_aux [] xs
where
  rev_aux acc [] = acc
  rev_aux acc (x:xs) =  rev_aux (x:acc) xs,"Define a function rev that reverses a list xs using an auxiliary function rev_aux. The rev_aux function accumulates elements in reverse order into an accumulator list acc, and once the input list becomes empty, it returns the accumulator."
propRev xs = reverse xs === rev xs,"Define a property named propRev that checks if reversing a list xs using the reverse function is equal to reversing it using the custom rev function."
prop k v m = lookup k ((k,v): m) === Just v
   where types = (k :: Int, v :: Int),"Define a property named prop that checks if looking up a key k in a list that contains a tuple (k,v) results in Just v."
ones = 1 : ones,"Define an infinite list named ones where each element is 1 followed by itself, creating an infinite cycle."
ones = 1 : 1 : ones,"Define an infinite list named ones where the first two elements are both 1, followed by itself, creating an infinite cycle."
ones = 1 : ones
tail ones
==> 1 : ones ,"Define an infinite list named ones where each element is 1 followed by itself. Then, take the tail of the list ones, resulting in a list with all elements same as ones except the first one."
ones = 1 : ones
take 5 (map (*2) ones)
   ==> [2,2,2,2,2] ,"Define an infinite list named ones where each element is 1 followed by itself. Then, take the first 5 elements of the list obtained by doubling each element of ones."
nat = asc 1
 where asc n = n: (asc $ n+1),"Define an infinite list named nat where each element is an ascending sequence starting from 1."
evens = map (*2) nat
odds = filter (\x -> mod x 2 == 0) nat,"Define an infinite list named evens where each element is twice the corresponding element in the list nat. Also, define an infinite list named odds where each element is an even number from the list nat using filtering."
data Either a b = Left a | Right b,"Define a data type 'Either' which represents a value of one of two possible types, 'a' or 'b'."
type SomeData = Either Int String,[Left 1, Right "Hello"] :: [SomeData],"Define a type synonym 'SomeData' for 'Either Int String', and creates a list containing a 'Left' value with 1 and a 'Right' value with 'Hello'."
import Data.Either,"Imports the 'Data.Either' module."
lefts :: [Either a b] -> [a],"Define a function 'lefts' that takes a list of 'Either' values and returns a list containing only the 'Left' values."
rights :: [Either a b] -> [b],"Define a function 'rights' that takes a list of 'Either' values and returns a list containing only the 'Right' values."
isleft :: Either a b -> Bool,"Define a function 'isleft' that checks whether the given 'Either' value is of the 'Left' type."
isright :: Either a b -> Bool,"Define a function 'isright' that checks whether the given 'Either' value is of the 'Right' type."
fromleft :: a -> Either a b -> a,"Define a function 'fromleft' that extracts the value from a 'Left' constructor or returns a default value."
fromright :: b -> Either a b -> b,"Define a function 'fromright' that extracts the value from a 'Right' constructor or returns a default value."
either :: (a ->c) -> (b -> c) -> Either a b -> c,"Define the 'either' function which takes two functions and an 'Either' value, applies the first function to the 'Left' value or the second function to the 'Right' value, and returns the result."
f = either (\l -> "Number") (\r -> r),"Define a function 'f' which uses the 'either' function to map 'Left' values to 'Number' and 'Right' values to themselves."
f (Left 1),"Applies 'f' to a 'Left' value with 1, resulting in 'Number'."
f (Right "Hello"),"Applies 'f' to a 'Right' value with 'Hello', resulting in 'Hello'."
data Either a b = Left a | Right b,"Define a data type 'Either' which represents a value of one of two possible types, 'a' or 'b', typically used for error handling where 'Left' indicates an error and 'Right' indicates a successful result."
data Maybe a = Nothing | just a,"Define a data type 'Maybe' which represents an optional value, where 'Nothing' indicates absence of a value and 'Just' wraps a value of type 'a'."
import Module,"Imports all the entities (functions, types, etc.) from the module 'Module' into the current namespace."
import Module (name1, name2),"Imports only the specified entities 'name1' and 'name2' from the module 'Module' into the current namespace."
import Module hiding (name1, name2),"Imports all entities from the module 'Module' into the current namespace except for 'name1' and 'name2'."
import qualified Module,"Imports all entities from the module 'Module' but qualifies them with the module name, so they need to be accessed using the module name prefix."
Module.name,"Accesses the entity 'name' from the module 'Module'."
import Module as NewName,"Imports all entities from the module 'Module' into the current namespace but renames the module to 'NewName', allowing access to its entities using the new name."
data DataType = A | B | C\nimport Module (dataType(...)),"Define a data type 'DataType' with constructors 'A', 'B', and 'C'. Then imports only the specified data type constructors from the module 'Module'."
or
import Module (dataType(A,C)),"Imports only the specified data type constructors 'A' and 'C' from the module 'Module'."
import System.Environment,"Import the System.Environment module to access environment-related functions."
import System.Exit,"Import the System.Exit module to handle program exit."
progname arg1 arg2 arg3 arg4,"Define a program with four arguments."
greet Hello,"Define a function 'greet' that takes a string argument and prints 'Hello user' with the argument appended."
:> greet Hello,"Invoke the 'greet' function with the argument 'Hello'."
import System.Environment,"Import the System.Environment module to access environment-related functions."
import System.Exit,"Import the System.Exit module to handle program exit."
progname arg1 arg2 arg3 arg4,"Define a program with four arguments."
getProgname :: IO String,"Define a function 'getProgname' which returns the program name as an IO action."
getProgname = System.Environment.getProgname,"Assign the 'getProgname' function to retrieve the program name."
withArgs :: [String] -> IO a -> IO a,"Define a function 'withArgs' which takes a list of strings and an IO action, and executes the action with the specified arguments."
withArgs args action = System.Environment.withArgs args action,"Implement the 'withArgs' function using 'System.Environment.withArgs'."
WithProgName :: String -> IO a -> IO a,"Define a function 'WithProgName' which takes a string representing a new program name and an IO action, and executes the action with the specified program name."
WithProgName name action = System.Environment.withProgName name action,"Implement the 'WithProgName' function using 'System.Environment.withProgName'."
data ExitCode = ExitSuccess | ExitFailure Int,"Define a custom data type 'ExitCode' which represents the status of program termination, either success or failure with an integer code."
exitWith :: ExitCode -> IO a,"Define a function 'exitWith' which takes an ExitCode and performs an IO action that terminates the program with the specified exit code."
exitWith code = System.Exit.exitWith code,"Implement the 'exitWith' function using 'System.Exit.exitWith'."
exitFailure :: IO a,"Define a function 'exitFailure' which performs an IO action that terminates the program with a failure status."
exitFailure = System.Exit.exitFailure,"Implement the 'exitFailure' function using 'System.Exit.exitFailure'."
exitSuccess :: IO a,"Define a function 'exitSuccess' which performs an IO action that terminates the program with a success status."
exitSuccess = System.Exit.exitSuccess,"Implement the 'exitSuccess' function using 'System.Exit.exitSuccess'."
die :: String -> IO a,"Define a function 'die' which takes a string argument and performs an IO action that terminates the program with a failure status and prints the specified string as an error message."
die msg = do { putStrLn msg; exitFailure },"Implement the 'die' function to print the error message followed by exiting with failure status."













