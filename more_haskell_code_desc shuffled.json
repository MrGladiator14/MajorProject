[
  {
    "Statement": "where f = reverse . dropWhile isSpace",
    "Description": "Define the function `f` to remove trailing whitespace."
  },
  {
    "Statement": "\"(Vrv e setT r. rv > v)\"",
    "Description": "Assume that for every rv in the set of r, rv is greater than v."
  },
  {
    "Statement": "con \"logicalAnd\" ((&&) :: Bool -> Bool -> Bool),",
    "Description": "Include the 'logicalAnd' function signature."
  },
  {
    "Statement": "import Data.List (partition)\n\nsplitEvenOdd :: [Int] -> ([Int], [Int])",
    "Description": "Define a function 'splitEvenOdd' that takes a list of integers and returns a tuple containing two lists: one with the even numbers and one with the odd numbers. Import the 'partition' function from the 'Data.List' module."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "(Just v) -> f v",
    "Description": "If maybe_val is Just v, apply the function f to v and return the result."
  },
  {
    "Statement": "proof (induction xs)",
    "Description": "Apply induction on the list."
  },
  {
    "Statement": "f a b = if a 'mod' 2 == 0 then a else b",
    "Description": "Define a function f that takes two arguments a and b, if a is even, return a, otherwise return b."
  },
  {
    "Statement": "| n `mod` 2 == 0 = True",
    "Description": "If `n` is even, return `True`."
  },
  {
    "Statement": "take :: Int -> Seq a -> Seq a",
    "Description": "Declare a function take that returns the specified number of elements from the beginning of a sequence."
  },
  {
    "Statement": "calc (Add x y) = x+y",
    "Description": "Define the 'calc' function pattern matching on the 'Add' constructor, returning the sum of 'x' and 'y'."
  },
  {
    "Statement": "| p x       = x : takeWhile p xs",
    "Description": "If the predicate `p` holds true for `x`, include `x` in the result."
  },
  {
    "Statement": "foldl1 :: (a -> a -> a) -> [a] -> a",
    "Description": "Define 'foldl1' as a function which takes a binary function and a list, and applies the function in a left-associative manner to the elements of the list, assuming that the list is non-empty."
  },
  {
    "Statement": "class Functor f => Monoidal f where\n\n    unit :: f ()\n\n    (\\*\\*) :: f a -> f b -> f (a,b)",
    "Description": "Define a typeclass Monoidal that extends the Functor typeclass. It has two member functions: unit that returns a functor f () representing the unit value, and (\\*\\*) that takes two functors f a and f b and returns a functor f (a,b) representing their product."
  },
  {
    "Statement": "instance MonadTrans (ReaderT r) where\n    lift m = ReaderT (const m)",
    "Description": "Provide an instance of the 'MonadTrans' type class for the 'ReaderT' monad transformer. This instance allows for lifting computations into the 'ReaderT' monad transformer."
  },
  {
    "Statement": "readUntilWithCount :: String -> IO Int",
    "Description": "Declare a function readUntilWithCount that takes a String argument and returns an IO Int value."
  },
  {
    "Statement": "]",
    "Description": "End of the list."
  },
  {
    "Statement": "instance Monad ((->) r)",
    "Description": "Create an instance of the Monad typeclass for the function type constructor (->) r, which represents computations that take a value of type r as input and return a value of type a."
  },
  {
    "Statement": "apply (cases \"contains P xs\")",
    "Description": "Begin a case analysis on whether `P` is contained in the list `xs`."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "hn = n",
    "Description": "Assign `hn` the value of `n`."
  },
  {
    "Statement": "name :: Person -> String",
    "Description": "Define a function 'name' which takes a 'Person' and returns their name."
  },
  {
    "Statement": "import Test.QuickCheck-Arbitrary",
    "Description": "Import the Test.QuickCheck-Arbitrary module."
  },
  {
    "Statement": "newtype Any a = Any { getAny :: a }",
    "Description": "Define a new data type called 'Any' with a single constructor 'Any' that wraps a value of type 'a'. The 'getAny' function extracts the value of type 'a' from the 'Any' constructor."
  },
  {
    "Statement": "map [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "append :: List a -> List a -> List a",
    "Description": "Define a function named append which takes two Lists of elements of type a and returns their concatenation as a List of the same type."
  },
  {
    "Statement": "toLowerCase = map toLower",
    "Description": "The implementation of 'toLowerCase' applies the 'toLower' function to each character in the input string using the 'map' function."
  },
  {
    "Statement": "\"shows 'sorted (inorder l @ [v] @ inorder r)'\"",
    "Description": "Show that the inorder traversal of `l`, followed by `v`, followed by the inorder traversal of `r`, is sorted."
  },
  {
    "Statement": "theory Tree",
    "Description": "Define a theory named `Tree`."
  },
  {
    "Statement": "exitFailure = System.Exit.exitFailure",
    "Description": "Implement the 'exitFailure' function using 'System.Exit.exitFailure'."
  },
  {
    "Statement": "fun mirror (Node l v r) = Node (mirror r) v (mirror l)",
    "Description": "Otherwise, create a node with mirrored left and right branches."
  },
  {
    "Statement": "empty :: Set a",
    "Description": "Declare an empty set."
  },
  {
    "Statement": "rotateList :: Int -> [a] -> [a]",
    "Description": "Define a function rotateList that takes an Int and a list, and rotates the list to the left by the specified number of positions."
  },
  {
    "Statement": "contains P [] = False",
    "Description": "Define `contains` as a function that returns `False` when the list is empty."
  },
  {
    "Statement": "sortBy _ [] = []",
    "Description": "Define the case of the sortBy function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "Class Num a where",
    "Description": "Declare a typeclass 'Num' which represents numeric types."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
    "Description": "Define a function bindIOM that takes an IOMaybe a and a function from a to IOMaybe b, and returns an IOMaybe b."
  },
  {
    "Statement": "bubbleUp x [] = [x]",
    "Description": "If the accumulator is empty, return a singleton list containing x."
  },
  {
    "Statement": "nub (x:xs) = x : nub (filter (/= x) xs)",
    "Description": "Define the recursive case of the nub function where a non-empty list is given. It adds the first element 'x' to the result and then recursively applies nub to the remaining list without the elements equal to 'x'."
  },
  {
    "Statement": "toUpperCase :: String -> String",
    "Description": "Define a function toUpperCase that takes a String and converts it to uppercase."
  },
  {
    "Statement": "append (Cons x xs) ys = Cons x (append xs ys)",
    "Description": "Otherwise, prepend the head of the first list to the result of recursively calling append with the tail of the first list and the second list."
  },
  {
    "Statement": "import Data.List",
    "Description": "Import the Data.List module which provides list manipulation functions."
  },
  {
    "Statement": "\\x y z -> x+y+z",
    "Description": "Define an anonymous function that takes three parameters 'x', 'y', and 'z', and returns their sum."
  },
  {
    "Statement": "f :: a -> b -> c -> d",
    "Description": "Define a function 'f' that takes three arguments of types 'a', 'b', and 'c', and returns a value of type 'd'."
  },
  {
    "Statement": "deriving (Eq, Ord)",
    "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Sum' data type."
  },
  {
    "Statement": "readUntil ending = do",
    "Description": "Begin the definition of the `readUntil` function using the do notation for monadic computations."
  },
  {
    "Statement": "fst (x,) = x",
    "Description": "Define the function 'fst' which extracts the first element of a tuple."
  },
  {
    "Statement": "bSort [] acc = acc",
    "Description": "If the input list is empty, return the accumulator."
  },
  {
    "Statement": "using assms sorted append by fastforce",
    "Description": "Use the given sorted lemma and fastforce tactic to solve the subgoal."
  },
  {
    "Statement": "case (Cons x xs)",
    "Description": "If the case is a non-empty list."
  },
  {
    "Statement": "inorder (Node l v r) = inorder l ++ [v] ++ inorder r;",
    "Description": "Traverse the left subtree, add 'v', and then traverse the right subtree."
  },
  {
    "Statement": "                       _ : s'' -> lines s''",
    "Description": "Define the condition for the recursive case of the lines function. If the remaining string is not empty, it recursively processes the remaining string."
  },
  {
    "Statement": "take n _ | n <= 0 = []",
    "Description": "If `n` is less than or equal to 0, return an empty list."
  },
  {
    "Statement": "stringToInt = foldl (\\acc x -> acc * 10 + digitToInt x) 0",
    "Description": "The implementation of 'stringToInt' uses 'foldl' to iterate over the characters in the input string, converting each digit character to an integer using 'digitToInt', and accumulating the resulting value by multiplying the previous value by 10 and adding the new digit."
  },
  {
    "Statement": "runStateT :: StateT sm a ->s → m (a, s)",
    "Description": "Declare a function runStateT that takes a StateT computation and an initial state, and returns a monadic computation that produces a tuple containing the final result and the final state."
  },
  {
    "Statement": "mapM_ f = foldr ((>>) . f) (return ())",
    "Description": "Define 'mapM_' as a fold operation that maps each element of a structure to a monadic action, and evaluates these actions from left to right, discarding the results."
  },
  {
    "Statement": "apply (auto)",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "bubbleSort [] = []",
    "Description": "If the input list is empty, return an empty list."
  },
  {
    "Statement": "loop f b = let (c, d) = f(b, d) in c",
    "Description": "Define the loop function for the ArrowApply instance of (->) that takes a function f and a value b, applies f to (b, d) where d is some undefined value, and returns the first component of the result."
  },
  {
    "Statement": "maybe_val <- iom",
    "Description": "Bind the result of evaluating iom to maybe_val."
  },
  {
    "Statement": "instance Num a => Monoid (Sum a) where",
    "Description": "Define a 'Monoid' instance for the 'Sum' data type, constrained by the 'Num' type class constraint on 'a'."
  },
  {
    "Statement": "[2*x | x <- [1,2,3], x>1 ]",
    "Description": "Generate a list where each element is obtained by doubling each element of the list [1,2,3], but only if the element is greater than 1."
  },
  {
    "Statement": "liftIOm :: IO a -> IOMaybe a",
    "Description": "Define a function liftIOm that takes an IO a and returns an IOMaybe a."
  },
  {
    "Statement": "commonElements xs ys = intersect xs ys",
    "Description": "The implementation of 'commonElements' simply applies the 'intersect' function to the two input lists 'xs' and 'ys'."
  },
  {
    "Statement": "addSig::\n[Sig]",
    "Description": "Define 'addSig' as a list of Sig."
  },
  {
    "Statement": "import Module (name1, name2)",
    "Description": "Imports only the specified entities 'name1' and 'name2' from the module 'Module' into the current namespace."
  },
  {
    "Statement": "\"sortedT t = sorted (inorder t)\"",
    "Description": "Define sortedT as a function that checks if the tree is sorted by using the inorder traversal."
  },
  {
    "Statement": "lines :: String -> [String]",
    "Description": "Define 'lines' as a function which breaks a string up into a list of strings at newline characters."
  },
  {
    "Statement": "con\n\"e\" (0 :: Int)\n]",
    "Description": "Declare the constant 'e' as '0' of type Int."
  },
  {
    "Statement": ":> greet Hello",
    "Description": "Invoke the 'greet' function with the argument 'Hello'."
  },
  {
    "Statement": "let ncount = count + 1",
    "Description": "Calculate the new count `ncount` by incrementing the current `count` by 1."
  },
  {
    "Statement": "con \":\" ((:) :: A -> [A] -> [A])",
    "Description": "Declare the signature for ':' function."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "assumes",
    "Description": "Specify assumptions for the lemma."
  },
  {
    "Statement": "import Data.Char (isDigit)",
    "Description": "Import the 'isDigit' function from the Data.Char module, which checks if a character is a digit."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "by (metis inorder.simps (2) sorted_append)",
    "Description": "Use the given sorted lemma to solve the subgoal."
  },
  {
    "Statement": "delete y (x:xs)",
    "Description": "Define the recursive case of the delete function where a non-empty list is given. It removes the first occurrence of the element 'y' from the list."
  },
  {
    "Statement": "(>>>=) = bindIOM",
    "Description": "Define the (>>>=) operator as bindIOM."
  },
  {
    "Statement": "y = True",
    "Description": "Assign the value True to the variable 'y'."
  },
  {
    "Statement": "con \"concatMap\"\n-> [A]),",
    "Description": "Declare the signature for 'concatMap' function."
  },
  {
    "Statement": "getName = do",
    "Description": "Begin the definition of getName by using a do block."
  },
  {
    "Statement": "getName = do",
    "Description": "Begin the definition of getName by using a do block."
  },
  {
    "Statement": "apply (induction t)",
    "Description": "Begin the proof by induction over tree t."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "If the first list is empty, return the second list ys as the result of splicing."
  },
  {
    "Statement": "evens (x:xs)\n | mod x 2 == 0 = x : evens xs,\n | otherwise = evens xs",
    "Description": "If the head of the list 'x' is even, add to the result list, and the function is called recursively on the rest of the list 'xs'. If the head of the list 'x' is odd, it is not added to the result list, and the function is called recursively on the rest of the list 'xs'."
  },
  {
    "Statement": "Nothing -> return Nothing",
    "Description": "If maybe_val is Nothing, return Nothing."
  },
  {
    "Statement": "elem y (x:xs)",
    "Description": "If `y` is in the list, return `True`. Otherwise, check the rest of the list."
  },
  {
    "Statement": "zip (a:as) (b:bs) = (a,b) : zip as bs",
    "Description": "Define the recursive case of the zip function where two non-empty lists are given. It combines the first element of each list into a tuple and then recursively does the same for the rest of the lists."
  },
  {
    "Statement": "zipWith _ [] _ = []",
    "Description": "Define the case of the zipWith function where the first list is empty, it returns an empty list."
  },
  {
    "Statement": "add x y z = (x + y) : z",
    "Description": "Define the add function to add x and y, then prepend the result to list z."
  },
  {
    "Statement": "unwords [w] = w",
    "Description": "Define the special case of the unwords function where a single word is given, it returns the word as it is."
  },
  {
    "Statement": "rev\n(x:xs) = rev xs ++ [x]",
    "Description": "Reverse the list."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "lines \"\" = []",
    "Description": "Define the base case of the lines function where an empty string is given, it returns an empty list."
  },
  {
    "Statement": "height (Node _ l r) = 1 + max (height l) (height r)",
    "Description": "Otherwise, return 1 plus the maximum of the heights of the left and right subtrees."
  },
  {
    "Statement": "| otherwise = False",
    "Description": "Otherwise, return `False`."
  },
  {
    "Statement": "elemIndex :: Eq a => a -> [a] -> Maybe Int",
    "Description": "Define 'elemIndex' as a function which returns the index of the first occurrence of the given element in the list."
  },
  {
    "Statement": "import Control.Monad",
    "Description": "Import the Control.Monad module which provides monad functionality."
  },
  {
    "Statement": "newtype Reader r a = Reader { runReader :: r -> a }\n\ninstance Functor (Reader r) where\n    fmap f (Reader g) = Reader (f . g)\n\ninstance Applicative (Reader r) where\n    pure x = Reader $ \\_ -> x\n    Reader f <*> Reader g = Reader $ \\x -> f x (g x)\n\ninstance Monad (Reader r) where\n    return = pure\n    Reader f >>= k = Reader $ \\r -> runReader (k (f r)) r",
    "Description": "Define a newtype 'Reader' with parameters 'r' and 'a'. Provide instances of the 'Functor', 'Applicative', and 'Monad' type classes for the 'Reader' newtype, allowing for mapping, applying, and sequencing computations that depend on an environment of type 'r'."
  },
  {
    "Statement": "where aux ending count = do",
    "Description": "Declare an auxiliary function aux that takes the ending string and a count as arguments, and performs the following actions in the IO monad."
  },
  {
    "Statement": "import Data.Map (Map, empty, insert, lookup)",
    "Description": "Import the 'Map' type and related functions from the Data.Map module."
  },
  {
    "Statement": "descSort = (\\x -> reverse (sort x))",
    "Description": "Define 'descSort' as a lambda function that reverses the sorted input list 'x'."
  },
  {
    "Statement": "transpose [] = []",
    "Description": "Define the base case of the transpose function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "y = func2 arg",
    "Description": "Define a variable 'y' which is assigned the result of calling function 'func2' with argument 'arg'."
  },
  {
    "Statement": "instance (Monoid w, Monad m) => MonadWriter w (ExceptT e m) where\n    tell _ = return ()\n    listen (ExceptT m) = ExceptT $ do\n        (result, w) <- listen m\n        return $ case result of\n            Left e -> Left e\n            Right r -> Right (r, w)\n    pass (ExceptT m) = ExceptT $ do\n        result <- m\n        case result of\n            Left (e, f) -> return $ Left e\n            Right (a, f) -> return $ Right a",
    "Description": "Provide an instance of the 'MonadWriter' type class for the 'ExceptT' monad transformer, assuming that 'm' is an instance of the 'Monad' type class and 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value within the 'ExceptT' monad transformer."
  },
  {
    "Statement": "evens = map (*2) nat\nodds = filter (\\x -> mod x 2 == 0) nat",
    "Description": "Define an infinite list named evens where each element is twice the corresponding element in the list nat. Also, define an infinite list named odds where each element is an even number from the list nat using filtering."
  },
  {
    "Statement": "nub :: Eq a => [a] -> [a]",
    "Description": "Define 'nub' as a function which removes duplicate elements from a list."
  },
  {
    "Statement": "apply (induction t2)",
    "Description": "Begin the proof by induction over tree t2."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "(<$) :: a -> f b -> f a",
    "Description": "Declare the '(<$)' operator signature for the 'Functor' type class, which takes a value of type 'a' and a value of type 'f b', and returns a value of type 'f a'."
  },
  {
    "Statement": "insert :: Ord a => a -> [a] -> [a]",
    "Description": "Define a function named insert which takes an element of type a, where a is an instance of the Ord typeclass, and a sorted list of elements of the same type, and inserts the element into the correct position in the list."
  },
  {
    "Statement": "map f = foldr ((:) . f) []",
    "Description": "Define 'map' as a fold operation that applies function 'f' to each element of the list and constructs a new list."
  },
  {
    "Statement": "class Monoid w => WriterMonad w (m :: * -> *) | m -> w where\n    writer :: (a, w) -> m a\n    runWriter :: m a -> (a, w)\n    tell :: w -> m ()\n    listen :: m a -> m (a, w)\n    pass :: m (a, w -> w) -> m a\n\n    writer (a, w) = do\n        tell w\n        return a\n\n    tell w = writer ((), w)\n\n    listen m = do\n        a <- m\n        w <- getWriter\n        return (a, w)\n\n    pass m = do\n        (a, f) <- m\n        writer (a, f w)\n\n    runWriter m = runState (listen m) mempty",
    "Description": "Define a type class 'WriterMonad' parameterized by 'm' and 'w', where 'w' must be an instance of the 'Monoid' type class. The 'WriterMonad' class specifies methods 'writer', 'runWriter', 'tell', 'listen', and 'pass' for working with computations that produce a log along with a value."
  },
  {
    "Statement": "class Arrow a => ArrowChoice (a :: _->_ -> *)\n  where\n    lift :: a b c -> a (Either b d) (Either c d)\n    right :: a b c -> a (Either d b) (Either d c)\n    (+++) :: a b c -> a b' c' -> a (Either b b') (Either c c')\n    (|||) :: a b d -> a b d -> a (Either b c) d",
    "Description": "Define a type class 'ArrowChoice' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowChoice' class specifies methods for working with sum types (e.g., 'Either') and choice operations."
  },
  {
    "Statement": "concat :: [[a]] -> [a]",
    "Description": "Define 'concat' as a function which concatenates a list of lists into a single list."
  },
  {
    "Statement": "find p (x:xs)",
    "Description": "Define the recursive case of the find function where a non-empty list is given. It searches for the first element that satisfies the predicate 'p'."
  },
  {
    "Statement": "head :: [a] -> a",
    "Description": "Return the first element of a list."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
    "Description": "Define a function bindIOM that takes an IOMaybe a and a function from a to IOMaybe b, and returns an IOMaybe b."
  },
  {
    "Statement": "takeWhileEnd :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function takeWhileEnd that takes a predicate p and a list xs, and returns the longest suffix of xs that satisfies p."
  },
  {
    "Statement": "count :: Int -> Int -> IO ()",
    "Description": "Declares a function 'count' that takes two integers and performs IO actions."
  },
  {
    "Statement": "case Nil",
    "Description": "If the case is an empty list."
  },
  {
    "Statement": "con \"add\" ((+) :: Int -> Int -> Int),",
    "Description": "Include the 'add' function signature."
  },
  {
    "Statement": "sortString = sort",
    "Description": "Use the `sort` function to sort the input string in ascending order."
  },
  {
    "Statement": "greet person = \"Hi\" ++ name person",
    "Description": "Define 'greet' function to concatenate \"Hi\" with the name of the person passed as argument."
  },
  {
    "Statement": "split = foldr f [[]]",
    "Description": "Define 'split' using a right fold over the characters in the string, where 'f' is the function that splits the string based on whitespace."
  },
  {
    "Statement": "class Ord a where {",
    "Description": "Define a class 'Ord' with type variable 'a' where,"
  },
  {
    "Statement": "instance Monad a => Monad ((,) a)",
    "Description": "Create an instance of the Monad typeclass for the tuple type constructor (,) a, given that a is an instance of the Monad typeclass."
  },
  {
    "Statement": "instance Monoid (NonEmpty a) where",
    "Description": "Define a 'Monoid' instance for the 'NonEmpty' data type."
  },
  {
    "Statement": "instance Monad (Either e)",
    "Description": "Create an instance of the Monad typeclass for the Either e data type, which represents computations that can either succeed with a value of type a or fail with a value of type e."
  },
  {
    "Statement": "class (Ord a) => Preorder a where {",
    "Description": "Define a class 'Preorder' with type variable 'a' which is a subclass of 'Ord', where,"
  },
  {
    "Statement": "reverse' :: [a] -> [a]",
    "Description": "Define a function reverse' that takes a list xs and returns a new list containing the elements of xs in reverse order."
  },
  {
    "Statement": "minimum :: (Ord a, Foldable t) => t a -> a",
    "Description": "Define 'minimum' as a function which finds the minimum element of a non-empty list."
  },
  {
    "Statement": "n == 0 =1",
    "Description": "If `n` is equal to 0, return 1."
  },
  {
    "Statement": "map [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "guard (checkInput input)",
    "Description": "Use the `guard` function to conditionally proceed with the computation based on the result of `checkInput input`, which presumably checks if the input satisfies some condition."
  },
  {
    "Statement": "intersperse sep (x:xs) = x : concat [[sep, y] | y <- xs]",
    "Description": "Define the recursive case of the intersperse function where a non-empty list is given. It intersperses the separator 'sep' between each pair of elements in the list."
  },
  {
    "Statement": "map' :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function map' that takes a function f and a list xs, and returns a new list containing the result of applying f to each element of xs."
  },
  {
    "Statement": "case (Cons x xs)",
    "Description": "If the case is a non-empty list."
  },
  {
    "Statement": "takeWhile p (x:xs)",
    "Description": "Take elements from the list as long as the predicate `p` holds true."
  },
  {
    "Statement": "count <- get",
    "Description": "Retrieve the current count value from the state using the `get` function."
  },
  {
    "Statement": "n == 0 =1",
    "Description": "If `n` is equal to 0, return 1."
  },
  {
    "Statement": "class Functor f => Monoidal f where",
    "Description": "Define a type class 'Monoidal' with a superclass constraint 'Functor f', representing monoidal functors."
  },
  {
    "Statement": "($!) :: (a -> b) -> a -> b",
    "Description": "Define the type signature for the ($!) operator, which takes a function (a -> b) and a value of type a, and returns a value of type b."
  },
  {
    "Statement": "filter :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function 'filter' that takes a predicate function 'f' and a list 'xs' as arguments, and returns a list containing only the elements of 'xs' for which 'f' returns True."
  },
  {
    "Statement": "con \"lcm\" (lcm :: Int -> Int -> Int),",
    "Description": "Include the 'lcm' function signature."
  },
  {
    "Statement": "module DataStructures",
    "Description": "Define a module named DataStructures."
  },
  {
    "Statement": "dropWhile _ [] = []",
    "Description": "Define the case of the dropWhile function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "  where (xs, ys) = unzip xys",
    "Description": "Use recursion to continue the process."
  },
  {
    "Statement": "import Data.List (foldl')\n\nmaxInts :: [Int] -> Int",
    "Description": "Define a function 'maxInts' that takes a list of integers and returns the maximum value in the list. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "singleton :: a -> Set a",
    "Description": "Declare a function singleton that creates a set with a single element."
  },
  {
    "Statement": "func x = if x == 0 then ( else f (x-1))",
    "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
  },
  {
    "Statement": "func :: Int -> Int",
    "Description": "Define a function named `func` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "all' :: (a -> Bool) -> [a] -> Bool",
    "Description": "Define a function all' that takes a predicate p and a list xs, and returns True if all elements of xs satisfy the predicate p, otherwise False."
  },
  {
    "Statement": "f = reverse . sort",
    "Description": "Define f as a composition of reverse and sort functions."
  },
  {
    "Statement": "greet (Person n_) = \"Hi\" ++ n_",
    "Description": "Define 'greet' function pattern matching on 'Person' constructor with 'n_' as its argument, concatenating \"Hi\" with 'n_'."
  },
  {
    "Statement": "mapA :: ArrowChoice a => a a1 a2 -> a [a1] [a2]\nmapA f =\n  arr listCase >>>\n  arr (const []) ||| (f *** mapA f >>> arr (uncurry (:)))",
    "Description": "Define a function 'mapA' that takes an arrow 'f' and applies it to each element of a list. It uses the 'ArrowChoice' operations to implement map in a point-free style."
  },
  {
    "Statement": "Class Num a where",
    "Description": "Declare a typeclass 'Num' which represents numeric types."
  },
  {
    "Statement": "import Data.List (find)\n\nfindElement :: Eq a => a -> [a] -> Maybe a",
    "Description": "Define a function 'findElement' that takes an element and a list of elements of the same type 'a' that implements the 'Eq' typeclass, and returns the first occurrence of the element in the list, wrapped in a 'Maybe' data type. Import the 'find' function from the 'Data.List' module."
  },
  {
    "Statement": "repeat' :: a -> [a]",
    "Description": "Define a function repeat' that takes a value x and returns an infinite list containing only x."
  },
  {
    "Statement": "foldl' f z (x:xs) = let z' = f z x in z' 'seq' foldl' f z' xs",
    "Description": "Define the recursive case for foldl', which applies the function f to the initial value z and the head of the list x to get z', evaluates z' strictly using seq, and then recursively calls foldl' with z' as the new initial value and the remaining list xs."
  },
  {
    "Statement": "concat [] = []",
    "Description": "Define the base case of the concat function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "where types = (x :: Bool, y :: Bool)",
    "Description": "Specify the types of 'x' and 'y' as boolean values for the 'prop' function."
  },
  {
    "Statement": "dropWhile p (x:xs)",
    "Description": "Define the recursive case of the dropWhile function where a non-empty list is given. It removes elements from the list while the predicate 'p' holds true."
  },
  {
    "Statement": "monadd mx my = do",
    "Description": "Define `monadd"
  },
  {
    "Statement": "mono Typeobserve (Proxy :: Proxy (Complex Float)),",
    "Description": "Include the 'Complex Float' type proxy in 'complexSig'."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "abbreviation sortedT :: \"('a :: linorder) Tree → bool*",
    "Description": "Define an abbreviation named `sortedT` which takes a `Tree` of type `('a :: linorder)` and returns a `bool`."
  },
  {
    "Statement": "data Temperature = C Float | F Float",
    "Description": "Define a datatype 'Temperature' with two constructors 'C' and 'F' representing temperatures in Celsius and Fahrenheit respectively."
  },
  {
    "Statement": "sorry",
    "Description": "Indicate the proof is skipped for now."
  },
  {
    "Statement": "maybeadd :: Num b => Maybe b -> Maybe b -> Maybe b",
    "Description": "Redefine `maybeadd` to accept two Maybe-wrapped values and add them."
  },
  {
    "Statement": "import Data.List (foldl')\n\nminInts :: [Int] -> Int",
    "Description": "Define a function 'minInts' that takes a list of integers and returns the minimum value in the list. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "length :: [a] -> Int",
    "Description": "Define a function named `length` which takes a list of any type and returns an `Int`."
  },
  {
    "Statement": "bubbleUp x (y:ys) | otherwise = x : y : ys",
    "Description": "Otherwise, prepend x and the head of the accumulator to the tail of the accumulator."
  },
  {
    "Statement": "Nothing >>= (\\x -> Just x)",
    "Description": "Bind Nothing to the function (\\x -> Just x), resulting in Nothing."
  },
  {
    "Statement": "isJust :: Maybe a -> Bool",
    "Description": "Define a function 'isJust' which takes a 'Maybe' value and returns 'True' if it is a 'Just' value, otherwise returns 'False'."
  },
  {
    "Statement": "uniqueSort = nub . sort",
    "Description": "The implementation of 'uniqueSort' uses function composition: first, sort the input list using 'sort', then remove duplicate elements using 'nub'."
  },
  {
    "Statement": "maybeadd (Just 1) 1",
    "Description": "Applly `maybeadd` function with `Just 1` and `1`, resulting in Just 2."
  },
  {
    "Statement": "\"assumes 'sortedT l'\"",
    "Description": "Assume that l is sorted."
  },
  {
    "Statement": "checkFirstChar [] = False",
    "Description": "If the input string is empty, return False."
  },
  {
    "Statement": "where aux ending = do",
    "Description": "Declare an auxiliary function aux that takes the ending string as an argument, and performs the following actions in the StateT monad."
  },
  {
    "Statement": "f (1+1) (2+1)",
    "Description": "Apply the function f with arguments 2 and 3."
  },
  {
    "Statement": "f :: [a] -> [a]",
    "Description": "Declare a function f which takes a list of type a and returns a list of the same type."
  },
  {
    "Statement": "f :: Int -> Int -> MVar Int -> IO ()\nf a b mVar = do\n  putMVar mVar $! (a+b)",
    "Description": "Define a function f that takes two integers a and b, computes their sum, and puts the sum into the given MVar."
  },
  {
    "Statement": "func :: Int -> Int",
    "Description": "Define a function named `func` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "\"∀t1 t2. sortedT t1 ⟶ sortedT t2 ⟶ sortedT (t1 ∩ t2)\"",
    "Description": "For all trees t1 and t2, if t1 and t2 are sorted, then the intersection of t1 and t2 is also sorted."
  },
  {
    "Statement": "where types = (x :: [Int], y :: [Int])",
    "Description": "Specify the types of 'x' and 'y' as lists of integers for the 'prop' function."
  },
  {
    "Statement": "factorial :: Integer -> Integer",
    "Description": "Define a function factorial that takes an Integer and returns its factorial."
  },
  {
    "Statement": "returnIOM = return . Just",
    "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
  },
  {
    "Statement": "take n (x:xs) = x : take (n-1) xs",
    "Description": "Otherwise, take `n` elements from the list."
  },
  {
    "Statement": "cross :: a -> b -> (a,b)",
    "Description": "Define the 'cross' function that takes two values 'a' and 'b', and returns a tuple '(a,b)' containing them."
  },
  {
    "Statement": "case Nil",
    "Description": "If the case is an empty list."
  },
  {
    "Statement": "instance Monad a => Monad ((,) a)",
    "Description": "Define a Monad instance for pairs."
  },
  {
    "Statement": "snd (,y) = y",
    "Description": "Define the function 'snd' which extracts the second element of a tuple."
  },
  {
    "Statement": "height (Node _ l r) = 1 + max (height l) (height r)",
    "Description": "Otherwise, return 1 plus the maximum of the heights of the left and right subtrees."
  },
  {
    "Statement": "greet = do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   putStrLn (\"Hello \" ++ name ++ \".\")",
    "Description": "Define 'greet' function which prompts the user for their name, reads the input, and prints a greeting message."
  },
  {
    "Statement": "import Data.List (sort)\n\nsortList :: [Int] -> [Int]",
    "Description": "Define a function 'sortList' that takes a list of integers and returns a sorted list of integers. Import the 'sort' function from the 'Data.List' module."
  },
  {
    "Statement": "monoTypeWithVars [\"t\", \"t1\", \"t2\"] (Proxy :: Proxy (Tree Int)),",
    "Description": "Include the type proxy 'Tree Int' in 'treesig2' with type variables 't', 't1', and 't2'."
  },
  {
    "Statement": "fun insert v (Node l tv r) = (if v ≤ tv then (Node (insert v l) tv r) else (Node l tv (insert v r)))",
    "Description": "Otherwise, insert `v` into the appropriate branch depending on the comparison of `v` and `tv`."
  },
  {
    "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
    "Description": "Define a function bindIOM that takes an IOMaybe a and a function from a to IOMaybe b, and returns an IOMaybe b."
  },
  {
    "Statement": "nub' :: Eq a => [a] -> [a]",
    "Description": "Define a function nub' that takes a list xs and removes duplicate elements from xs, preserving the order of the remaining elements."
  },
  {
    "Statement": "maximum (x:xs) = max x (maximum xs)",
    "Description": "Otherwise, return the maximum of the first element and the maximum of the rest of the list."
  },
  {
    "Statement": "proof (induction t rule:insert.induct)",
    "Description": "Apply induction on the tree with the rule for the 'insert' function."
  },
  {
    "Statement": "map :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function 'map' that takes a function 'f' and a list 'xs' as arguments, and applies 'f' to each element of 'xs', returning a list of the results."
  },
  {
    "Statement": "else return Nothing",
    "Description": "If the condition is not satisfied, return Nothing."
  },
  {
    "Statement": "con \"divide\" (div :: Int -> Int -> Int),",
    "Description": "Include the 'divide' function signature."
  },
  {
    "Statement": "sum (x:xs) = x + sum xs",
    "Description": "Define the sum of a list as the first element plus the sum of the rest of the list."
  },
  {
    "Statement": "    | p x = (x:ys, zs)",
    "Description": "Define the condition for the recursive case of the partition function. If the predicate 'p' is satisfied by the current element 'x', it is added to the first component of the resulting pair."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "Define a function 'sum' that takes an empty list as input and returns 0."
  },
  {
    "Statement": "con \":@\" ((++) :: [a] -> [a] -> [a]),",
    "Description": "Include the ':@' operator signature."
  },
  {
    "Statement": "import Data.Char (digitToInt)\n\nstringToInt :: String -> Int",
    "Description": "Define a function 'stringToInt' that takes a string and returns its integer representation. Import the 'digitToInt' function from the 'Data.Char' module."
  },
  {
    "Statement": "replicate' n x = foldl' (\\acc _ -> x : acc) [] [1..n]",
    "Description": "The implementation of 'replicate'' uses 'foldl'' to fold a list of indices '[1..n]' using an anonymous function that prepends 'x' to the accumulator 'acc' for each iteration. The initial accumulator is an empty list '[]'."
  },
  {
    "Statement": "\"∃t. sortedT t\"",
    "Description": "There exists a tree t that is sorted."
  },
  {
    "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Last a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
  },
  {
    "Statement": "instance MonadIO m => MonadIO (StateT s m) where\n    liftIO = lift . liftIO",
    "Description": "Provide an instance of the 'MonadIO' type class for the 'StateT' monad transformer, assuming that 'm' is an instance of the 'MonadIO' type class. This instance allows for lifting 'IO' computations into the 'StateT' monad transformer."
  },
  {
    "Statement": "greet (Person name_) = \"Hi\" ++ name_",
    "Description": "Define 'greet' function pattern matching on 'Person' constructor with 'name_' as its argument, concatenating \"Hi\" with 'name_'."
  },
  {
    "Statement": "put :: s -> m ()",
    "Description": "Declare a function put that takes a new state and updates the current state inside a monadic context, returning an empty tuple."
  },
  {
    "Statement": "where aux ending = do",
    "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string as an argument."
  },
  {
    "Statement": "replicate' :: Int -> a -> [a]",
    "Description": "Define a function replicate' that takes an integer n and a value x, and returns a list containing n copies of x."
  },
  {
    "Statement": "Just 1 >> Nothing",
    "Description": "Perform the (>>) operation with Just 1 and Nothing, resulting in Nothing."
  },
  {
    "Statement": "insert x [] = [x]",
    "Description": "If the input list is empty, return a singleton list containing x."
  },
  {
    "Statement": "unzip ((x,y):xys) = (x:xs, y:ys)",
    "Description": "Otherwise, separate the first and second elements of each pair into two separate lists."
  },
  {
    "Statement": "Lemma sorted node:",
    "Description": "Define a lemma named sorted_node."
  },
  {
    "Statement": "data [] a = [] | a : [a]",
    "Description": "Declare a data type [a] that represents a list of elements of type a, with two constructors: [] (representing an empty list) and (:) (representing a non-empty list by prepending an element to an existing list)."
  },
  {
    "Statement": "class Category (cat :: k -> k -> *) where\n  id :: forall (a :: k). cat a a\n  (.) :: forall (b :: k) (c :: k) (a :: k).\n         cat b c -> cat a b -> cat a c\n  (>>>) :: Category cat => cat a b -> cat b c -> cat a b -> cat a c\n  f >>> g = g . f",
    "Description": "Define a type class 'Category' parameterized by 'cat', which is a higher-kinded type constructor that takes two type arguments and returns a type. The 'Category' class specifies the methods 'id' (identity arrow), '.' (arrow composition), and '>>>' (right-to-left arrow composition)."
  },
  {
    "Statement": "    | y == x = xs",
    "Description": "Define the condition for the recursive case of the delete function. If the element 'y' is equal to the current element 'x', it returns the rest of the list."
  },
  {
    "Statement": "app :: (a -> b) -> a->b",
    "Description": "Define a higher-order function 'app' that takes a function 'f' and a value 'x' as arguments, and applies 'f' to 'x'."
  },
  {
    "Statement": "(**) as bs = [(a,b) | a <- as, b <- bs]",
    "Description": "Define the '(**)' operator for the 'Monoidal' instance of '[]' as a list comprehension that combines all pairs of elements from the two input lists 'as' and 'bs' into tuples '(a,b)'."
  },
  {
    "Statement": "unit :: f ()",
    "Description": "Declare the 'unit' function signature for the 'Monoidal' type class, which returns a value of type 'f ()' representing the monoidal unit."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "Define the splice function for an empty list and a non-empty list ys to return the list ys."
  },
  {
    "Statement": "where aux ending count = do",
    "Description": "Declare an auxiliary function aux that takes the ending string and a count as arguments, and performs the following actions in the IO monad."
  },
  {
    "Statement": "height Leaf = 0",
    "Description": "If the input tree is Leaf, return 0."
  },
  {
    "Statement": "readUntilWithCount :: String -> IO Int",
    "Description": "Declare a function named `readUntilWithCount` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read."
  },
  {
    "Statement": "treeToSeq :: Tree a -> Seq a",
    "Description": "Define a function 'treeToSeq' that converts a binary tree of type 'Tree a' into a sequence ('Seq a') while preserving the order of elements."
  },
  {
    "Statement": "\\x -> x+1",
    "Description": "Define an anonymous function that takes a parameter 'x' and returns 'x+1'."
  },
  {
    "Statement": "class Applicative m => Monad (m :: * -> *) where",
    "Description": "Declare the Monad type class, which extends the Applicative type class."
  },
  {
    "Statement": "return input",
    "Description": "If the guard condition is satisfied, return the `input` value as the result of the `getName` computation."
  },
  {
    "Statement": "put (count + 1)",
    "Description": "Update the state by incrementing the current count by 1 and storing the new value using the `put` function."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "zip _ [] = []",
    "Description": "If the second list is empty, return an empty list."
  },
  {
    "Statement": "lookup _ Leaf = Nothing",
    "Description": "For a leaf node, return 'Nothing' since there are no subtrees."
  },
  {
    "Statement": "main = do catch failing (\\e -> do putStrLn \"Something went wrong!\")",
    "Description": "Define the main function to catch any exceptions of type MyError thrown by failing, and print a message \"Something went wrong!\" if an exception is caught."
  },
  {
    "Statement": "minimum :: Ord a => [a] -> a",
    "Description": "Define a function named `minimum` which takes a list of type `[a]` and returns an element of type `a`."
  },
  {
    "Statement": "using sorted. simps(2) sorted append by blast",
    "Description": "Use the given sorted lemma to solve the subgoals."
  },
  {
    "Statement": "asc :: Int -> Int -> [Int]",
    "Description": "Define a function 'asc' that generates a list of integers in ascending order."
  },
  {
    "Statement": "delete w = arr words >>> arr (filter (/= w)) >>> arr unwords",
    "Description": "Define a function delete that takes a word w and returns a new function that removes all occurrences of w from a given string, using the point-free style and the arr function from the Arrow typeclass."
  },
  {
    "Statement": "map [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "map :: (a -> b) -> Seq a -> Seq b",
    "Description": "Declare a function map that applies a function to each element of a sequence."
  },
  {
    "Statement": "lemma contains_rev: \"contains P (rev xs) ⟷ contains P xs\"",
    "Description": "Define a lemma asserting that `P` holds for an element in the reversed list if and only if `P` holds for that element in the original list."
  },
  {
    "Statement": "\"assumes 'sortedT l'\"",
    "Description": "Assume that `l` is sorted."
  },
  {
    "Statement": "Lemma sorted_tree:",
    "Description": "Define a lemma named sorted_tree."
  },
  {
    "Statement": "instance Monoid (First a) where",
    "Description": "Define a 'Monoid' instance for the 'First' data type."
  },
  {
    "Statement": "\"assumes 'sortedT r'\"",
    "Description": "Assume that `r` is sorted."
  },
  {
    "Statement": "sum (x: xs) = x + sum xs",
    "Description": "Sum the first element x with the sum of the remaining elements xs recursively."
  },
  {
    "Statement": "count n m = do\n  putStrLn (show n)\n  if n<m then\n      count (n+1) m\n  else\n      return ()",
    "Description": "Define 'count' function which prints numbers from 'n' to 'm', inclusively."
  },
  {
    "Statement": "inOrder :: Tree a -> [a]",
    "Description": "Define a function named inOrder which takes a Tree of elements of type a and returns a list of the elements in in-order traversal order."
  },
  {
    "Statement": "unzip :: [(a, b)] -> ([a], [b])",
    "Description": "Define 'unzip' as a function which takes a list of pairs and returns a pair of lists."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "Base case: If the list is empty, the sum is 0."
  },
  {
    "Statement": "returniOM :: a -> IOMaybe a",
    "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
  },
  {
    "Statement": "instance Applicative Maybe where\n    pure = Just\n    Just f <*> m = fmap f m\n    Nothing <*> _ = Nothing\n    _ *> b = b\n    a <* _ = a",
    "Description": "Provide an instance of the 'Applicative' type class for the 'Maybe' data type. This instance allows for applying and combining 'Maybe' computations."
  },
  {
    "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
    "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user and bind it to the variable `input`."
  },
  {
    "Statement": "sortBy :: (a -> a -> Ordering) -> [a] -> [a]",
    "Description": "Define 'sortBy' as a function which sorts a list by the given comparison function."
  },
  {
    "Statement": "foldr (\\elem acc -> <term>) <start_acc> <list>",
    "Description": "Define a fold operation where the function takes an element and an accumulator as arguments, starting with an initial accumulator value, and folding from the right over the list."
  },
  {
    "Statement": "import Data.Maybe (fromMaybe)",
    "Description": "Import the 'fromMaybe' function from the Data.Maybe module."
  },
  {
    "Statement": "(+) :: Num a => a -> a -> a",
    "Description": "Define an operator '+' which takes two arguments of type 'a' belonging to the 'Num' typeclass and returns a value of the same type."
  },
  {
    "Statement": "x (D3 1 2 3)",
    "Description": "Access the 'x' coordinate of a 3D point, yielding '1'."
  },
  {
    "Statement": "inorder Leaf = []:",
    "Description": "If the tree is a 'Leaf', then return an empty list."
  },
  {
    "Statement": "instance MonadIO m => MonadIO (ExceptT e m) where\n    liftIO = lift . liftIO",
    "Description": "Provide an instance of the 'MonadIO' type class for the 'ExceptT' monad transformer, assuming that 'm' is an instance of the 'MonadIO' type class. This instance allows for lifting 'IO' computations into the 'ExceptT' monad transformer."
  },
  {
    "Statement": "printInput = runKleisli ka ()\n  where ka = Kleisli (\\_-> getLine) >>> Kleisli putStrLn",
    "Description": "Define a function 'printInput' that reads a line from the input and prints it to the output. It uses the 'Kleisli' arrow 'ka', which is composed of two 'Kleisli' arrows: one that reads a line from the input using 'getLine', and one that prints the line to the output using 'putStrLn'."
  },
  {
    "Statement": "]",
    "Description": "End the 'complexSig' list definition."
  },
  {
    "Statement": "insert v (Node l tv r) =\n(if less eq v tv then Node (insert v l) tv r else Node l tv (insert v r));",
    "Description": "If 'v' is less than or equal to 'tv', then insert 'v' in the left subtree, else insert 'v' in the right subtree."
  },
  {
    "Statement": "data List a = Nil | Cons a (List a)",
    "Description": "Define a data type named List which is either Nil or a Cons cell containing an element of type a and a List of the same type."
  },
  {
    "Statement": "instance Monad IO",
    "Description": "Define a Monad instance for IO actions."
  },
  {
    "Statement": "if (z) {",
    "Description": "Start a conditional Statement based on the value of 'z'."
  },
  {
    "Statement": "map2D = map . map",
    "Description": "Define 'map2D' as the composition of 'map' function applied twice."
  },
  {
    "Statement": "newEmptyMVar :: IO (MVar a)",
    "Description": "Create a new empty MVar, which is a synchronized mutable variable that can be used for communication between threads."
  },
  {
    "Statement": "where aux ending count = do",
    "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string and the current `count` as arguments."
  },
  {
    "Statement": "where f' x y = f (x, snd y )",
    "Description": "Define a helper function f' that takes x and y, and applies the original function f to (x, snd y), where snd y is the second component of y."
  },
  {
    "Statement": "map :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
  },
  {
    "Statement": "background [ prelude ]",
    "Description": "Include the Prelude module in the background."
  },
  {
    "Statement": "module Monads",
    "Description": "Define a module named Monads."
  },
  {
    "Statement": "minInts = foldl' min (maxBound :: Int)",
    "Description": "The implementation of 'minInts' uses 'foldl'' to fold the input list of integers using the 'min' function and an initial accumulator value of 'maxBound :: Int' (the largest possible integer value)."
  },
  {
    "Statement": "inOrder Leaf = []",
    "Description": "If the input tree is Leaf, return an empty list."
  },
  {
    "Statement": "zip' :: [a] -> [b] -> [(a, b)]",
    "Description": "Define a function zip' that takes two lists xs and ys, and returns a list of pairs, where each pair contains one element from xs and the corresponding element from ys."
  },
  {
    "Statement": "returnIOM = return . Just",
    "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
  },
  {
    "Statement": "member :: a -> Set a -> Bool",
    "Description": "Declare a function member that checks if an element is in a set."
  },
  {
    "Statement": "intersect' :: Eq a => [a] -> [a] -> [a]",
    "Description": "Define a function intersect' that takes two lists xs and ys, and returns a new list containing only the elements that are common to both xs and ys."
  },
  {
    "Statement": "filter :: (a -> Bool) -> Seq a -> Seq a",
    "Description": "Declare a function filter that filters elements from a sequence based on a predicate."
  },
  {
    "Statement": "instance Num a => Semigroup (Product a) where",
    "Description": "Define a 'Semigroup' instance for the 'Product' data type, constrained by the 'Num' type class constraint on 'a'."
  },
  {
    "Statement": "if checkInput input",
    "Description": "Check if the input satisfies the checkInput condition."
  },
  {
    "Statement": "module Monads",
    "Description": "Define a module named Monads."
  },
  {
    "Statement": "deleteBy eq y (x:xs)",
    "Description": "Define the recursive case of the deleteBy function where a non-empty list is given. It removes the first occurrence of the element 'y' that satisfies the predicate 'eq'."
  },
  {
    "Statement": "func :: Int -> Int -> Int -> Int",
    "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
  },
  {
    "Statement": "module Main where",
    "Description": "Define the module 'Main'."
  },
  {
    "Statement": "quicksort (x:xs) = quicksort [y | y <- xs, y < x] ++ [x] ++ quicksort [y | y <- xs, y >= x]",
    "Description": "The implementation of 'quicksort' follows the standard quicksort algorithm: select a pivot element 'x', partition the remaining elements into two lists (less than 'x' and greater than or equal to 'x'), recursively sort the two partitions, and concatenate the results with the pivot element in the middle."
  },
  {
    "Statement": "instance ArrowApply (->) where",
    "Description": "Create an instance of the ArrowApply typeclass for the function type constructor (->) that represents functions."
  },
  {
    "Statement": "maximum [x] = x",
    "Description": "If the list has only one element, return that element."
  },
  {
    "Statement": "length [] =?= foldr (const (+1)) 0 []",
    "Description": "State that the length of an empty list is equal to foldr (const (+1)) 0 [] (which should evaluate to 0)."
  },
  {
    "Statement": "import Data.List (foldl')\n\nor' :: [Bool] -> Bool",
    "Description": "Define a function 'or'' that takes a list of boolean values and returns their logical disjunction (OR). Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "maybeadd Nothing 1",
    "Description": "Applly `maybeadd` function with `Nothing` and `1`, resulting in Nothing."
  },
  {
    "Statement": "monoTypewithvars [\"a\", \"b\", \"c\"] (Proxy :: Proxy OrdA),",
    "Description": "Include the 'OrdA' type proxy with type variables 'a', 'b', and 'c' in 'treesig2'."
  },
  {
    "Statement": "stimes n (Sum a) = Sum (a * n)",
    "Description": "Define the 'stimes' function that takes an integer 'n' and a 'Sum a' value, and returns a new 'Sum' value where the wrapped value 'a' is multiplied by 'n'."
  },
  {
    "Statement": "p n= n≥ 0",
    "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
  },
  {
    "Statement": "proof (induction xs rule: list.induct)",
    "Description": "Apply induction on the list using the rule for the `list` type."
  },
  {
    "Statement": "checkFirstChar :: String -> Bool",
    "Description": "Define a function checkFirstChar that takes a String and returns a Bool, indicating whether the first character is uppercase or not."
  },
  {
    "Statement": "unzip ((x, y):xys) = (x:xs, y:ys)",
    "Description": "Define the recursive case of the unzip function where a non-empty list of pairs is given. It separates the first element of each pair into the first component of the resulting pair, and the second element into the second component."
  },
  {
    "Statement": "newtype StateT s (m :: * -> *) a",
    "Description": "Declare a new type constructor `StateT` that represents a state transformer monad, parameterized by the state type `s`, a base monad `m`, and the result type `a`."
  },
  {
    "Statement": "import Data.Maybe",
    "Description": "Import the 'Data.Maybe' module to access functions related to the 'Maybe' datatype."
  },
  {
    "Statement": "using assms sorted append by fastforce",
    "Description": "Use the given sorted lemma and `fastforce` tactic to solve the subgoal."
  },
  {
    "Statement": "con\n\"revAcc\"",
    "Description": "Declare the signature for 'revAcc' function."
  },
  {
    "Statement": "insert y [] = [y]",
    "Description": "Define the base case of the insert function where an empty list is given, it returns a list containing the element 'y'."
  },
  {
    "Statement": "sizeT (Node l _ r) = 1 + sizeT l + sizeT r",
    "Description": "Define sizeT for a Node as 1 plus the size of the left subtree plus the size of the right subtree."
  },
  {
    "Statement": "reverse Nil = Nil",
    "Description": "If the input list is Nil, return Nil."
  },
  {
    "Statement": "sorry",
    "Description": "Indicate the proof is skipped for now."
  },
  {
    "Statement": "prop a b = (a+b) == (b+a)",
    "Description": "Define a property named prop that checks if the sum of two numbers a and b is equal to the sum of b and a."
  },
  {
    "Statement": "or\nimport Module (dataType(A,C))",
    "Description": "Imports only the specified data type constructors 'A' and 'C' from the module 'Module'."
  },
  {
    "Statement": "| n <= 0    = []",
    "Description": "If `n` is less than or equal to 0, return an empty list."
  },
  {
    "Statement": "where",
    "Description": "Begin the definition of helper functions for 'mergeSort'."
  },
  {
    "Statement": "quicksort (x:xs) = quicksort [y | y <- xs, y < x] ++ [x] ++ quicksort [y | y <- xs, y >= x]",
    "Description": "For a non-empty list, 'quicksort' selects a pivot element 'x', partitions the remaining elements into two lists (elements less than 'x' and elements greater than or equal to 'x'), recursively sorts the two lists, and concatenates the sorted lists with the pivot element in the middle."
  },
  {
    "Statement": "import Data.List (intercalate)",
    "Description": "Import the 'intercalate' function from the Data.List module, which inserts a given string between the elements of a list."
  },
  {
    "Statement": "import Data.List (sort)",
    "Description": "Import the 'sort' function from the Data.List module, which sorts a list in ascending order."
  },
  {
    "Statement": "else readUntil ending",
    "Description": "If the input is not the ending string, recursively call readUntil with the ending string."
  },
  {
    "Statement": "p n= n≥ 0",
    "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
  },
  {
    "Statement": "import Control.Monad",
    "Description": "Import the Control.Monad module which provides monad functionality."
  },
  {
    "Statement": "foldr (\\acc elem -> <term>) <start_acc> <list>",
    "Description": "Define a fold operation where the function takes an accumulator and an element as arguments, starting with an initial accumulator value, and folding from the right over the list."
  },
  {
    "Statement": "name <- getName",
    "Description": "Call the `getName` function and bind the result (if successful) to the `name` variable."
  },
  {
    "Statement": "takeWhile :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define 'takeWhile' as a function which takes elements from a list while the predicate holds."
  },
  {
    "Statement": "mono TypeObserve (Proxy :: Proxy Float),",
    "Description": "Include the 'Float' type proxy in 'complexSig'."
  },
  {
    "Statement": "con \":^:\" ((++) :: [[a]] -> [[a]] -> [[a]]),",
    "Description": "Include the ':^:' operator signature."
  },
  {
    "Statement": "apply (simp add: sorted_append)",
    "Description": "Apply the simp tactic with the additional information sorted_append."
  },
  {
    "Statement": "safeGetLine :: IO (Maybe String)",
    "Description": "Define a function safeGetLine that returns an IO action that produces a Maybe String."
  },
  {
    "Statement": "ones = 1 : ones",
    "Description": "Define an infinite list named ones where each element is 1 followed by itself, creating an infinite cycle."
  },
  {
    "Statement": "liftIOm io :: io >>= retrunIOM",
    "Description": "Define liftIOm io as io >>= returnIOM."
  },
  {
    "Statement": "map f (x:xs) = f x : map f xs",
    "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
  },
  {
    "Statement": "newtype Product a = Product { getProduct :: a }",
    "Description": "Define a new data type called 'Product' with a single constructor 'Product' that wraps a value of type 'a'. The 'getProduct' function extracts the value of type 'a' from the 'Product' constructor."
  },
  {
    "Statement": "stimes n (All a) = All (a && n)",
    "Description": "Define the 'stimes' function that takes an integer 'n' and an 'All a' value, and returns a new 'All' value where the wrapped value 'a' is 'AND'ed 'n' times."
  },
  {
    "Statement": "f :: Int -> Int -> IO ()\nf a b = do\n  let x = a+b\n  putStrLn $! show x",
    "Description": "Define a function f that takes two integers a and b, computes their sum x, and prints the value of x using putStrLn."
  },
  {
    "Statement": "int z = func3 (arg);",
    "Description": "Define a variable 'z' of type integer which is assigned the result of calling function 'func3' with argument 'arg'."
  },
  {
    "Statement": "| p (head xs) = dropWhile p (tail xs)",
    "Description": "If the predicate `p` holds true for the head of the list, drop the head and continue."
  },
  {
    "Statement": "product [] = 1",
    "Description": "Define the product of an empty list as 1."
  },
  {
    "Statement": "partition :: (a -> Bool) -> [a] -> ([a], [a])",
    "Description": "Define 'partition' as a function which takes a predicate and a list and returns a pair of lists: those elements which satisfy the predicate and those that do not."
  },
  {
    "Statement": "con\n(revAcc :: [A] -> [A]),",
    "Description": "Define 'revAcc' as a function which takes a list of 'A' and returns a list of 'A'."
  },
  {
    "Statement": "p n= n≥ 0",
    "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
  },
  {
    "Statement": "let x = func1 arg",
    "Description": "Define a variable 'x' which is assigned the result of calling function 'func1' with argument 'arg'."
  },
  {
    "Statement": "fun insert :: \"'a :: linorder → 'a Tree → 'a Tree\"",
    "Description": "Define a function named `insert` which takes a value of type `'a :: linorder` and a `Tree 'a` and returns a `Tree 'a`."
  },
  {
    "Statement": "reverse :: Seq a -> Seq a",
    "Description": "Declare a function reverse that reverses the elements of a sequence."
  },
  {
    "Statement": "instance Eq Temperature where",
    "Description": "Declare an instance of the 'Eq' typeclass for the 'Temperature' datatype."
  },
  {
    "Statement": "app :: (a -> b) -> a->b",
    "Description": "Define a higher-order function 'app' that takes a function 'f' and a value 'x' as arguments, and applies 'f' to 'x'."
  },
  {
    "Statement": "instance Monoid a => Monoid (Dual a) where",
    "Description": "Define a 'Monoid' instance for the 'Dual' data type, constrained by the 'Monoid' instance of the inner type 'a'."
  },
  {
    "Statement": "con \"concatenate\" ((++) :: [a] -> [a] -> [a]),",
    "Description": "Include the 'concatenate' function signature."
  },
  {
    "Statement": "prop k v m = lookup k ((k,v): m) === Just v\n   where types = (k :: Int, v :: Int)",
    "Description": "Define a property named prop that checks if looking up a key k in a list that contains a tuple (k,v) results in Just v."
  },
  {
    "Statement": "Lemma sets value sortedT:",
    "Description": "Define a lemma named sortedT_values."
  },
  {
    "Statement": "indicesOf x = elemIndices x",
    "Description": "The implementation of 'indicesOf' simply applies the 'elemIndices' function to the element 'x' and the input list."
  },
  {
    "Statement": "all :: (a -> Bool) -> Seq a -> Bool",
    "Description": "Declare a function all that checks if all elements of a sequence satisfy a predicate."
  },
  {
    "Statement": "uncapitalize (x:xs) = if isLower x then x:xs else toLower x : xs",
    "Description": "If the first character 'x' of the input string is already lowercase, leave it unchanged and process the remaining characters 'xs'. Otherwise, convert 'x' to lowercase using 'toLower' and prepend it to the remaining characters 'xs'."
  },
  {
    "Statement": "deleteFirstsBy eq xs (y:ys)",
    "Description": "Define the recursive case of the deleteFirstsBy function where two non-empty lists are given. It removes the first occurrence of each element from the first list that satisfies the predicate 'eq'."
  },
  {
    "Statement": "import Data.Char (isDigit)\n\ncountDigits :: String -> Int",
    "Description": "Define a function 'countDigits' that takes a string and returns the count of digits in the string. Import the 'isDigit' function from the 'Data.Char' module."
  },
  {
    "Statement": "bSort (x:xs) acc = bSort xs (bubbleUp x acc)",
    "Description": "Otherwise, recursively call bSort with the tail of the list and the result of bubbleUp with the head of the list and the accumulator."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "map :: Monad m => (a -> b) -> m a -> m b\n\nmap f = fmap f",
    "Description": "Define a function map that takes a function (a -> b) and a monadic value m a and returns a monadic value m b, by applying fmap to the function f and the monadic value."
  },
  {
    "Statement": "if input == ending then",
    "Description": "Check if the input string is equal to the ending string."
  },
  {
    "Statement": "maybe_val <- iom",
    "Description": "Bind the result of evaluating iom to maybe_val."
  },
  {
    "Statement": "zip :: [a] -> [b] -> [(a, b)]",
    "Description": "Define 'zip' as a function which takes two lists and returns a list of corresponding pairs."
  },
  {
    "Statement": "group :: Eq a => Seq a -> Seq (Seq a)",
    "Description": "Declare a function group that groups adjacent elements in a sequence."
  },
  {
    "Statement": "length Nil = 0",
    "Description": "If the input list is Nil, return 0."
  },
  {
    "Statement": "getInput :: IO String",
    "Description": "Define a function getInput that returns an IO action that produces a String."
  },
  {
    "Statement": "treeToSeq (Node x l r) = treeToSeq l >< singleton x >< treeToSeq r",
    "Description": "For a non-empty tree, recursively convert the left and right subtrees into sequences, and concatenate them with the current node's value in the middle."
  },
  {
    "Statement": "(**) as bs = [(a,b) | a <- as, b <- bs]",
    "Description": "Define the '(**)' operator for the 'Monoidal' instance of '[]' as a list comprehension that combines all pairs of elements from the two input lists 'as' and 'bs' into tuples '(a,b)'."
  },
  {
    "Statement": "lift3 :: ( a -> b -> c ) -> (f a -> f b -> f c )",
    "Description": "Declare the 'lift3' function signature, which takes a ternary function '(a -> b -> c -> d)' and returns a function that lifts the ternary function to operate on values of types 'f a', 'f b', and 'f c', returning a value of type 'f d'."
  },
  {
    "Statement": "instance Monad List where",
    "Description": "Define an instance of the Monad typeclass for the List data type."
  },
  {
    "Statement": "readUntilWithCount :: String -> IO Int",
    "Description": "Declare a function named `readUntilWithCount` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read."
  },
  {
    "Statement": "import Data.List (union)\n\nmergeUnique :: Ord a => [a] -> [a] -> [a]",
    "Description": "Define a function 'mergeUnique' that takes two lists of elements of any type 'a' that implements the 'Ord' typeclass, and returns a list containing the unique elements from both input lists. Import the 'union' function from the 'Data.List' module."
  },
  {
    "Statement": "and' = foldl' (&&) True",
    "Description": "The implementation of 'and'' uses 'foldl'' to fold the input list of boolean values using the '&&' operator (logical AND) and an initial accumulator value of 'True'."
  },
  {
    "Statement": "con \":==\" ((==) :: Int -> Int -> Bool),",
    "Description": "Include the ':==' operator signature."
  },
  {
    "Statement": "deriving (Eq, Ord)",
    "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'First' data type."
  },
  {
    "Statement": "]",
    "Description": "End of the list."
  },
  {
    "Statement": "abbreviation sizeT :: \"'a Tree → nat\"",
    "Description": "Define an abbreviation named sizeT which takes a Tree of type 'a and returns a natural number."
  },
  {
    "Statement": "withArgs :: [String] -> IO a -> IO a",
    "Description": "Define a function 'withArgs' which takes a list of strings and an IO action, and executes the action with the specified arguments."
  },
  {
    "Statement": "quickSort :: Ord a => [a] -> [a]",
    "Description": "Define a function named quickSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
  },
  {
    "Statement": "take _ [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "instance Semigroup (Endo a) where",
    "Description": "Define a 'Semigroup' instance for the 'Endo' data type."
  },
  {
    "Statement": "aux acc\n(x:xs) = aux (x:acc) xs",
    "Description": "Otherwise, prepend the current element to the accumulator and continue."
  },
  {
    "Statement": "height :: Tree a -> Int",
    "Description": "Define a function named height which takes a Tree of elements of type a and returns the height of the tree as an Int."
  },
  {
    "Statement": "import Data.List (foldl')\n\nreplicate' :: Int -> a -> [a]",
    "Description": "Define a function 'replicate'' that takes an integer 'n' and a value 'x' of any type 'a', and returns a list of length 'n' with 'x' replicated 'n' times. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "    | otherwise = fmap (+1) (elemIndex y xs)",
    "Description": "Define the condition for the recursive case of the elemIndex function. If the element 'y' is not equal to the current element 'x', it recursively searches in the rest of the list and increments the result by 1."
  },
  {
    "Statement": "safeHeadOr x xs = fromMaybe x (safeHead xs)",
    "Description": "Define 'safeHeadOr' using the 'fromMaybe' function, which returns the value wrapped in the 'Maybe' value if it is 'Just x', or the default value 'x' if it is 'Nothing'."
  },
  {
    "Statement": "wordCount = length . words",
    "Description": "Define 'wordCount' as a composition of the 'words' function (which splits a string into a list of words) and the 'length' function (which returns the length of the list)."
  },
  {
    "Statement": "Lemma contains_in_set: \"contains P xs ⟶ (∃x ∈ set xs. P x)\"",
    "Description": "Define a lemma asserting that if `P` holds for an element in the list, then that element is in the set of the list."
  },
  {
    "Statement": "sortAndRemoveDuplicates = removeDuplicates . sort",
    "Description": "Define 'sortAndRemoveDuplicates' as the composition of the 'sort' function (which sorts the list) and the 'removeDuplicates' function (which removes duplicate elements from the sorted list)."
  },
  {
    "Statement": "evalStateT :: Monad m => StateT s m a -> s -> m a",
    "Description": "Declare a function `evalStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the result value `a` (discarding the final state)."
  },
  {
    "Statement": "import Control.Arrow",
    "Description": "Import the Control.Arrow module, which provides the Arrow typeclass and related functions."
  },
  {
    "Statement": "add 1 :: Int -> Int",
    "Description": "Partially apply the 'add' function with '1' as the first argument, resulting in a function that takes an 'Int' and returns an 'Int' by adding '1' to its argument."
  },
  {
    "Statement": "getName :: MaybeT IO String",
    "Description": "Declare a function named `getName` that returns a `MaybeT IO String` value, which represents a computation that may fail to produce a `String` value within the `IO` monad."
  },
  {
    "Statement": "import Data.Set (Set, empty, insert, union)",
    "Description": "Import the 'Set' data type and related functions from the 'Data.Set' module, which provides a set data structure."
  },
  {
    "Statement": "map [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "  (>>=) :: m a -> (a -> m b) -> m b",
    "Description": "Define the bind operator (>>=) which sequences two monadic actions."
  },
  {
    "Statement": "[]",
    "Description": "Define an empty list."
  },
  {
    "Statement": "con \"multiply\" ((*) :: Int -> Int -> Int),",
    "Description": "Include the 'multiply' function signature."
  },
  {
    "Statement": "main :: IO ()",
    "Description": "Define a function main of type IO ()."
  },
  {
    "Statement": "checkInput [] = False",
    "Description": "If the input String is empty, return False."
  },
  {
    "Statement": "lift $ putStr \"Please enter your name: \"",
    "Description": "Print the prompt \"Please enter your name: \" to the user within the `IO` monad, using `lift` to lift the `IO` action into the `MaybeT` monad."
  },
  {
    "Statement": "maxInts = foldl' max (minBound :: Int)",
    "Description": "The implementation of 'maxInts' uses 'foldl'' to fold the input list of integers using the 'max' function and an initial accumulator value of 'minBound :: Int' (the smallest possible integer value)."
  },
  {
    "Statement": "using sorted. simps(2) sorted append by blast",
    "Description": "Use the given sorted lemma to solve the subgoals."
  },
  {
    "Statement": "f c acc@(x:xs) = (c:x):xs",
    "Description": "If the current character is not whitespace, 'f' prepends it to the current substring in the accumulator."
  },
  {
    "Statement": "type IOMaybe a = IO (Maybe a)",
    "Description": "Define a new type synonym IOMaybe a that represents a computation that can perform side effects and either succeed with a value of type a or fail without a value."
  },
  {
    "Statement": "(Just x) >>= f = f x",
    "Description": "If the input to the bind operation is Just x, apply the function f to x and return the result."
  },
  {
    "Statement": "class Arrow a => ArrowLoop (a :: _->_ -> *)\n  where\n    loop :: a (b, d) (c, d) -> a b c",
    "Description": "Define a type class 'ArrowLoop' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowLoop' class specifies a single method 'loop' for creating feedback loops."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "If the second list is empty, return the first list xs as the result of splicing."
  },
  {
    "Statement": "bSort (x:xs) acc = bSort xs (bubbleUp x acc)",
    "Description": "Otherwise, recursively call bSort with the tail of the list and the result of bubbleUp with the head of the list and the accumulator."
  },
  {
    "Statement": "module main where",
    "Description": "Start of the main module."
  },
  {
    "Statement": "deriving (Eq, Ord)",
    "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Any' data type."
  },
  {
    "Statement": "class Applicative m => Monad (m :: _\\->_ )\n\nwhere\n\n    (>>=) :: m a -> (a -> m b) -> m b\n\n    (>>) :: m a -> m b -> m b\n\n    return :: a -> m a",
    "Description": "Define a typeclass Monad that extends the Applicative typeclass. It has three member functions: (>>=) that takes a monadic value m a and a function (a -> m b) and returns a monadic value m b, (>>) that takes two monadic values m a and m b and returns m b, and return that takes a value a and returns a monadic value m a."
  },
  {
    "Statement": "bubbleUp x (y:ys) | x > y = y : bubbleUp x ys",
    "Description": "If x is greater than the head of the accumulator, prepend the head to the result of recursively calling bubbleUp with x and the tail of the accumulator."
  },
  {
    "Statement": "import Data.Tree.Zipper",
    "Description": "Import the 'Data.Tree.Zipper' module, which provides a zipper data structure for navigating and modifying trees."
  },
  {
    "Statement": "then show ?thesis using False sets_value_sortedT sorted_left sorted_right tv_disjunct \"2.IH\" (2) by auto",
    "Description": "then show the thesis using the given data and the assumed statement."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "maximum :: Ord a => [a] -> a",
    "Description": "Define a function named `maximum` which takes a list of type `[a]` and returns an element of type `a`."
  },
  {
    "Statement": "scanr1 :: (a -> a -> a) -> Seq a -> Seq a",
    "Description": "Declare a function scanr1 that scans a non-empty sequence from the right with a binary function."
  },
  {
    "Statement": "WithProgName name action = System.Environment.withProgName name action",
    "Description": "Implement the 'WithProgName' function using 'System.Environment.withProgName'."
  },
  {
    "Statement": "foldr (\\elem acc -> <term>) <start_acc> <list>",
    "Description": "Define a fold operation where the function takes an element and an accumulator as arguments, starting with an initial accumulator value, and folding from the right over the list."
  },
  {
    "Statement": "readUntilWithState :: String -> IO Int",
    "Description": "Declare a function named `readUntilWithState` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read, using the `StateT` monad transformer."
  },
  {
    "Statement": "bSort [] acc = acc",
    "Description": "If the input list is empty, return the accumulator."
  },
  {
    "Statement": "example = runMaybeT $ do",
    "Description": "Define a value `example` by running a `MaybeT` computation using `runMaybeT`."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
  },
  {
    "Statement": "quicksort [] = []",
    "Description": "If the input list is empty, return an empty list."
  },
  {
    "Statement": "Lemma \"sorted (inorder (fromList x§) )\"",
    "Description": "State the lemma 'sorted (inorder (fromList x§))'."
  },
  {
    "Statement": "import Data.List (nub, sort)\n\nuniqueSort :: Ord a => [a] -> [a]",
    "Description": "Define a function 'uniqueSort' that takes a list of elements of any type 'a' that implements the 'Ord' typeclass, and returns a sorted list of unique elements. Import the 'nub' and 'sort' functions from the 'Data.List' module."
  },
  {
    "Statement": "failing = do throw Error",
    "Description": "Define the failing function to throw an exception of type Error."
  },
  {
    "Statement": "execStateT :: Monad m => StateT s m a -> s -> m s",
    "Description": "Declare a function `execStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the final state `s` (discarding the result value)."
  },
  {
    "Statement": "frequencies :: Ord a => [a] -> Map a Int",
    "Description": "Define a function 'frequencies' that takes a list of elements of type 'a' (which must be an instance of the 'Ord' typeclass) and returns a map of elements to their frequencies in the list."
  },
  {
    "Statement": "class (Preorder a) => Order a where {",
    "Description": "Define a class 'Order' with type variable 'a' which is a subclass of 'Preorder', where,"
  },
  {
    "Statement": "(>>>=) = bindIOM",
    "Description": "Define the fish operator (>>>=) as a synonym for the bindIOM function, which is a common convention in Haskell."
  },
  {
    "Statement": "if checkInput input",
    "Description": "Check if the input satisfies the checkInput condition."
  },
  {
    "Statement": "checkInput :: String -> Bool",
    "Description": "Define a function checkInput that takes a String and returns a Bool indicating whether the input is valid or not."
  },
  {
    "Statement": "delete _ [] = []",
    "Description": "Define the case of the delete function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "If the second list is empty, return the first list xs as the result of splicing."
  },
  {
    "Statement": "zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys",
    "Description": "Define the recursive case of the zipWith function where two non-empty lists are given. It applies the function 'f' to the first elements of each list, then recursively does the same for the rest of the lists."
  },
  {
    "Statement": "name :: Person -> String",
    "Description": "Define a function 'name' which takes a 'Person' and returns their name."
  },
  {
    "Statement": "prelude",
    "Description": "Include the prelude."
  },
  {
    "Statement": "have \"Viv € setT (insert v r). iv ≥ tv\" using setT insert tv disjunct False by (metis Un iff le cases single",
    "Description": "assert that all the elements in the setT (insert v r) are greater than or equal to 'tv'."
  },
  {
    "Statement": "getLine",
    "Description": "Read a line of input from the user."
  },
  {
    "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
    "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
  },
  {
    "Statement": "put (count + 1)",
    "Description": "Update the state by incrementing the current count by 1."
  },
  {
    "Statement": "apply (induct t)",
    "Description": "Begin the proof by induction over tree t."
  },
  {
    "Statement": "instance MonadTrans (ExceptT e) where\n    lift = ExceptT . liftM Right",
    "Description": "Provide an instance of the 'MonadTrans' type class for the 'ExceptT' monad transformer. This instance allows for lifting computations into the 'ExceptT' monad transformer."
  },
  {
    "Statement": "con \"insertAt\" (insert :: Ord a => a -> [a] -> [a]),",
    "Description": "Include the 'insertAt' function signature."
  },
  {
    "Statement": "where types = (x :: Maybe Int, y :: Maybe Int)",
    "Description": "Specify the types of 'x' and 'y' as 'Maybe' integers for the 'prop' function."
  },
  {
    "Statement": "| n == 0      =1",
    "Description": "If `n` is equal to 0, return 1."
  },
  {
    "Statement": "replicate n x",
    "Description": "Replicate the element `x` `n` times."
  },
  {
    "Statement": "(Just v) -> f v",
    "Description": "If maybe_val is Just v, apply the function f to v and return the result."
  },
  {
    "Statement": "lift3 :: (a -> b -> c -> d) -> (f a -> f b -> f c -> f d)",
    "Description": "Declare the 'lift3' function signature, which takes a ternary function '(a -> b -> c -> d)' and returns a function that lifts the ternary function to operate on values of types 'f a', 'f b', and 'f c', returning a value of type 'f d'."
  },
  {
    "Statement": "background [ prelude ]",
    "Description": "Include the Prelude module in the background."
  },
  {
    "Statement": "instance Monad []",
    "Description": "Create an instance of the Monad typeclass for the list type constructor [], which represents computations that can return multiple values."
  },
  {
    "Statement": "execStateT :: Monad m => StateT s m a -> s -> m s",
    "Description": "Declare a function `execStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the final state `s` (discarding the result value)."
  },
  {
    "Statement": "readChan :: Chan a -> IO a",
    "Description": "Read a value of type a from the given channel, blocking until there is a sender."
  },
  {
    "Statement": "sortBy _ [] = []",
    "Description": "Define the case of the sortBy function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "sum (x: xs) = x + sum xs",
    "Description": "Sum the first element x with the sum of the remaining elements xs recursively."
  },
  {
    "Statement": "fmap :: (a -> b) -> f a -> f b",
    "Description": "Declare the 'fmap' function signature for the 'Functor' type class, which takes a function '(a -> b)' and a value of type 'f a', and returns a value of type 'f b'."
  },
  {
    "Statement": "qed",
    "Description": "Close the current proof."
  },
  {
    "Statement": "f $ x = f x",
    "Description": "Define the ($) operator to apply the function f to the value x."
  },
  {
    "Statement": "cross = (,)",
    "Description": "Implement the 'cross' function using the tuple constructor '(,)'."
  },
  {
    "Statement": "is_zero 0 = True | is_zero _ = False",
    "Description": "Define a function 'is_zero' that pattern matches on its argument. If the argument is 0, return True; otherwise, return False."
  },
  {
    "Statement": "map :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function 'map' which takes a function from 'a' to 'b' and a list of 'a's, returning a list of 'b's."
  },
  {
    "Statement": "instance Monad IO where\n    return = pure\n    m >>= k  = do\n        a <- m\n        k a\n    (>>) = (*>)",
    "Description": "Provide an instance of the 'Monad' type class for the 'IO' data type. This instance allows for sequencing and combining 'IO' computations."
  },
  {
    "Statement": "foldr1 f (x:xs) = foldr f x xs",
    "Description": "Define 'foldr1' as a function that applies a binary function in a right-associative manner to the elements of a non-empty list, using the first element as the starting value."
  },
  {
    "Statement": "map :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
  },
  {
    "Statement": "add = (\\x -> (\\y -> x+y))",
    "Description": "Define the 'add' function as a composition of two lambda functions, the outer one taking 'x' and the inner one taking 'y', returning their sum."
  },
  {
    "Statement": "mergeSort [x] = [x]",
    "Description": "For a list with a single element, 'mergeSort' returns the same list."
  },
  {
    "Statement": "(>>>=) = bindIOM",
    "Description": "Define the (>>>=) operator as bindIOM."
  },
  {
    "Statement": "fac n",
    "Description": "Define `fac` with parameter `n`."
  },
  {
    "Statement": "lemma insert_sorted:",
    "Description": "Define a lemma named insert_sorted."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "The base case for summing an empty list, which returns 0."
  },
  {
    "Statement": "splitAt :: Int -> Seq a -> (Seq a, Seq a)",
    "Description": "Declare a function splitAt that splits a sequence at a specified index."
  },
  {
    "Statement": "import Data.List (isPrefixOf)\n\nstartsWith :: Eq a => [a] -> [a] -> Bool",
    "Description": "Define a function 'startsWith' that takes two lists of elements of any type 'a' that implements the 'Eq' typeclass, and returns 'True' if the first list is a prefix of the second list, and 'False' otherwise. Import the 'isPrefixOf' function from the 'Data.List' module."
  },
  {
    "Statement": "greet Hello",
    "Description": "Define a function 'greet' that takes a string argument and prints 'Hello user' with the argument appended."
  },
  {
    "Statement": "apply (induction t1)",
    "Description": "Begin the proof by induction over tree t1."
  },
  {
    "Statement": "[2x | x <- [1,2,3] ]",
    "Description": "Generate a list where each element is obtained by doubling each element of the list [1,2,3]."
  },
  {
    "Statement": "newtype Product a = Product { getProduct :: a }\nderiving (Eq, Ord, ..... )",
    "Description": "Define a new data type Product that wraps a value of type a, and derives various type class instances for it, such as Eq, Ord, etc."
  },
  {
    "Statement": "else return Nothing",
    "Description": "If the input is not valid, return a failed IOMaybe computation by returning Nothing."
  },
  {
    "Statement": "return x = Just x",
    "Description": "Define the return function for the Maybe monad, which wraps a value in Just."
  },
  {
    "Statement": "return (in_lower_bound && in_upper_bound);",
    "Description": "Return true if 'x' is within the range [min, max], otherwise false."
  },
  {
    "Statement": "case maybe_val of",
    "Description": "Begin a case expression to handle the two possible cases of maybe_val: Nothing or Just v."
  },
  {
    "Statement": "(\\*\\*) :: Applicative f => f a -> f b -> f (a,b)\n\n(\\*\\*) fa fb = pure (,) <\\*> fa <\\*> fb",
    "Description": "Define an operator (\\*\\*) that takes two Applicative functors f a and f b and returns their product f (a,b), using the pure and (<\\*>) functions from the Applicative typeclass."
  },
  {
    "Statement": "getProgname = System.Environment.getProgname",
    "Description": "Assign the 'getProgname' function to retrieve the program name."
  },
  {
    "Statement": "fun mirror :: \"'a Tree → 'a Tree\"",
    "Description": "Define a function named `mirror` which takes a `Tree` and returns a `Tree`."
  },
  {
    "Statement": "(Cons x xs) >>= f = append (f x) (xs >>= f)",
    "Description": "If the input to the bind operation is Cons x xs, apply the function f to x, recursively apply the bind operation to xs, and concatenate the results."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "reverse [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "findIndex x = elemIndex x",
    "Description": "Define 'findIndex' as the 'elemIndex' function, which returns the index of the first occurrence of an element in a list, or 'Nothing' if the element is not found."
  },
  {
    "Statement": "fromJust :: Maybe a -> a",
    "Description": "Define a function 'fromJust' which extracts the value from a 'Just' constructor. Caution: This function throws an error if given a 'Nothing' value, so it should be used with care."
  },
  {
    "Statement": "getName :: IOMaybe String",
    "Description": "Define a function getName that represents an IOMaybe computation that can get a valid name from the user."
  },
  {
    "Statement": "instance Monad []",
    "Description": "Create an instance of the Monad typeclass for the list type constructor [], which represents computations that can return multiple values."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Get a line of input from the user using the getLine function from the IO monad."
  },
  {
    "Statement": "msum :: (Foldable t, Alternative f) => t (f a) -> f a\nmsum = foldr (<|>) empty",
    "Description": "Define a function 'msum' that takes a foldable container of alternative structures and returns a single alternative structure containing the result of folding over the container using the '<|>' operation."
  },
  {
    "Statement": "(>>>=) = bindIOM",
    "Description": "Define the fish operator (>>>=) as a synonym for the bindIOM function, which is a common convention in Haskell."
  },
  {
    "Statement": "m >>= f = case m of",
    "Description": "Define a function (>>=) which takes a Maybe value m and a function f, and performs a case analysis on m."
  },
  {
    "Statement": "import Data.List (foldl')\n\ndrop' :: Int -> [a] -> [a]",
    "Description": "Define a function 'drop'' that takes an integer 'n' and a list of elements of any type 'a', and returns a list containing all elements of the input list except the first 'n' elements. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "(<>) = coerce ((.) :: (a -> a) -> (a -> a) -> (a -> a))",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Endo a' by converting the '(.)' function for type '(a -> a)' to the appropriate type using 'coerce'."
  },
  {
    "Statement": "data MyError = Error deriving Show",
    "Description": "Define a data type MyError with a single constructor Error, and derive the Show instance for it."
  },
  {
    "Statement": "startsWith :: Eq a => [a] -> [a] -> Bool",
    "Description": "Define a function 'startsWith' that takes two lists of elements of type 'a' (which must be an instance of the 'Eq' typeclass) and returns 'True' if the first list is a prefix of the second list, and 'False' otherwise."
  },
  {
    "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'First a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
  },
  {
    "Statement": "  {-# MINIMAL (>>=) #-}",
    "Description": "Specify that the bind operator is the minimal complete definition for a Monad instance."
  },
  {
    "Statement": "square :: Int -> Int\nsquare x = x * x",
    "Description": "Define a function square that takes an integer x and returns its square."
  },
  {
    "Statement": "if checkInput input",
    "Description": "Check if the input is valid using the checkInput function."
  },
  {
    "Statement": "class Arrow a => ArrowChoice (a :: _->_ -> *)\n  where\n    lift :: a b c -> a (Either b d) (Either c d)\n    right :: a b c -> a (Either d b) (Either d c)\n    (+++) :: a b c -> a b' c' -> a (Either b b') (Either c c')\n    (|||) :: a b d -> a b d -> a (Either b c) d",
    "Description": "Define a type class 'ArrowChoice' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowChoice' class specifies methods for working with sum types (e.g., 'Either') and choice operations."
  },
  {
    "Statement": "removeDuplicates = nub",
    "Description": "Use the `nub` function to remove duplicate elements from the list."
  },
  {
    "Statement": "instance Monad []",
    "Description": "Define a Monad instance for lists."
  },
  {
    "Statement": "| otherwise = x : replicate (n-1) x",
    "Description": "Otherwise, replicate the element `x` `n` times."
  },
  {
    "Statement": "writeChan :: Chan a -> a -> IO ()",
    "Description": "Write a value of type a to the given channel, blocking until there is a receiver."
  },
  {
    "Statement": "xs' <- shuffleM xs",
    "Description": "Shuffle the characters of the input string `xs` using the `shuffleM` function."
  },
  {
    "Statement": "nub [] = []",
    "Description": "Define the base case of the nub function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "runStateT :: StateT s m a -> s -> m (a, s)",
    "Description": "Declare a function `runStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning the result value `a` and the final state `s`."
  },
  {
    "Statement": "instance Monoid a => Applicative ((,) a) where\n    pure x = (mempty, x)\n    (u, f) <*> (v, x) = (u `mappend` v, f x)\n    (*>) = (>>)\n    (<*) = const",
    "Description": "Provide an instance of the 'Applicative' type class for the tuple type constructor '(,) a', assuming that 'a' is an instance of the 'Monoid' type class. This instance allows for applying and combining computations."
  },
  {
    "Statement": "putMVar :: MVar a -> a -> IO ()",
    "Description": "Put a value of type a into the given MVar, blocking until the MVar is empty."
  },
  {
    "Statement": "where f' x y = f (x, snd y )",
    "Description": "Define a helper function f' that takes x and y, and applies the original function f to (x, snd y), where snd y is the second component of y."
  },
  {
    "Statement": "\"shows 'sorted (inorder l @ [v] @ inorder r)'\"",
    "Description": "Show that the inorder traversal of l, followed by v, followed by the inorder traversal of r, is sorted."
  },
  {
    "Statement": "in_lower_bound = min <= x;",
    "Description": "Check if 'x' is greater than or equal to 'min' and assign the result to 'in_lower_bound'."
  },
  {
    "Statement": "quicksort [] = []",
    "Description": "For an empty list, 'quicksort' returns an empty list."
  },
  {
    "Statement": "unwords :: [String] -> String",
    "Description": "Define 'unwords' as a function which joins words with separating spaces."
  },
  {
    "Statement": "prop x y z = ((x <> y) <> z) === (x <> (y <> z))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'NonEmpty a' by comparing the results of two equivalent expressions involving '<>'."
  },
  {
    "Statement": "fromInteger :: Integer-> a",
    "Description": "Define a conversion function 'fromInteger' within the 'Num' typeclass which takes an Integer and returns a value of type 'a'."
  },
  {
    "Statement": "abbreviation contains :: \"('a ⇒ bool) ⇒ 'a list ⇒ bool\"",
    "Description": "Define an abbreviation named `contains` which takes a function `('a ⇒ bool)` and a list of type `'a` and returns a `bool` indicating whether the element is in the list."
  },
  {
    "Statement": "con \"realPart\" (realPart :: Complex Float -› Float),",
    "Description": "Include the 'realPart' function signature in 'complexSig'."
  },
  {
    "Statement": "delete :: Eq a => a -> [a] -> [a]",
    "Description": "Define 'delete' as a function which removes the first occurrence of the given element from the list."
  },
  {
    "Statement": "by auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "merge :: Ord a => [a] -> [a] -> [a]",
    "Description": "Define a function 'merge' that takes two sorted lists and returns a single sorted list."
  },
  {
    "Statement": "then show ?thesis using True sets value sortedT \"2.IH\" (1) sorted left sorted right tv disjunct by auto",
    "Description": "then show the thesis using the given data and the assumed statement."
  },
  {
    "Statement": "(Cons x xs) >>= f = append (f x) (xs >>= f)",
    "Description": "If the input to the bind operation is Cons x xs, apply the function f to x, recursively apply the bind operation to xs, and concatenate the results."
  },
  {
    "Statement": "next",
    "Description": "Move to the next case."
  },
  {
    "Statement": "ilb = min <= x",
    "Description": "Check if 'x' is greater than or equal to 'min' and assign the result to 'ilb'."
  },
  {
    "Statement": "sortList xs = sort xs",
    "Description": "The implementation of 'sortList' simply applies the 'sort' function to the input list 'xs'."
  },
  {
    "Statement": "data List a = Nil | Cons a (List a)",
    "Description": "Define a data type named List which is either Nil or a Cons cell containing an element of type a and a List of the same type."
  },
  {
    "Statement": "add 10 20",
    "Description": "Call the function 'add' with arguments 10 and 20, resulting in the sum of 10 and 20."
  },
  {
    "Statement": "seq :: a -> b -> b",
    "Description": "Define a function seq that takes two arguments a and b, and returns b."
  },
  {
    "Statement": "compose :: (b -> c) -> (a -> b) -> a -> c",
    "Description": "Define a function compose that takes two functions f and g, and an argument x, and returns the composition f . g of the two functions applied to x."
  },
  {
    "Statement": "sortedSig - [\npredicate \"sorted\" (sorted :: [Int] -> Bool),",
    "Description": "Declare the signature for the 'sorted' function."
  },
  {
    "Statement": "seq a b = b",
    "Description": "Define the seq function to return its second argument."
  },
  {
    "Statement": "if input == ending then return ncount else aux ending ncount",
    "Description": "Check if the input is equal to the `ending` string. If so, return the current `ncount` value. Otherwise, recursively call `aux` with the same `ending` string and the updated `ncount` value."
  },
  {
    "Statement": "data Node a = Node a [Node a]",
    "Description": "Define a data type 'Node a' to represent a node in a graph, where each node contains a value of type 'a' and a list of child nodes."
  },
  {
    "Statement": "by auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "y :: Bool",
    "Description": "Declare a variable 'y' with type Bool."
  },
  {
    "Statement": "(>>>=) = bindIOM",
    "Description": "Define the fish operator (>>>=) as a synonym for the bindIOM function, which is a common convention in Haskell."
  },
  {
    "Statement": "con \"join\" (intercalate :: [a] -> [[a]] -> [a]),",
    "Description": "Include the 'join' function signature."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]",
    "Description": "Define a function zipWith' that takes a function f and two lists xs and ys, and returns a new list containing the result of applying f to each pair of elements from xs and ys."
  },
  {
    "Statement": "null :: Seq a -> Bool",
    "Description": "Declare a function null that checks if a sequence is empty."
  },
  {
    "Statement": "index :: Seq a -> Int -> a",
    "Description": "Declare a function index that retrieves an element at a specified index from a sequence."
  },
  {
    "Statement": "class Arrow a => ArrowApply (a :: _->_ -> *)\n  where\n    app :: a (a b c, b) c",
    "Description": "Define a type class 'ArrowApply' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowApply' class specifies a single method 'app' for applying an arrow to its input."
  },
  {
    "Statement": "ghci> throw ErrorA",
    "Description": "Throw an exception of type ErrorA in GHCi."
  },
  {
    "Statement": "deriving (Eq, Ord)",
    "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'All' data type."
  },
  {
    "Statement": "instance Monoid w => WriterMonad w ((,) w) where\n    writer = id\n    runWriter = id\n    tell w = ((), w)\n    listen m = (m, snd m)\n    pass (m, f) = (fst m, f $ snd m)",
    "Description": "Provide an instance of the 'WriterMonad' type class for the tuple type constructor '(,) w', assuming that 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value."
  },
  {
    "Statement": "removeDuplicates :: Eq a => [a] -> [a]",
    "Description": "Define a function removeDuplicates that takes a list of Eq type and returns a list with duplicate elements removed."
  },
  {
    "Statement": "runEval :: Eval a -> a",
    "Description": "Run the given Eval computation and return its result."
  },
  {
    "Statement": "put :: s -> m ()",
    "Description": "Declare a function `put` that takes a new state value and updates the current state within the base monad `m`."
  },
  {
    "Statement": "(<>) (First (Just x)) _ = First (Just x)",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'First a' to prioritize the first non-Nothing value."
  },
  {
    "Statement": "module SortingAlgorithms",
    "Description": "Define a module named SortingAlgorithms."
  },
  {
    "Statement": "find _ [] = Nothing",
    "Description": "Define the case of the find function where an empty list is given, it returns Nothing."
  },
  {
    "Statement": "(<**>) mf mx = fmap (\\(f,x) -> f x) (mf ** mx)",
    "Description": "Define the '(<**>)' operator for the 'Monoidal' type class by applying the functions in 'mf' to the values in 'mx' using the '(**)' operator and 'fmap'."
  },
  {
    "Statement": "bubbleSort [] = []",
    "Description": "If the input list is empty, return an empty list."
  },
  {
    "Statement": "getName :: IO (Maybe String)",
    "Description": "Define a function getName that returns an IO action that may produce a String, wrapped in a Maybe type."
  },
  {
    "Statement": "f acc [] = reverse acc",
    "Description": "If the input string is empty, 'f' returns the accumulated characters in reverse order."
  },
  {
    "Statement": "rotateList n xs = take (length xs) (drop n (cycle xs))",
    "Description": "Rotate the list to the left by `n` positions using `cycle`, `drop`, and `take` functions."
  },
  {
    "Statement": "class Functor f => Applicative (f :: _\\->_ )\n\nwhere\n\n    pure :: a -> f a\n\n    (<\\*>) :: f (a -> b) -> (f a -> f b)\n\n    liftA2 :: (a -> b -> c) -> f a -> f b -> f c",
    "Description": "Define a typeclass Applicative that extends the Functor typeclass. It has three member functions: pure that takes a value a and returns a functor f a, (<\\*>) that takes a functor of functions f (a -> b) and a functor f a and returns a functor f b, and liftA2 that takes a function (a -> b -> c) and two functors f a and f b and returns a functor f c."
  },
  {
    "Statement": "empty :: Seq a",
    "Description": "Declare an empty sequence."
  },
  {
    "Statement": "concatMap' :: (a -> [b]) -> [a] -> [b]",
    "Description": "Define a function concatMap' that takes a function f and a list xs, and returns a new list containing the result of applying f to each element of xs, and then concatenating the results."
  },
  {
    "Statement": "bubbleSort xs = bSort xs []",
    "Description": "Otherwise, call the helper function bSort with the input list xs and an empty accumulator."
  },
  {
    "Statement": "let ncount = count + 1",
    "Description": "Calculate the new count by incrementing the current count by 1, and bind it to the variable ncount."
  },
  {
    "Statement": "data List a = Nil | Cons a (List a)",
    "Description": "Define a data type named List which is either Nil or a Cons cell containing an element of type a and a List of the same type."
  },
  {
    "Statement": "main :: IO ()",
    "Description": "Define a function main of type IO ()."
  },
  {
    "Statement": "import Data.List (foldl')\n\nproductInts :: [Int] -> Int",
    "Description": "Define a function 'productInts' that takes a list of integers and returns their product. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "checkInput [] = False",
    "Description": "If the input String is empty, return False."
  },
  {
    "Statement": "elemIndicesL :: Eq a => a -> Seq a -> Seq Int",
    "Description": "Declare a function elemIndicesL that returns all indices of occurrences of an element in a sequence."
  },
  {
    "Statement": "map :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
  },
  {
    "Statement": "inorder :: forall a. Tree a -> [a];",
    "Description": "Define a function 'inorder' which takes a 'Tree a' and returns a list of 'a'."
  },
  {
    "Statement": "class Semigroup a where\n  (<>) :: a -> a -> a",
    "Description": "Define a class Semigroup that represents types that have an associative binary operation (<>)."
  },
  {
    "Statement": "(==) (C n) (C m) = n == m",
    "Description": "Define the equality operator '==' for comparing two temperatures in Celsius. It returns true if their values are equal."
  },
  {
    "Statement": "assumes",
    "Description": "Specify assumptions for the lemma."
  },
  {
    "Statement": "Nothing -> Nothing",
    "Description": "If m is Nothing, then return Nothing."
  },
  {
    "Statement": "if input == ending then return () else aux ending",
    "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `aux` with the same `ending` string."
  },
  {
    "Statement": "insert :: a -> Set a -> Set a",
    "Description": "Declare a function insert that adds an element to a set."
  },
  {
    "Statement": "name arg1 arg2 ... argn = <expr>",
    "Description": "Define a function named 'name' with 'n' arguments and an expression to be evaluated."
  },
  {
    "Statement": "| otherwise    = xs",
    "Description": "Otherwise, return the remaining list."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "evens :: [Int] -> [Int]",
    "Description": "Define a function 'evens' that takes a list of integers and returns a list containing only the even integers."
  },
  {
    "Statement": "con \"trim\" (dropWhile isSpace . reverse . dropWhile isSpace . reverse :: String -> String),",
    "Description": "Include the 'trim' function signature."
  },
  {
    "Statement": "import qualified Lib",
    "Description": "Import the 'Lib' module qualified."
  },
  {
    "Statement": "merge xs [] = xs",
    "Description": "If the second list is empty, 'merge' returns the first list."
  },
  {
    "Statement": "checkInput [] = False",
    "Description": "If the input string is empty, return False."
  },
  {
    "Statement": "greet = do\n   putStrLn \"What is your name?\"\n   name <- getLine\n   let uname = map toUpper name\n   putStrLn (\"Hello \" ++ uname ++ \".\")",
    "Description": "Define 'greet' function which prompts the user for their name, reads the input, converts it to uppercase, and prints a greeting message."
  },
  {
    "Statement": "trimString :: String -> String",
    "Description": "Define a function trimString that takes a String and removes leading and trailing whitespace."
  },
  {
    "Statement": "show :: a -> String",
    "Description": "Define a function 'show' within the 'Show' typeclass which takes a value of type 'a' and returns a string representation."
  },
  {
    "Statement": "put (count + 1)",
    "Description": "Update the state by incrementing the current count by 1 and storing the new value using the `put` function."
  },
  {
    "Statement": "where",
    "Description": "Begin the definition of helper functions for 'words'."
  },
  {
    "Statement": "take' :: Int -> [a] -> [a]",
    "Description": "Define a function take' that takes an integer n and a list xs, and returns the first n elements of xs."
  },
  {
    "Statement": "main = putStrLn \"Hello World!\"",
    "Description": "Print 'Hello World!' when 'main' is executed."
  },
  {
    "Statement": "Lemma sets value sizeT:",
    "Description": "Define a lemma named sizeT_values."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user and bind it to the variable input."
  },
  {
    "Statement": "join :: (Monad m) => m (m a) -> m a\n\njoin x = x >>= id",
    "Description": "Define a function join that takes a nested monadic value m (m a) and flattens it to a single monadic value m a, using the (>>=) operator and the identity function id."
  },
  {
    "Statement": "f (Left 1)",
    "Description": "Applies 'f' to a 'Left' value with 1, resulting in 'Number'."
  },
  {
    "Statement": "con \"headElement\" (head :: [a] -> a),",
    "Description": "Include the 'headElement' function signature."
  },
  {
    "Statement": "readUntilWithCount ending = aux ending 0",
    "Description": "Define the implementation of readUntilWithCount by calling the auxiliary function aux with the ending string and an initial count of 0."
  },
  {
    "Statement": "apply (induction t2)",
    "Description": "Begin the proof by induction over tree t2."
  },
  {
    "Statement": "evalStateT :: Monad m => StateT s m a -> s -> m a",
    "Description": "Declare a function evalStateT that takes a StateT computation and an initial state, and returns a monadic computation that produces the final result, discarding the final state."
  },
  {
    "Statement": "length :: List a -> Int",
    "Description": "Define a function named length which takes a List of elements of type a and returns the length of the list as an Int."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "instance Monoid (Any a) where",
    "Description": "Define a 'Monoid' instance for the 'Any' data type."
  },
  {
    "Statement": "    | otherwise = x:xs",
    "Description": "Define the condition for the recursive case of the dropWhile function. If the predicate 'p' does not hold true for the current element 'x', it returns the list starting from 'x'."
  },
  {
    "Statement": "ones = 1 : ones\ntake 5 (map (*2) ones)\n   ==> [2,2,2,2,2] ",
    "Description": "Define an infinite list named ones where each element is 1 followed by itself. Then, take the first 5 elements of the list obtained by doubling each element of ones."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "main :: IO ()",
    "Description": "Declares the main function."
  },
  {
    "Statement": "f :: a -> (b -> (c -> d))",
    "Description": "Alternatively define the function 'f' using currying syntax, where it takes an argument of type 'a' and returns a function that takes an argument of type 'b' and returns another function that takes an argument of type 'c' and finally returns a value of type 'd'."
  },
  {
    "Statement": "\"sortedT t A t = (Node l v r) → sortedT 1 A sortedT r\"",
    "Description": "If the tree t is sorted, then for every Node l v r, l and r are sorted."
  },
  {
    "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
    "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
  },
  {
    "Statement": "addTuples :: [(Int, Int)] -> [Int]",
    "Description": "Define a function 'addTuples' that takes a list of tuples of integers and returns a list of integers."
  },
  {
    "Statement": "type IOMaybe a = IO (Maybe a)",
    "Description": "Define a new type synonym IOMaybe a that represents a computation that can perform side effects and either succeed with a value of type a or fail without a value."
  },
  {
    "Statement": "instance Monad a => Monad ((,) a)",
    "Description": "Create an instance of the Monad typeclass for the tuple type constructor (,) a, given that a is an instance of the Monad typeclass."
  },
  {
    "Statement": "flip' :: (a -> b -> c) -> b -> a -> c",
    "Description": "Define a function flip' that takes a function f and two arguments a and b, and returns the result of applying f to b and a (flipping the order of the arguments)."
  },
  {
    "Statement": "isPrefixOf _ [] = False",
    "Description": "Define the case of the isPrefixOf function where the second list is empty, it returns False."
  },
  {
    "Statement": "execStateT :: Monad m => StateT s m a -> s -> m s",
    "Description": "Declare a function `execStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the final state `s` (discarding the result value)."
  },
  {
    "Statement": "words = filter (not . null) . map trim . split",
    "Description": "Define 'words' as a composition of several functions: 'split' splits the string into a list of substrings, 'map trim' trims leading and trailing whitespace from each substring, 'filter (not . null)' removes any empty substrings."
  },
  {
    "Statement": "main = do catch failing (\\(e :: MyError) -> do putStrLn \"Something went wrong!\")",
    "Description": "Define the main function to catch any exceptions of type MyError thrown by failing, and print a message \"Something went wrong!\" if an exception is caught. The handler function is explicitly typed to match the MyError type."
  },
  {
    "Statement": "import System.Exit",
    "Description": "Import the System.Exit module to handle program exit."
  },
  {
    "Statement": "fun insert v Leaf = Node Leaf v Leaf",
    "Description": "If the tree is empty, insert `v` and create a node."
  },
  {
    "Statement": "fmap :: (a -> b) -> f a -> f b\n\n(<$>) :: (a -> b) -> f a -> f b\n\n(<\\*>) :: f (a -> b) -> (f a -> f b)",
    "Description": "Define three functions: fmap that takes a function (a -> b) and a functor f a and returns a functor f b, (<$>) that does the same thing, and (<\\*>) that takes a functor of functions f (a -> b) and a functor f a and returns a functor f b."
  },
  {
    "Statement": "Lemma sortedT_values sets: \"sortedT t A t = (Node l v r) → (Vv € setT l. lv ≤ v) A (Vrv e setT r. rv 2 v)\"",
    "Description": "Define a lemma asserting that if the tree t is sorted, then the left and right subtrees are also sorted."
  },
  {
    "Statement": "have \"insert v (Node l tv r) = Node l tv (insert v r)\" by (simp add: False)",
    "Description": "then prove the equation 'insert v (Node l tv r) = Node l tv (insert v r)'."
  },
  {
    "Statement": "by (induct xs) (auto simp:sorted insert)",
    "Description": "Prove the lemma by induction on 'xs' and using 'auto simp:sorted insert'."
  },
  {
    "Statement": "rev xs = rev_aux [] xs\nwhere\n  rev_aux acc [] = acc\n  rev_aux acc (x:xs) =  rev_aux (x:acc) xs",
    "Description": "Define a function rev that reverses a list xs using an auxiliary function rev_aux. The rev_aux function accumulates elements in reverse order into an accumulator list acc, and once the input list becomes empty, it returns the accumulator."
  },
  {
    "Statement": "con \"maximum\" (maximum :: [Int] -> Int),",
    "Description": "Include the 'maximum' function signature."
  },
  {
    "Statement": "sum (x: xs) = x + sum xs",
    "Description": "Sum the first element x with the sum of the remaining elements xs recursively."
  },
  {
    "Statement": "cycle' :: [a] -> [a]",
    "Description": "Define a function cycle' that takes a list xs and returns an infinite list by repeatedly cycling through the elements of xs."
  },
  {
    "Statement": "monoTypeWithVars [\"t\", \"t1\", \"t2\"] (Proxy :: Proxy (Tree OrdA)),",
    "Description": "Include the type proxy 'Tree OrdA' in 'treesig2' with type variables 't', 't1', and 't2'."
  },
  {
    "Statement": "where aux ending = do",
    "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string as an argument."
  },
  {
    "Statement": "deriving (Eq, Ord)",
    "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Last' data type."
  },
  {
    "Statement": "import Data.Char (isUpper)\n\ncapitalize :: String -> String",
    "Description": "Define a function 'capitalize' that takes a string and returns a new string with the first character capitalized (if it is a letter) and the remaining characters unchanged. Import the 'isUpper' function from the 'Data.Char' module."
  },
  {
    "Statement": "instance ArrowApply (->) where",
    "Description": "Create an instance of the ArrowApply typeclass for the function type constructor (->) that represents functions."
  },
  {
    "Statement": "(\\x -> x+1) 1",
    "Description": "Applly the anonymous function (\\x -> x+1) to the value 1, resulting in 2."
  },
  {
    "Statement": "treeToSet (Node x l r) = insert x (union (treeToSet l) (treeToSet r))",
    "Description": "For a non-empty tree, recursively convert the left and right subtrees into sets, union them, and insert the current node's value into the resulting set."
  },
  {
    "Statement": "if input == ending then return () else aux ending",
    "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `aux` with the same `ending` string."
  },
  {
    "Statement": "con \":+\" ((:+) :: Float -› Float -> Complex Float),",
    "Description": "Include the ':+' operator signature in 'complexSig'."
  },
  {
    "Statement": "calc :: Calculation -> Int",
    "Description": "Define a function 'calc' which takes a 'Calculation' and returns an 'Int'."
  },
  {
    "Statement": "put :: s -> m ()",
    "Description": "Declare a function `put` that takes a new state value and updates the current state within the base monad `m`."
  },
  {
    "Statement": "lift3 f x y = lift2 f x y",
    "Description": "Define the 'lift3' function by applying 'lift2' to the input function 'f' and the input values 'x' and 'y' of type 'f a'."
  },
  {
    "Statement": "where types = (x :: Endo Int, y :: Endo Int, z :: Endo Int)",
    "Description": "Specify the types of 'x', 'y', and 'z' as 'Endo' functions of integers for the 'prop' function."
  },
  {
    "Statement": "| otherwise = n * fac (n-1)",
    "Description": "Otherwise, return `n * fac (n-1)`."
  },
  {
    "Statement": "lookup y ((x,v):xys)",
    "Description": "Define the recursive case of the lookup function where a non-empty list of key-value pairs is given. It searches for the key 'y' in the list."
  },
  {
    "Statement": "lemma tree_union:",
    "Description": "Define a lemma named tree_union."
  },
  {
    "Statement": "type IOMaybe a = IO (Maybe a)\n\nreturnIOM :: a -> IOMaybe a\nreturnIOM = return . Just\n\nbindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b\nbindIOM iom f = do\n    maybe_val <- iom\n    case maybe_val of\n        Nothing -> return Nothing\n        Just val -> f val",
    "Description": "Define a new type synonym 'IOMaybe' that represents a computation that can perform side effects and either succeed with a value of type 'a' or fail without a value. Implement functions 'returnIOM' and 'bindIOM' to work with 'IOMaybe'."
  },
  {
    "Statement": "         in l : case s' of",
    "Description": "Define the recursive case of the lines function. It adds the line to the result and processes the remaining string."
  },
  {
    "Statement": "rights :: [Either a b] -> [b]",
    "Description": "Define a function 'rights' that takes a list of 'Either' values and returns a list containing only the 'Right' values."
  },
  {
    "Statement": "lemma setT insert: \"setT (insert v t) = setT t ∪ {v}\"",
    "Description": "Define a lemma asserting the set of a tree after inserting v is equal to the set of the original tree unioned with {v}."
  },
  {
    "Statement": "x :: Integer",
    "Description": "Declare a variable 'x' with type Integer."
  },
  {
    "Statement": "maximum' :: Ord a => [a] -> a",
    "Description": "Define a function maximum' that takes a non-empty list xs and returns the maximum element of xs."
  },
  {
    "Statement": "proof (induction t rule:insert. induct)",
    "Description": "Apply induction on the tree with the rule for the 'insert' function."
  },
  {
    "Statement": "import Data.List (foldl')\n\nmap' :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function 'map'' that takes a function 'f :: a -> b' and a list of elements of type 'a', and returns a list containing the results of applying 'f' to each element of the input list. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "iterate' :: (a -> a) -> a -> [a]",
    "Description": "Define a function iterate' that takes a function f and an initial value x, and returns an infinite list by repeatedly applying f to x."
  },
  {
    "Statement": "(<>) = coerce ((+) :: a -> a -> a)",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Product a' by converting the '(+)' function for type 'a' to the appropriate type using 'coerce'."
  },
  {
    "Statement": "case (1 v)",
    "Description": "If the case is (1 v),"
  },
  {
    "Statement": "if (1+1) 'mod' 2 == 0 then (1+1) else (2+1)",
    "Description": "Evaluate the expression using if-then-else, if (1+1) is even, return (1+1), otherwise return (2+1)."
  },
  {
    "Statement": "Lemma sizeT_values sets: \"sizeT t A t = (Node l v r) → (sizeT l < sizeT (Node l v r) ∧ sizeT r < sizeT (Node l v r))\"",
    "Description": "Define a lemma asserting that if the tree t is a non-leaf node, then the sizes of its left and right subtrees are less than the size of the node itself."
  },
  {
    "Statement": "fromList :: [a] -> Set a",
    "Description": "Declare a function fromList that takes a list and returns a set."
  },
  {
    "Statement": "add a b = a+b",
    "Description": "Define a function 'add' that takes two arguments 'a' and 'b' and returns their sum."
  },
  {
    "Statement": "x = 1",
    "Description": "Assign the value 1 to the variable 'x'."
  },
  {
    "Statement": "instance Monad Maybe where",
    "Description": "Declare an instance of the Monad type class for the Maybe type."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "have tv disjunct: \"(Vlv € setT l. lv S tv) A (Vrv € setT r. rv 2 tv)\" using \"2.prems\" sortedT values sets by k",
    "Description": "assert the disjunction of 'tv' with the set 'l' and 'r'."
  },
  {
    "Statement": "input <- lift getLine",
    "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
  },
  {
    "Statement": "reverse (Cons x xs) = append (reverse xs) (Cons x Nil)",
    "Description": "Otherwise, recursively call reverse with the tail of the list and prepend the head of the list to the result."
  },
  {
    "Statement": "apply (induct t)",
    "Description": "Begin the proof by induction over tree t."
  },
  {
    "Statement": "filter' :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function filter' that takes a predicate p and a list xs, and returns a new list containing only the elements of xs that satisfy the predicate p."
  },
  {
    "Statement": "evens [] = []",
    "Description": "Base case: If the list is empty, the result is an empty list."
  },
  {
    "Statement": "safeGetLine = do",
    "Description": "Begin the definition of safeGetLine by using a do block."
  },
  {
    "Statement": "newtype First a = First { getFirst :: Maybe a }",
    "Description": "Define a new data type called 'First' with a single constructor 'First' that wraps a 'Maybe' value of type 'a'. The 'getFirst' function extracts the 'Maybe' value of type 'a' from the 'First' constructor."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "Define the splice function for an empty list and a non-empty list ys to return the list ys."
  },
  {
    "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Sum a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
  },
  {
    "Statement": "lemma tree_subset:",
    "Description": "Define a lemma named tree_subset."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
  },
  {
    "Statement": "proof (cases \"v s tv\")",
    "Description": "Apply proof by cases on 'v s tv'."
  },
  {
    "Statement": "unwords [] = \"\"",
    "Description": "Define the base case of the unwords function where an empty list is given, it returns an empty string."
  },
  {
    "Statement": "lemma contains_drop: \"contains P (drop n xs) ⟶ contains P xs\"",
    "Description": "Define a lemma asserting that if `P` holds for an element in the dropped list, then `P` holds for that element in the original list."
  },
  {
    "Statement": "bubbleSort xs = bSort xs []",
    "Description": "Otherwise, call the helper function bSort with the input list xs and an empty accumulator."
  },
  {
    "Statement": "instance Monad (Either e)",
    "Description": "Create an instance of the Monad typeclass for the Either e data type, which represents computations that can either succeed with a value of type a or fail with a value of type e."
  },
  {
    "Statement": " of boolean values using the '||' operator (logical OR) and an initial accumulator value of 'False'."
  },
  {
    "Statement": "instance Exception MyError",
    "Description": "Make the MyError data type an instance of the Exception class."
  },
  {
    "Statement": "import Data.Ord ( comparing )",
    "Description": "Import the 'comparing' function from Data.Ord module."
  },
  {
    "Statement": "evalState :: States a →> s -> a",
    "Description": "Declare a function evalState that takes a State computation and an initial state, and returns the final result, discarding the final state."
  },
  {
    "Statement": "splice [] [] = []",
    "Description": "Define the splice function for two empty lists to return an empty list."
  },
  {
    "Statement": "using assms sorted append by fastforce",
    "Description": "Use the given sorted lemma and fastforce tactic to solve the subgoal."
  },
  {
    "Statement": "Lemma sortedT_values sets: \"sortedT t A t = (Node l v r) → (Vv € setT l. lv ≤ v) A (Vrv e setT r. rv 2 v)\"",
    "Description": "Define a lemma asserting that if the tree `t` is sorted, then the left and right subtrees are also sorted."
  },
  {
    "Statement": "n == 0 =1",
    "Description": "If `n` is equal to 0, return 1."
  },
  {
    "Statement": "con \"fibonacci\" (fib :: Int -> Int),",
    "Description": "Include the 'fibonacci' function signature."
  },
  {
    "Statement": "func :: Int -> Int",
    "Description": "Define a function named `func` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "put (count + 1)",
    "Description": "Update the state by incrementing the current count by 1 and storing the new value using the `put` function."
  },
  {
    "Statement": "findIndexL :: (a -> Bool) -> Seq a -> Maybe Int",
    "Description": "Declare a function findIndexL that returns the index of the first element satisfying a predicate in a sequence."
  },
  {
    "Statement": "case False",
    "Description": "If the case is False,"
  },
  {
    "Statement": "con \"absolute\" (abs :: Int -> Int),",
    "Description": "Include the 'absolute' function signature."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "iub = max >= x",
    "Description": "Check if 'x' is less than or equal to 'max' and assign the result to 'iub'."
  },
  {
    "Statement": "concat :: Seq (Seq a) -> Seq a",
    "Description": "Declare a function concat that concatenates a sequence of sequences into a single sequence."
  },
  {
    "Statement": "readUntilWithCount ending = aux ending 0",
    "Description": "Define the implementation of readUntilWithCount by calling the auxiliary function aux with the ending string and an initial count of 0."
  },
  {
    "Statement": "sortAndRemoveDuplicates :: Ord a => [a] -> [a]",
    "Description": "Define a function 'sortAndRemoveDuplicates' that takes a list of elements of type 'a' (which must be an instance of the 'Ord' typeclass) and returns a sorted list with duplicates removed."
  },
  {
    "Statement": "instance Applicative IO where\n    pure = return\n    f <*> a = do\n        f' <- f\n        a' <- a\n        return (f' a')\n    (*>) = (>>)\n    (<*) = const",
    "Description": "Provide an instance of the 'Applicative' type class for the 'IO' data type. This instance allows for applying and combining 'IO' computations."
  },
  {
    "Statement": "func :: Int -> Int -> Int -> Int",
    "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
  },
  {
    "Statement": "foldr (\\acc elem -> <term>) <start_acc> <list>",
    "Description": "Define a fold operation where the function takes an accumulator and an element as arguments, starting with an initial accumulator value, and folding from the right over the list."
  },
  {
    "Statement": "transpose ([]:_) = []",
    "Description": "Define the special case of the transpose function where the input list is empty, it returns an empty list."
  },
  {
    "Statement": "then returnIOM input",
    "Description": "If the input is valid, return a successful IOMaybe computation with the input String."
  },
  {
    "Statement": "quickSort (x:xs) = quickSort [y | y <- xs, y < x] ++ [x] ++ quickSort [y | y <- xs, y >= x]",
    "Description": "Otherwise, recursively call quickSort on the elements less than x, prepend x to the result, and append the result of recursively calling quickSort on the elements greater than or equal to x."
  },
  {
    "Statement": "bindIOM iom f = do",
    "Description": "Begin the implementation of the bindIOM function using the do notation."
  },
  {
    "Statement": "liftIOm io :: io >>= returnIOM",
    "Description": "Implement the liftIOm function by binding the result of the IO computation io to the returnIOM function, which wraps the value in a successful IOMaybe computation."
  },
  {
    "Statement": "f $! x = x 'seq' f x",
    "Description": "Define the ($!) operator to evaluate the value x strictly using seq before applying the function f to it."
  },
  {
    "Statement": "x (D3 1 2 3)",
    "Description": "Access the 'x' coordinate of a 3D point, yielding '1'."
  },
  {
    "Statement": "sortBy :: (a -> a -> Ordering) -> [a] -> [a]",
    "Description": "Define 'sortBy' as a function which sorts a list by the given comparison function."
  },
  {
    "Statement": "if input == ending then return () else aux ending",
    "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `aux` with the same `ending` string."
  },
  {
    "Statement": "length = foldr (\\_ acc -> acc + 1) 0",
    "Description": "Define 'length' as a fold operation that counts the length of the list."
  },
  {
    "Statement": "sortString :: String -> String",
    "Description": "Define a function sortString that takes a String and sorts it in ascending order."
  },
  {
    "Statement": "asc n m | m<n = [] | m==n = [m] | m>n = n : asc (n+1) m",
    "Description": "Define the implementation of the 'asc' function using pattern matching. If 'm' is less than 'n', return an empty list. If 'm' equals 'n', return a singleton list containing 'm'. If 'm' is greater than 'n', prepend 'n' to the result of recursively calling 'asc' with 'n+1' and 'm'."
  },
  {
    "Statement": "wordCount :: String -> Int",
    "Description": "Define a function 'wordCount' that takes a string and returns the number of words in the string."
  },
  {
    "Statement": "map f (x:xs) = f x : map f xs",
    "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
  },
  {
    "Statement": "readUntilWithState ending = execStateT (aux ending) 0",
    "Description": "Define the `readUntilWithState` function by executing the `aux` computation within the `StateT` monad transformer, using `execStateT` to discard the result value and return the final state (the count)."
  },
  {
    "Statement": "if 2 'mod' 2 == 0 then 2 else (2+1)",
    "Description": "Evaluate the expression using if-then-else, if 2 is even, return 2, otherwise return (2+1)."
  },
  {
    "Statement": "findElement x = find (== x)",
    "Description": "The implementation of 'findElement' uses the 'find' function to locate the first occurrence of the element 'x' in the input list, using the '==' operator as the predicate."
  },
  {
    "Statement": "calc (Div x y) = div x y",
    "Description": "Define the 'calc' function pattern matching on the 'Div' constructor, returning the division of 'x' by 'y'."
  },
  {
    "Statement": "calc (Add x y) = x+y",
    "Description": "Define the 'calc' function pattern matching on the 'Add' constructor, returning the sum of 'x' and 'y'."
  },
  {
    "Statement": "scanr' :: (a -> b -> b) -> b -> [a] -> [b]",
    "Description": "Define a function scanr' that takes a function f, an initial value z, and a list xs, and returns a list of successive reduced values from the right, starting with the initial value z."
  },
  {
    "Statement": "safeHead (x:_) = Just x",
    "Description": "For a non-empty list, 'safeHead' returns the first element wrapped in a 'Just' value."
  },
  {
    "Statement": "int x = func1 (arg);",
    "Description": "Define a variable 'x' of type integer which is assigned the result of calling function 'func1' with argument 'arg'."
  },
  {
    "Statement": "lookup _ [] = Nothing",
    "Description": "Define the case of the lookup function where an empty list is given, it returns Nothing."
  },
  {
    "Statement": "revSig =\ncon\n\"rev\" (rev :: [A] -> [A]),",
    "Description": "Declare the signature for 'rev' function."
  },
  {
    "Statement": "splitAt n xs = (take n xs, drop n xs)",
    "Description": "The implementation of 'splitAt' uses the 'take' function to get the first 'n' elements from the input list 'xs', and the 'drop' function to get the remaining elements after dropping the first 'n' elements."
  },
  {
    "Statement": "data Tree a = Empty | Node a (Tree a) (Tree a)",
    "Description": "Define a data type Tree a that represents a binary tree with elements of type a, where each node can have zero, one, or two children."
  },
  {
    "Statement": "merge [] ys = ys",
    "Description": "If the first list is empty, 'merge' returns the second list."
  },
  {
    "Statement": "isNumeric :: String -> Bool",
    "Description": "Define a function 'isNumeric' that takes a string and returns 'True' if the string represents a numeric value, and 'False' otherwise."
  },
  {
    "Statement": "bubbleSort :: Ord a => [a] -> [a]",
    "Description": "Define a function named bubbleSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
  },
  {
    "Statement": "startsWith prefix = isPrefixOf prefix",
    "Description": "Define 'startsWith' as the 'isPrefixOf' function, which checks if a list is a prefix of another list."
  },
  {
    "Statement": "greet :: Person -> String",
    "Description": "Define a function 'greet' which takes a 'Person' and returns a greeting string."
  },
  {
    "Statement": "by auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "unit :: f ()",
    "Description": "Declare the 'unit' function signature for the 'Monoidal' type class, which returns a value of type 'f ()' representing the monoidal unit."
  },
  {
    "Statement": "rdeepseq :: NFData a => Strategy a",
    "Description": "Create a Strategy that evaluates the given value to normal form, fully evaluating all sub-expressions."
  },
  {
    "Statement": "newMVar :: a -> IO (MVar a)",
    "Description": "Create a new MVar with an initial value of type a."
  },
  {
    "Statement": "instance Monad Maybe where",
    "Description": "Define an instance of the Monad typeclass for the Maybe data type."
  },
  {
    "Statement": "failing :: IO ()",
    "Description": "Define a function failing of type IO () that throws an exception of type Error."
  },
  {
    "Statement": "by auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "instance Monoid a => Monad ((,) a) where\n    return x = (mempty, x)\n    (u, m) >>= k = let (v, n) = k m in (u `mappend` v, n)\n    (>>) = (*>)",
    "Description": "Provide an instance of the 'Monad' type class for the tuple type constructor '(,) a', assuming that 'a' is an instance of the 'Monoid' type class. This instance allows for sequencing and combining computations."
  },
  {
    "Statement": "sum :: [Int] -> Int",
    "Description": "Define a function named `sum` which takes a list of `Int` and returns an `Int`."
  },
  {
    "Statement": "length (Cons _ xs) = 1 + length xs",
    "Description": "Otherwise, return 1 plus the length of the tail of the list."
  },
  {
    "Statement": "intersect' function from the 'Data.List' module."
  },
  {
    "Statement": "instance Monad ((->))",
    "Description": "Define a Monad instance for functions."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "import Data.Either (partitionEithers)\n\nsplitEithers :: [Either a b] -> ([a], [b])",
    "Description": "Define a function 'splitEithers' that takes a list of 'Either' values and returns a tuple containing two lists: one with the 'Left' values and one with the 'Right' values. Import the 'partitionEithers' function from the 'Data.Either' module."
  },
  {
    "Statement": "data Tree a = Leaf | Node (Tree a) a (Tree a) ;",
    "Description": "Define a data type 'Tree' with type variable 'a' which can either be a 'Leaf' or a 'Node' with three parameters."
  },
  {
    "Statement": "reverse Nil = Nil",
    "Description": "If the input list is Nil, return Nil."
  },
  {
    "Statement": "foldr1 :: (a -> a -> a) -> Seq a -> a",
    "Description": "Declare a function foldr1 that folds a non-empty sequence from the right with a binary function."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "insert :: Ord a => a -> [a] -> [a]",
    "Description": "Define a function named insert which takes an element of type a, where a is an instance of the Ord typeclass, and a sorted list of elements of the same type, and inserts the element into the correct position in the list."
  },
  {
    "Statement": "(concatMap :: (A -> [B]) -> [A] -> [BJ),",
    "Description": "Define 'concatMap' as a function which takes two arguments of type 'A' and returns a list of 'B'."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "1:2:3:4:5: []",
    "Description": "Construct a list with integers 1 through 5 using the cons operator (:). Each element is separated by the cons operator, and the list is terminated with an empty list."
  },
  {
    "Statement": "findIndicesL :: (a -> Bool) -> Seq a -> Seq Int",
    "Description": "Declare a function findIndicesL that returns all indices of elements satisfying a predicate in a sequence."
  },
  {
    "Statement": "toLowerString :: String -> String",
    "Description": "Define a function toLowerString that takes a String and converts it to lowercase."
  },
  {
    "Statement": "isNothing :: Maybe a -> Bool",
    "Description": "Define a function 'isNothing' which takes a 'Maybe' value and returns 'True' if it is a 'Nothing' value, otherwise returns 'False'."
  },
  {
    "Statement": "zipWith3' :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]",
    "Description": "Define a function zipWith3' that takes a function f and three lists xs, ys, and zs, and returns a new list containing the result of applying f to each triple of elements from xs, ys, and zs."
  },
  {
    "Statement": "evalStateT :: Monad m => StateT s m a -> s -> m a",
    "Description": "Declare a function `evalStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the result value `a` (discarding the final state)."
  },
  {
    "Statement": "return x = Just x",
    "Description": "Define the return function for the Maybe monad, which wraps a value in Just."
  },
  {
    "Statement": "map2D x = (\\xs -> map (\\ys -> map x ys) xs)",
    "Description": "Define 'map2D' as a function taking an argument 'x' and returning a function that maps 'x' over each element of a list of lists."
  },
  {
    "Statement": "contains P (x # xs) = (P x) ∨ (contains P xs)",
    "Description": "Define `contains` as a function that checks if the predicate `P` holds for the head of the list or if it's contained in the tail of the list."
  },
  {
    "Statement": "mergeSort :: Ord a => [a] -> [a]",
    "Description": "Define a function 'mergeSort' that takes a list of elements of type 'a' (which must be an instance of the 'Ord' typeclass) and returns a sorted list."
  },
  {
    "Statement": "signum :: a -> a",
    "Description": "Define the signum operation 'signum' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
  },
  {
    "Statement": "f acc (c:cs) = c : f [] cs",
    "Description": "If the current character is whitespace, 'f' skips it and recursively processes the remaining characters with an empty accumulator."
  },
  {
    "Statement": "greet (Person n_) = \"Hi\" ++ n_",
    "Description": "Define 'greet' function pattern matching on 'Person' constructor with 'n_' as its argument, concatenating \"Hi\" with 'n_'."
  },
  {
    "Statement": "getName = do",
    "Description": "Begin the definition of getName by using a do block."
  },
  {
    "Statement": "data [l a = [] a : [a]",
    "Description": "Declare a data type [a] that represents a list of elements of type a, with two constructors: [] (representing an empty list) and (:) (representing a non-empty list by prepending an element to an existing list)."
  },
  {
    "Statement": "progname arg1 arg2 arg3 arg4",
    "Description": "Define a program with four arguments."
  },
  {
    "Statement": "trim :: String -> String",
    "Description": "Define a function 'trim' that takes a string and returns the string with leading and trailing whitespace removed."
  },
  {
    "Statement": "splice [] [] = []",
    "Description": "The base case for splicing two empty lists, which returns an empty list."
  },
  {
    "Statement": "removeDuplicates = nub",
    "Description": "Define 'removeDuplicates' as the 'nub' function, which removes duplicates from a list."
  },
  {
    "Statement": "input <- liftIO getLine",
    "Description": "Read a line of input from the user within the `IO` monad, lifted into the `StateT` monad using `liftIO`."
  },
  {
    "Statement": "(<\\*\\*>) :: Monoidal f => f (a -> b) -> f a -> f b\n\n(<\\*\\*>) mf mx = fmap (\\\\(f,x) -> f x) (mf \\*\\* mx)",
    "Description": "Define an operator (<\\*\\*>) that takes a Monoidal functor f (a -> b) and a Monoidal functor f a and returns a functor f b, using the fmap and (\\*\\*) functions from the Monoidal and Functor typeclasses."
  },
  {
    "Statement": "elemIndex y (x:xs)",
    "Description": "Define the recursive case of the elemIndex function where a non-empty list is given. It checks if the element 'y' is equal to the current element 'x', if so, it returns Just 0, otherwise, it recursively searches in the rest of the list."
  },
  {
    "Statement": "map :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
  },
  {
    "Statement": "maximum :: (Ord a, Foldable t) => t a -> a",
    "Description": "Define 'maximum' as a function which finds the maximum element of a non-empty list."
  },
  {
    "Statement": "add :: (Num d) => d -> d -> [d] -> [d]",
    "Description": "Declares a function add which takes three arguments of type d and returns a list of type [d]."
  },
  {
    "Statement": "maybeadd mx my = mx >>= (\\x -> my >>= (\\y -> Just $ x+y))",
    "Description": "Use nested bind operators to sequentially extract values from `mx` and `my`, adds them, and wraps the result in a Just context."
  },
  {
    "Statement": "import Data.List (nub)",
    "Description": "Import the 'nub' function from the Data.List module, which removes duplicate elements from a list."
  },
  {
    "Statement": "import Data.Char (toLower)\n\ntoLowerCase :: String -> String",
    "Description": "Define a function 'toLowerCase' that takes a string and returns a new string with all characters converted to lowercase. Import the 'toLower' function from the 'Data.Char' module."
  },
  {
    "Statement": "where",
    "Description": "Begin definition of the sizeT abbreviation."
  },
  {
    "Statement": "apply (induct t)",
    "Description": "Begin the proof by induction over tree `t`."
  },
  {
    "Statement": "apply (simp add: sorted_append)",
    "Description": "Apply the `simp` tactic with the additional information `sorted_append`."
  },
  {
    "Statement": "deriving (Eq, Ord)",
    "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'NonEmpty' data type."
  },
  {
    "Statement": "case Nil",
    "Description": "If the case is an empty list."
  },
  {
    "Statement": "instance Semigroup (All a) where",
    "Description": "Define a 'Semigroup' instance for the 'All' data type."
  },
  {
    "Statement": "class Semigroup a => Monoid a where\n  mempty :: a\n  mappend :: a -> a -> a\n  mconcat :: [a] -> a",
    "Description": "Define a class Monoid that represents types that have a Semigroup instance and an identity element mempty, with a binary operation mappend and a function mconcat that combines a list of elements using the binary operation."
  },
  {
    "Statement": "bindIOM iom f = do",
    "Description": "Begin the definition of bindIOM by using a do block."
  },
  {
    "Statement": "zip :: [a] -> [b] -> [(a, b)]",
    "Description": "Define a function named `zip` which takes two lists and returns a list of pairs."
  },
  {
    "Statement": "intersperse :: a -> [a] -> [a]",
    "Description": "Define 'intersperse' as a function which takes an element and a list, and puts the element between each pair of elements in the list."
  },
  {
    "Statement": "case maybe_val of",
    "Description": "Start a case expression on maybe_val."
  },
  {
    "Statement": "mapA :: ArrowChoice a => a a1 a2 -> a [a1] [a2]\nmapA f =\n  arr listCase >>>\n  arr (const []) ||| (f *** mapA f >>> arr (uncurry (:)))",
    "Description": "Define a function 'mapA' that takes an arrow 'f' and applies it to each element of a list. It uses the 'ArrowChoice' operations to implement map in a point-free style."
  },
  {
    "Statement": "hn = n",
    "Description": "Assign `hn` the value of `n`."
  },
  {
    "Statement": "failing :: IO ()",
    "Description": "Define a function failing of type IO () that throws an exception of type Error."
  },
  {
    "Statement": "postOrder Leaf = []",
    "Description": "If the input tree is Leaf, return an empty list."
  },
  {
    "Statement": "exitFailure :: IO a",
    "Description": "Define a function 'exitFailure' which performs an IO action that terminates the program with a failure status."
  },
  {
    "Statement": "product (x:xs) = x * product xs",
    "Description": "Define the product of a list as the first element times the product of the rest of the list."
  },
  {
    "Statement": "import qualified Prelude;",
    "Description": "Import the Prelude module qualified."
  },
  {
    "Statement": "postOrder (Node x l r) = postOrder l ++ postOrder r ++ [x]",
    "Description": "Otherwise, return the concatenation of the post-order traversal of the left subtree, the post-order traversal of the right subtree, and a singleton list containing the value at the root."
  },
  {
    "Statement": "quickSort (x:xs) = quickSort [y | y <- xs, y < x] ++ [x] ++ quickSort [y | y <- xs, y >= x]",
    "Description": "Otherwise, recursively call quickSort on the elements less than x, prepend x to the result, and append the result of recursively calling quickSort on the elements greater than or equal to x."
  },
  {
    "Statement": "con \"uppercase\" (map toUpper :: String -> String),",
    "Description": "Include the 'uppercase' function signature."
  },
  {
    "Statement": "mempty = Product 1",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Product a' as a 'Product' value wrapping the number '1'."
  },
  {
    "Statement": "fac n",
    "Description": "Define `fac` with parameter `n`."
  },
  {
    "Statement": "else return Nothing",
    "Description": "If the condition is not satisfied, return Nothing."
  },
  {
    "Statement": "where aux ending count = do",
    "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string and the current `count` as arguments."
  },
  {
    "Statement": "getName = do",
    "Description": "Begin the implementation of the getName function using the do notation."
  },
  {
    "Statement": "then returnIOM input",
    "Description": "If the input is valid, return a successful IOMaybe computation with the input String."
  },
  {
    "Statement": "newtype Last a = Last { getLast :: Maybe a }",
    "Description": "Define a new data type called 'Last' with a single constructor 'Last' that wraps a 'Maybe' value of type 'a'. The 'getLast' function extracts the 'Maybe' value of type 'a' from the 'Last' constructor."
  },
  {
    "Statement": "import Quickspec",
    "Description": "Import the Quickspec module."
  },
  {
    "Statement": "by auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "concatMap :: (a -> Seq b) -> Seq a -> Seq b",
    "Description": "Declare a function concatMap that maps a function over a sequence and concatenates the results."
  },
  {
    "Statement": "(\\x y z -> x+y+z) 1 2 3",
    "Description": "Applly the anonymous function (\\x y z -> x+y+z) to the values 1, 2, and 3, resulting in 6."
  },
  {
    "Statement": "instance Monoid (All a) where",
    "Description": "Define a 'Monoid' instance for the 'All' data type."
  },
  {
    "Statement": "(<$) :: a -> f b -> f a",
    "Description": "Declare the '(<$)' operator signature for the 'Functor' type class, which takes a value of type 'a' and a value of type 'f b', and returns a value of type 'f a'."
  },
  {
    "Statement": "takeWhile _ [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "where edges = concatMap (\\(Node _ children) -> zip (repeat n) (map nodeIndex children)) (zip nodes [0..])",
    "Description": "Define a helper function to generate the list of edges, where each node is associated with its index, and edges are created from each node to its children."
  },
  {
    "Statement": "in_range :: Integer -> Integer -> Integer -> Bool",
    "Description": "Declare a function 'in_range' that takes three Integer arguments and returns a Bool."
  },
  {
    "Statement": "Space c = f acc cs",
    "Description": "If the current character is not whitespace, 'f' recursively processes the remaining characters with the current character prepended to the accumulator."
  },
  {
    "Statement": "where aux ending count = do",
    "Description": "Declare an auxiliary function aux that takes the ending string and a count as arguments, and performs the following actions in the IO monad."
  },
  {
    "Statement": "foldl' (+) 0 [1,2,3]",
    "Description": "Perform a strict left fold using the (+) operator and initial value 0 over the list [1,2,3]."
  },
  {
    "Statement": "where types = (x :: [Int], y :: [Int])",
    "Description": "Specify the types of 'x' and 'y' as lists of integers for the 'prop' function."
  },
  {
    "Statement": "age :: Person -> Int",
    "Description": "Define a function 'age' which takes a 'Person' and returns their age."
  },
  {
    "Statement": "sortedSig :: [Sig)",
    "Description": "Define 'sortedSig' as a list of Sig."
  },
  {
    "Statement": "import Data.List (intersect)\n\ncommonElements :: Eq a => [a] -> [a] -> [a]",
    "Description": "Define a function 'commonElements' that takes two lists of elements of the same type 'a' that implements the 'Eq' typeclass, and returns a list containing the elements that are present in both input lists. "
  },
  {
    "Statement": "splitEvenOdd xs = partition even xs",
    "Description": "The implementation of 'splitEvenOdd' uses the 'partition' function to split the input list 'xs' into two lists based on the 'even' predicate, which separates the even and odd numbers."
  },
  {
    "Statement": "get :: m s",
    "Description": "Declare a function get that returns the current state inside a monadic context."
  },
  {
    "Statement": "zipWith _ _ [] = []",
    "Description": "Define the case of the zipWith function where the second list is empty, it returns an empty list."
  },
  {
    "Statement": "intersperse _ [] = []",
    "Description": "Define the base case of the intersperse function where an empty list is given, returning an empty list."
  },
  {
    "Statement": "unit :: Applicative f => f ()\n\nunit = pure ()",
    "Description": "Define a function unit that takes an Applicative functor f and returns its unit value f (), using the pure function from the Applicative typeclass."
  },
  {
    "Statement": "trim = f . f []",
    "Description": "Define 'trim' as a composition of 'f' applied to an empty list and then applied to the input string."
  },
  {
    "Statement": "return input",
    "Description": "If the guard condition is satisfied, return the `input` value as the result of the `getName` computation."
  },
  {
    "Statement": "isPrefixOf :: Eq a => [a] -> [a] -> Bool",
    "Description": "Define 'isPrefixOf' as a function which determines whether the first list is a prefix of the second list."
  },
  {
    "Statement": "merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys)",
    "Description": "If the first element of the first list is less than the first element of the second list, 'merge' prepends that element to the result of merging the remaining elements."
  },
  {
    "Statement": "mempty = Sum 0",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Sum a' as a 'Sum' value wrapping the number '0'."
  },
  {
    "Statement": "class Functor (f :: * -> *) where",
    "Description": "Define a type class 'Functor' with a kind constraint '(* -> *)' representing type constructors that take one type argument."
  },
  {
    "Statement": "instance MonadReader r m => MonadReader r (StateT s m) where\n    ask = lift ask\n    local f (StateT g) = StateT $ \\s -> local f (g s)",
    "Description": "Provide an instance of the 'MonadReader' type class for the 'StateT' monad transformer, assuming that 'm' is an instance of the 'MonadReader' type class. This instance allows for reading the environment within the 'StateT' monad transformer."
  },
  {
    "Statement": "data Tree a = Node a (Map Path (Tree a)) | Leaf",
    "Description": "Define a tree data structure 'Tree a', where each node contains a value of type 'a' and a map from paths ('Path') to subtrees ('Tree a'), or it can be a leaf node."
  },
  {
    "Statement": "data Maybe a = Nothing | just a",
    "Description": "Define a data type 'Maybe' which represents an optional value, where 'Nothing' indicates absence of a value and 'Just' wraps a value of type 'a'."
  },
  {
    "Statement": "union' :: Eq a => [a] -> [a] -> [a]",
    "Description": "Define a function union' that takes two lists xs and ys, and returns a new list containing all the elements of xs and ys with duplicates removed."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "Define the base case of the sum function where an empty list is given, it returns 0."
  },
  {
    "Statement": "data Maybe a = Nothing | Just a",
    "Description": "Define a data type Maybe a that represents an optional value, either Nothing or Just a."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "If the second list is empty, return the first list xs as the result of splicing."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Get a line of input from the user using the getLine function from the IO monad."
  },
  {
    "Statement": "(==) (C n) (C m) = n == m",
    "Description": "Define the equality operator '==' for comparing two temperatures in Celsius. It returns true if their values are equal."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "If the first list is empty, return the second list ys as the result of splicing."
  },
  {
    "Statement": "con \"takeFirst\" (take :: Int -> [a] -> [a]),",
    "Description": "Include the 'takeFirst' function signature."
  },
  {
    "Statement": "countDigits = length . filter isDigit",
    "Description": "The implementation of 'countDigits' uses function composition: first, filter the input string to retain only the digits using 'isDigit', then find the length of the resulting list."
  },
  {
    "Statement": "instance (Monoid w, Monad m) => MonadWriter w (WriterT w m) where\n    tell = WriterT . return\n    listen (WriterT m) = WriterT $ do\n        (a, w) <- m\n        return ((a, w), w)\n    pass (WriterT m) = WriterT $ do\n        ((a, f), w) <- m\n        return (a, f w)",
    "Description": "Provide an instance of the 'MonadWriter' type class for the 'WriterT' monad transformer, assuming that 'm' is an instance of the 'Monad' type class and 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value within the 'WriterT' monad transformer."
  },
  {
    "Statement": "elem' :: Eq a => a -> [a] -> Bool",
    "Description": "Define a function elem' that takes an element x and a list xs, and returns True if x is an element of xs, otherwise False."
  },
  {
    "Statement": "newtype StateT s (m :: _\\->_ ) a",
    "Description": "Declare a new type constructor StateT that takes two type parameters: s (representing the state) and m (representing a monad), and returns a new type a."
  },
  {
    "Statement": "con \"product\" (product :: [Int] -> Int),",
    "Description": "Include the 'product' function signature."
  },
  {
    "Statement": "Lemma sets value sortedT:",
    "Description": "Define a lemma named `sortedT_values`."
  },
  {
    "Statement": "Class Show a where",
    "Description": "Declare a typeclass 'Show' which represents types that can be converted to strings."
  },
  {
    "Statement": "sum = foldr (+) 0",
    "Description": "Calculate the sum of a list of numbers using a right fold (foldr) with the addition operator (+) and starting with an initial accumulator value of 0."
  },
  {
    "Statement": "zip _ _ = []",
    "Description": "Define the case of the zip function where any of the lists is empty, it returns an empty list."
  },
  {
    "Statement": "break' :: (a -> Bool) -> [a] -> ([a], [a])",
    "Description": "Define a function break' that takes a predicate p and a list xs, and returns a pair of lists, where the first list contains the longest prefix of xs that does not satisfy p, and the second list contains the remaining elements."
  },
  {
    "Statement": "any :: (a -> Bool) -> Seq a -> Bool",
    "Description": "Declare a function any that checks if any element of a sequence satisfies a predicate."
  },
  {
    "Statement": "by (metis inorder.simps (2) sorted_append)",
    "Description": "Use the given sorted lemma to solve the subgoal."
  },
  {
    "Statement": "| × < y = Z",
    "Description": "If `x * y` is less than `y`, return `Z`."
  },
  {
    "Statement": "let ncount = count + 1",
    "Description": "Calculate the new count `ncount` by incrementing the current `count` by 1."
  },
  {
    "Statement": "import Test.QuickCheck.Poly(OrdA(..))",
    "Description": "Import the OrdA class from Test.QuickCheck.Poly module."
  },
  {
    "Statement": "in_range 4 5 3",
    "Description": "Check if the value 3 is within the range [4, 5]."
  },
  {
    "Statement": "otherwise = n * fac (n-1)",
    "Description": "Otherwise, return `n * fac (n-1)`."
  },
  {
    "Statement": "(Just v) -> f v",
    "Description": "If maybe_val is Just v, apply the function f to the value v and return the resulting IOMaybe computation."
  },
  {
    "Statement": "readUntil :: String -> IO ()",
    "Description": "Declare a function named `readUntil` that takes a `String` argument and returns an `IO ()` computation, which reads input from the user until a specific ending string is entered."
  },
  {
    "Statement": "() :: a -> a -> a",
    "Description": "Define the multiplication operation '' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
  },
  {
    "Statement": "guard (checkInput input)",
    "Description": "Use the `guard` function to conditionally proceed with the computation based on the result of `checkInput input`, which presumably checks if the input satisfies some condition."
  },
  {
    "Statement": "transpose :: [[a]] -> [[a]]",
    "Description": "Define 'transpose' as a function which transposes the rows and columns of a list of lists."
  },
  {
    "Statement": "aux acc\n0] = асс",
    "Description": "If the accumulator is an empty list, return the accumulator."
  },
  {
    "Statement": "trimString = f . f",
    "Description": "Define trimString using the 'f.f' composition to remove leading and trailing whitespace."
  },
  {
    "Statement": "case (1 v)",
    "Description": "If the case is (1 v),"
  },
  {
    "Statement": "bubbleUp x [] = [x]",
    "Description": "If the accumulator is empty, return a singleton list containing x."
  },
  {
    "Statement": "intersection :: Set a -> Set a -> Set a",
    "Description": "Declare a function intersection that returns the intersection of two sets."
  },
  {
    "Statement": "Nothing -> return Nothing",
    "Description": "If maybe_val is Nothing, return Nothing."
  },
  {
    "Statement": "import qualified Lib",
    "Description": "Import the 'Lib' module qualified."
  },
  {
    "Statement": "con \"slice\" (takeWhile . dropWhile . not :: (a -> Bool) -> [a] -> [a]),",
    "Description": "Include the 'slice' function signature."
  },
  {
    "Statement": "count <- get",
    "Description": "Retrieve the current count value from the state using the `get` function."
  },
  {
    "Statement": "f X = X : X",
    "Description": "Define a function f which takes an argument X and prepends it twice to itself, which results in a type error due to infinite recursion."
  },
  {
    "Statement": "postOrder :: Tree a -> [a]",
    "Description": "Define a function named postOrder which takes a Tree of elements of type a and returns a list of the elements in post-order traversal order."
  },
  {
    "Statement": "isAll e = foldr (\\x acc -> e == x && acc) True",
    "Description": "Define 'isAll' as a fold operation that checks if all elements in the list are equal to 'e'."
  },
  {
    "Statement": "fun inorder :: \"'a Tree → 'a list\"",
    "Description": "Define a function named `inorder` which takes a `Tree 'a` and returns a list of 'a."
  },
  {
    "Statement": "lift2 :: (a -> b -> c) -> (f a -> f b -> f c)",
    "Description": "Declare the 'lift2' function signature, which takes a binary function '(a -> b -> c)' and returns a function that lifts the binary function to operate on values of types 'f a' and 'f b', returning a value of type 'f c'."
  },
  {
    "Statement": "capitalize (x:xs) = toUpper x : xs",
    "Description": "For a non-empty string, 'capitalize' converts the first character to uppercase and concatenates it with the remaining characters."
  },
  {
    "Statement": "if input == ending then",
    "Description": "Check if the input string is equal to the ending string."
  },
  {
    "Statement": "con \"logicalOr\" ((||) :: Bool -> Bool -> Bool),",
    "Description": "Include the 'logicalOr' function signature."
  },
  {
    "Statement": "class Functor (f :: * -> *) where",
    "Description": "Define a type class 'Functor' with a kind constraint '(* -> *)' representing type constructors that take one type argument."
  },
  {
    "Statement": "    | otherwise = deleteFirstsBy eq (deleteBy eq y xs) ys",
    "Description": "Define the condition for the recursive case of the deleteFirstsBy function. It removes the first occurrence of the current element 'y' from the first list using the predicate 'eq', and then recursively processes the rest of the second list."
  },
  {
    "Statement": "nat = asc 1\n where asc n = n: (asc $ n+1)",
    "Description": "Define an infinite list named nat where each element is an ascending sequence starting from 1."
  },
  {
    "Statement": "| n == 0      =1",
    "Description": "If `n` is equal to 0, return 1."
  },
  {
    "Statement": "readUntilWithCount ending = aux ending 0",
    "Description": "Define the `readUntilWithCount` function by calling an auxiliary function `aux` with the `ending` string and an initial count of `0`."
  },
  {
    "Statement": "(Just v) -> f v",
    "Description": "If maybe_val is Just v, apply the function f to the value v and return the resulting IOMaybe computation."
  },
  {
    "Statement": "instance Monad Maybe",
    "Description": "Create an instance of the Monad typeclass for the Maybe data type, which represents computations that can either succeed with a value of type a or fail without a value."
  },
  {
    "Statement": "takeWhile' :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function takeWhile' that takes a predicate p and a list xs, and returns the longest prefix of xs that satisfies p."
  },
  {
    "Statement": "| × < y = Z",
    "Description": "If `x * y` is less than `y`, return `Z`."
  },
  {
    "Statement": "                  Nothing -> []",
    "Description": "Define the 'unfoldr' function. If the result of 'f' is Nothing, it terminates the list."
  },
  {
    "Statement": "preOrder (Node x l r) = [x] ++ preOrder l ++ preOrder r",
    "Description": "Otherwise, return the concatenation of a singleton list containing the value at the root, the pre-order traversal of the left subtree, and the pre-order traversal of the right subtree."
  },
  {
    "Statement": "tail :: [a] -> [a]",
    "Description": "Return all elements of a list except the first one."
  },
  {
    "Statement": "sort :: Ord a => Seq a -> Seq a",
    "Description": "Declare a function sort that sorts the elements of a sequence."
  },
  {
    "Statement": "\"sizeT r < sizeT (Node l v r)\"",
    "Description": "Assume that the size of r is less than the size of the node."
  },
  {
    "Statement": "insertionSort (x:xs) = insert x (insertionSort xs)",
    "Description": "Otherwise, recursively call insertionSort with the tail of the list and insert the head of the list into the sorted result."
  },
  {
    "Statement": "words :: String -> [String]",
    "Description": "Define a function 'words' that takes a string and returns a list of words in the string."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
  },
  {
    "Statement": "| × < y = Z",
    "Description": "If `x * y` is less than `y`, return `Z`."
  },
  {
    "Statement": "  (>>) :: m a -> m b -> m b",
    "Description": "Define the sequencing operator (>>), which discards the result of the first action and executes the second action."
  },
  {
    "Statement": "runStateT :: StateT s m a -> s -> m (a, s)",
    "Description": "Declare a function `runStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning the result value `a` and the final state `s`."
  },
  {
    "Statement": "postOrder (Node x l r) = postOrder l ++ postOrder r ++ [x]",
    "Description": "Otherwise, return the concatenation of the post-order traversal of the left subtree, the post-order traversal of the right subtree, and a singleton list containing the value at the root."
  },
  {
    "Statement": "isEven :: Int -> Bool",
    "Description": "Define a function named `isEven` which takes an `Int` and returns a `Bool`."
  },
  {
    "Statement": "concat' = foldl' (++) []",
    "Description": "The implementation of 'concat'' uses 'foldl'' to fold the input list of lists using the '++' operator (list concatenation) and an initial accumulator value of an empty list '[]'."
  },
  {
    "Statement": "sum (x: xs) = x + sum xs",
    "Description": "Sum the first element x with the sum of the remaining elements xs recursively."
  },
  {
    "Statement": "treesig2 = [",
    "Description": "Assign the following list of Sig to 'treesig2'."
  },
  {
    "Statement": "instance Monoid w => MonadTrans (WriterT w) where\n    lift m = WriterT $ do\n        a <- m\n        return (a, mempty)",
    "Description": "Provide an instance of the 'MonadTrans' type class for the 'WriterT' monad transformer, assuming that 'w' is an instance of the 'Monoid' type class. This instance allows for lifting computations into the 'WriterT' monad transformer."
  },
  {
    "Statement": "(<>) = coerce ((+) :: a -> a -> a)",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Sum a' by converting the '(+)' function for type 'a' to the appropriate type using 'coerce'."
  },
  {
    "Statement": "case (Cons x xs)",
    "Description": "If the case is a non-empty list."
  },
  {
    "Statement": "bubbleSort :: Ord a => [a] -> [a]",
    "Description": "Define a function named bubbleSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "length [] = 0",
    "Description": "Define the length of an empty list as 0."
  },
  {
    "Statement": "import Data.List (foldl')\n\ntake' :: Int -> [a] -> [a]",
    "Description": "Define a function 'take'' that takes an integer 'n' and a list of elements of any type 'a', and returns a list containing the first 'n' elements of the input list. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
    "Description": "Define a function bindIOM that takes an IOMaybe computation and a function that takes a value of type a and returns an IOMaybe computation of type b, and returns a new IOMaybe computation of type b that combines the two computations."
  },
  {
    "Statement": "import Module as NewName",
    "Description": "Imports all entities from the module 'Module' into the current namespace but renames the module to 'NewName', allowing access to its entities using the new name."
  },
  {
    "Statement": "unfoldr :: (b -> Maybe (a, b)) -> b -> [a]",
    "Description": "Define 'unfoldr' as a function which builds a list from a seed value, using a function to generate the next element and a termination condition."
  },
  {
    "Statement": "type Path = [B.ByteString]",
    "Description": "Define a type alias 'Path' as a list of 'ByteString' values."
  },
  {
    "Statement": "(==) (C c) (F f) = (1.8c + 32) == f",
    "Description": "Define the equality operator '==' for comparing a temperature in Celsius with a temperature in Fahrenheit. It returns true if the Celsius temperature, when converted to Fahrenheit, is equal to the given Fahrenheit temperature."
  },
  {
    "Statement": "z = 3.1415",
    "Description": "Assign the value 3.1415 to the variable 'z'."
  },
  {
    "Statement": "bubbleUp x (y:ys) | x > y = y : bubbleUp x ys",
    "Description": "If x is greater than the head of the accumulator, prepend the head to the result of recursively calling bubbleUp with x and the tail of the accumulator."
  },
  {
    "Statement": "import Data.List (foldl')\n\nsumInts :: [Int] -> Int",
    "Description": "Define a function 'sumInts' that takes a list of integers and returns their sum. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
    "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
  },
  {
    "Statement": "findIndex :: Eq a => a -> [a] -> Maybe Int",
    "Description": "Define a function 'findIndex' that takes an element of type 'a' (which must be an instance of the 'Eq' typeclass) and a list of elements of type 'a', and returns the index of the first occurrence of the element in the list wrapped in a 'Maybe' value, or 'Nothing' if the element is not found."
  },
  {
    "Statement": "hn = n",
    "Description": "Assign `hn` the value of `n`."
  },
  {
    "Statement": "fromList :: Ord a => [a] -> Seq a",
    "Description": "Declare a function fromList that takes a list and returns a sequence."
  },
  {
    "Statement": "add :: Int -> Int -> Int",
    "Description": "Define a function 'add' which takes two 'Int' arguments and returns an 'Int'."
  },
  {
    "Statement": "import Data.List (inits)\n\nprefixes :: [a] -> [[a]]",
    "Description": "Define a function 'prefixes' that takes a list of elements of any type 'a' and returns a list of all prefixes (initial segments) of the input list, including the empty list and the input list itself. Import the 'inits' function from the 'Data.List' module."
  },
  {
    "Statement": "elemIndex _ [] = Nothing",
    "Description": "Define the case of the elemIndex function where an empty list is given, it returns Nothing."
  },
  {
    "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
    "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
  },
  {
    "Statement": "newtype Dual a = Dual { getDual :: a }",
    "Description": "Define a new data type called 'Dual' with a single constructor 'Dual' that wraps a value of type 'a'. The 'getDual' function extracts the value of type 'a' from the 'Dual' constructor."
  },
  {
    "Statement": "removeNothings = catMaybes",
    "Description": "The implementation of 'removeNothings' simply applies the 'catMaybes' function to the input list of 'Maybe' values."
  },
  {
    "Statement": "    | y == x = Just v",
    "Description": "Define the condition for the recursive case of the lookup function. If the key 'y' is found, it returns the associated value 'v'."
  },
  {
    "Statement": "elem :: Eq a => a -> [a] -> Bool",
    "Description": "Define a function named `elem` which takes an element of type `a` and a list of type `[a]` and returns a `Bool`."
  },
  {
    "Statement": "return xs'",
    "Description": "Return the shuffled string."
  },
  {
    "Statement": "\"sortedT t = sorted (inorder t)\"",
    "Description": "Define `sortedT` as a function that checks if the tree is sorted by using the inorder traversal."
  },
  {
    "Statement": "deleteBy _ _ [] = []",
    "Description": "Define the case of the deleteBy function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "module DataStructures",
    "Description": "Define a module named DataStructures."
  },
  {
    "Statement": "quicksort :: Ord a => [a] -> [a]",
    "Description": "Define a function named `quicksort` which takes a list of type `[a]` and returns a sorted list of the same type."
  },
  {
    "Statement": "withArgs args action = System.Environment.withArgs args action",
    "Description": "Implement the 'withArgs' function using 'System.Environment.withArgs'."
  },
  {
    "Statement": "proof (induction xs arbitrary: P)",
    "Description": "Apply induction on the list with an arbitrary predicate `P`."
  },
  {
    "Statement": "fibonacci n = fibonacci (n-1) + fibonacci (n-2)",
    "Description": "The nth Fibonacci number is the sum of the (n-1)th and (n-2)th Fibonacci numbers."
  },
  {
    "Statement": "otherwise = n * fac (n-1)",
    "Description": "Otherwise, return `n * fac (n-1)`."
  },
  {
    "Statement": "instance Monad ((->) r)",
    "Description": "Create an instance of the Monad typeclass for the function type constructor (->) r, which represents computations that take a value of type r as input and return a value of type a."
  },
  {
    "Statement": "let ncount = count + 1",
    "Description": "Calculate the new count `ncount` by incrementing the current `count` by 1."
  },
  {
    "Statement": "main :: IO ()",
    "Description": "Define the 'main' function."
  },
  {
    "Statement": "getName :: IOMaybe String",
    "Description": "Define a function getName that represents an IOMaybe computation that can get a valid name from the user."
  },
  {
    "Statement": "takeWhile p (x:xs)",
    "Description": "Define the recursive case of the takeWhile function where a non-empty list is given. It takes elements from the list while the predicate 'p' holds true."
  },
  {
    "Statement": "instance Monad Maybe where",
    "Description": "Define an instance of the Monad typeclass for the Maybe data type."
  },
  {
    "Statement": "\"∀t1 t2. sortedT t1 ⟶ sortedT t2 ⟶ t1 ⊆ t2 ⟶ sortedT t1\"",
    "Description": "For all trees t1 and t2, if t1 and t2 are sorted and t1 is a subset of t2, then t1 is also sorted."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "If the first list is empty, return the second list ys as the result of splicing."
  },
  {
    "Statement": "maybe_val <- iom",
    "Description": "Bind the result of evaluating iom to maybe_val."
  },
  {
    "Statement": "minimum :: Ord a => Seq a -> a",
    "Description": "Declare a function minimum that returns the minimum element of a sequence."
  },
  {
    "Statement": "import Data.List (elemIndex)",
    "Description": "Import the 'elemIndex' function from the Data.List module, which returns the index of the first occurrence of an element in a list, or 'Nothing' if the element is not found."
  },
  {
    "Statement": "case (1 v)",
    "Description": "If the case is (1 v),"
  },
  {
    "Statement": "import Data.List (sort)",
    "Description": "Import the 'sort' function from the Data.List module."
  },
  {
    "Statement": "instance Semigroup (Either a b)",
    "Description": "Provide an instance of Semigroup for the Either data type, where the (<>) operation is defined to prefer the Right value if both inputs are Right, and otherwise return the non-Right value."
  },
  {
    "Statement": "if input == ending then",
    "Description": "Check if the input string is equal to the ending string."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "type IOMaybe a = IO (Maybe a)",
    "Description": "Define a new type synonym IOMaybe a that represents a computation that can perform side effects and either succeed with a value of type a or fail without a value."
  },
  {
    "Statement": "import Data.List (foldl')\n\nconcat' :: [[a]] -> [a]",
    "Description": "Define a function 'concat'' that takes a list of lists of elements of any type 'a' and returns a single list containing all the elements concatenated. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "instance MonadTrans (StateT s) where\n    lift m = StateT $ \\s -> do\n        a <- m\n        return (a, s)",
    "Description": "Provide an instance of the 'MonadTrans' type class for the 'StateT' monad transformer. This instance allows for lifting computations into the 'StateT' monad transformer."
  },
  {
    "Statement": "cross :: a -> b -> (a,b)",
    "Description": "Define the 'cross' function that takes two values 'a' and 'b', and returns a tuple '(a,b)' containing them."
  },
  {
    "Statement": "splice [] [] = []",
    "Description": "The base case for splicing two empty lists, which returns an empty list."
  },
  {
    "Statement": "apply (rule exI[where x=Leaf])",
    "Description": "Apply the rule exI to instantiate the existential quantifier."
  },
  {
    "Statement": "mempty = Dual mempty",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Dual a' as a 'Dual' value wrapping the 'mempty' value of the inner type 'a'."
  },
  {
    "Statement": "maybe_val <- iom",
    "Description": "Bind the result of the first IOMaybe computation iom to the variable maybe_val."
  },
  {
    "Statement": "preOrder :: Tree a -> [a]",
    "Description": "Define a function named preOrder which takes a Tree of elements of type a and returns a list of the elements in pre-order traversal order."
  },
  {
    "Statement": "startsWith xs ys = isPrefixOf xs ys",
    "Description": "The implementation of 'startsWith' simply applies the 'isPrefixOf' function to the two input lists 'xs' and 'ys'."
  },
  {
    "Statement": "instance Monoid (Last a) where",
    "Description": "Define a 'Monoid' instance for the 'Last' data type."
  },
  {
    "Statement": "ilb = min <= x",
    "Description": "Check if 'x' is greater than or equal to 'min' and assign the result to 'ilb'."
  },
  {
    "Statement": "(==)  _ _ = False",
    "Description": "Define a catch-all case for the equality operator '==' which returns false for any other combination of temperatures."
  },
  {
    "Statement": "minimum = foldl1 min",
    "Description": "Define 'minimum' as a function which finds the minimum element of a non-empty list using the 'min' function."
  },
  {
    "Statement": "filter (\\x -> x>2) [1,2,3,4,5]",
    "Description": "Filter the list [1,2,3,4,5] using the predicate function (\\x -> x>2), resulting in [3,4,5]."
  },
  {
    "Statement": "map f (x:xs) = f x : map f xs",
    "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
  },
  {
    "Statement": "inOrder Leaf = []",
    "Description": "If the input tree is Leaf, return an empty list."
  },
  {
    "Statement": "instance Monad (Either e)",
    "Description": "Define a Monad instance for the Either type constructor."
  },
  {
    "Statement": "(Just x) >>= f = f x",
    "Description": "If the input to the bind operation is Just x, apply the function f to x and return the result."
  },
  {
    "Statement": "(<>) = coerce ((||) :: a -> a -> a)",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Any a' by converting the '(||)' function for type 'a' to the appropriate type using 'coerce'."
  },
  {
    "Statement": "concatMapSig :: [Sig]",
    "Description": "Define 'concatMapSig' as a list of Sig."
  },
  {
    "Statement": "returnIOM :: a -> IOMaybe a",
    "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
  },
  {
    "Statement": "fromleft :: a -> Either a b -> a",
    "Description": "Define a function 'fromleft' that extracts the value from a 'Left' constructor or returns a default value."
  },
  {
    "Statement": "insert:: forall a. (Linorder a) => a -> Tree a -> Tree a;",
    "Description": "Define a function 'insert' which takes an element of type 'a' and a 'Tree a' and returns a 'Tree a'."
  },
  {
    "Statement": "readUntilWithState :: String -> IO Int",
    "Description": "Declare a function named `readUntilWithState` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read, using the `StateT` monad transformer."
  },
  {
    "Statement": "getLine :: IO String",
    "Description": "Define an IO action 'getLine' that reads a line of input from the user and returns it as a String."
  },
  {
    "Statement": "func x = if x == 0 then ( else f (x-1))",
    "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
  },
  {
    "Statement": "iub = max >= x",
    "Description": "Check if 'x' is less than or equal to 'max' and assign the result to 'iub'."
  },
  {
    "Statement": "uncapitalize [] = []",
    "Description": "If the input string is empty, return an empty string."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Get a line of input from the user using the getLine function from the IO monad."
  },
  {
    "Statement": "imports Main",
    "Description": "Import `Main` module."
  },
  {
    "Statement": "insert y (x:xs)",
    "Description": "Define the recursive case of the insert function where a non-empty list is given. It inserts the element 'y' into the sorted list."
  },
  {
    "Statement": "fac n",
    "Description": "Define `fac` with parameter `n`."
  },
  {
    "Statement": "have sorted_right: \"sortedT r\" using 2 sorted node by blast",
    "Description": "declare that 'r' is sorted."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "liftIOm :: IO a -> IOMaybe a",
    "Description": "Define a function liftIOm that takes an IO a and returns an IOMaybe a."
  },
  {
    "Statement": "append :: List a -> List a -> List a",
    "Description": "Define a function named append which takes two Lists of elements of type a and returns their concatenation as a List of the same type."
  },
  {
    "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
    "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
  },
  {
    "Statement": "con \"isPrime\" (isPrime :: Int -> Bool),",
    "Description": "Include the 'isPrime' function signature."
  },
  {
    "Statement": "rev\n[] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "module Main where",
    "Description": "Define the module 'Main'."
  },
  {
    "Statement": "filterJust f = mapMaybe f",
    "Description": "The implementation of 'filterJust' simply applies the 'mapMaybe' function to the input function 'f' and the input list."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user and bind it to input."
  },
  {
    "Statement": "foldl1' :: (a -> a -> a) -> Seq a -> a",
    "Description": "Declare a function foldl1' that folds a non-empty sequence strictly from the left with a binary function."
  },
  {
    "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
    "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
  },
  {
    "Statement": "predicate \"sorted\" (sorted :: [OrdA] -> Bool)",
    "Description": "Include the 'sorted' predicate signature in 'treesig2'."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user and bind it to input."
  },
  {
    "Statement": "con \"fromList\" (fromList :: [Orda] -› Tree Ord),",
    "Description": "Include the 'fromList' function signature in 'treeSig1'."
  },
  {
    "Statement": "merge (x:xs) (y:ys) = y : merge (x:xs) ys",
    "Description": "If the first element of the second list is less than or equal to the first element of the first list, 'merge' prepends that element to the result of merging the remaining elements."
  },
  {
    "Statement": "prop xs = not (null xs) ==> (length xs) -1)",
    "Description": "Define a property named prop that states if xs is not null, then the length of xs minus one is equal to itself."
  },
  {
    "Statement": "reverse :: [a] -> [a]",
    "Description": "Define a function named `reverse` which takes a list of any type and returns a list of the same type."
  },
  {
    "Statement": "length xs =? = foldr (const (+1)) 0 xs",
    "Description": "State that the length of a list xs can be computed using the foldr function, applying the const (+1) function to each element and starting with an initial value of 0."
  },
  {
    "Statement": "map' f = foldl' (\\acc x -> acc ++ [f x]) []",
    "Description": "The implementation of 'map'' uses 'foldl'' to fold the input list using an anonymous function that appends the result of applying 'f' to the current element 'x' to the accumulator 'acc'. The initial accumulator is an empty list '[]'."
  },
  {
    "Statement": "  fail :: String -> m a",
    "Description": "Handle failure within a monadic computation."
  },
  {
    "Statement": "minimum' :: Ord a => [a] -> a",
    "Description": "Define a function minimum' that takes a non-empty list xs and returns the minimum element of xs."
  },
  {
    "Statement": "minimum [x] = x",
    "Description": "If the list has only one element, return that element."
  },
  {
    "Statement": "exitSuccess :: IO a",
    "Description": "Define a function 'exitSuccess' which performs an IO action that terminates the program with a success status."
  },
  {
    "Statement": "die msg = do { putStrLn msg; exitFailure }",
    "Description": "Implement the 'die' function to print the error message followed by exiting with failure status."
  },
  {
    "Statement": "import Data.List (transpose)\n\ntransposeMatrix :: [[a]] -> [[a]]",
    "Description": "Define a function 'transposeMatrix' that takes a matrix represented as a list of lists and returns its transpose. Import the 'transpose' function from the 'Data.List' module."
  },
  {
    "Statement": "instance Monoid [a] where\n  mempty = []\n  mconcat xss = [x | xs <- xss, x <- xs]",
    "Description": "Provide an instance of Monoid for lists, where mempty is the empty list, and mconcat concatenates a list of lists by flattening them into a single list."
  },
  {
    "Statement": "instance MonadState s m => MonadState s (ReaderT r m) where\n    get = lift get\n    put = lift . put",
    "Description": "Provide an instance of the 'MonadState' type class for the 'ReaderT' monad transformer, assuming that 'm' is an instance of the 'MonadState' type class. This instance allows for working with state within the 'ReaderT' monad transformer."
  },
  {
    "Statement": "getInput = do",
    "Description": "Begin the definition of getInput by using a do block."
  },
  {
    "Statement": "ones = 1 : ones\ntail ones\n==> 1 : ones ",
    "Description": "Define an infinite list named ones where each element is 1 followed by itself. Then, take the tail of the list ones, resulting in a list with all elements same as ones except the first one."
  },
  {
    "Statement": "| otherwise = []",
    "Description": "Otherwise, stop taking elements."
  },
  {
    "Statement": "sum (splice xs ys) =?= sum xs + sum ys",
    "Description": "Verify whether the sum of splicing two lists xs and ys is equal to the sum of the individual lists xs and ys."
  },
  {
    "Statement": "instance Applicative [] where\n    pure x = [x]\n    fs <*> xs = [f x | f <- fs, x <- xs]\n    _ *> ys = ys\n    xs <* _ = xs",
    "Description": "Provide an instance of the 'Applicative' type class for the list data type '[]'. This instance allows for applying and combining list computations."
  },
  {
    "Statement": "apply (induction t1)",
    "Description": "Begin the proof by induction over tree t1."
  },
  {
    "Statement": "(<>) _ (Last (Just y)) = Last (Just y)",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Last a' to prioritize the last non-Nothing value."
  },
  {
    "Statement": "transpose xss = map head xss : transpose (map tail xss)",
    "Description": "Define the recursive case of the transpose function where a non-empty list of lists is given. It transposes the rows and columns of the list."
  },
  {
    "Statement": "count e = foldr (\\x acc -> if e == x then acc+1 else acc) 0",
    "Description": "Define 'count' as a fold operation that counts occurrences of 'e' in a list."
  },
  {
    "Statement": "by auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "case (1 v)",
    "Description": "If the case is (1 v),"
  },
  {
    "Statement": "import System.Environment",
    "Description": "Import the System.Environment module to access environment-related functions."
  },
  {
    "Statement": "dropWhile _ [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "prop x y = (( x <> y) <> mempty) === (x <> (y <> mempty))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Product a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
  },
  {
    "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Any a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
  },
  {
    "Statement": "app (\\x -> x+1) 1",
    "Description": "Applly the anonymous function (\\x -> x+1) to the value 1 using the 'app' function, resulting in 2."
  },
  {
    "Statement": "if input == ending then return ncount else aux ending ncount",
    "Description": "Check if the input is equal to the `ending` string. If so, return the current `ncount` value. Otherwise, recursively call `aux` with the same `ending` string and the updated `ncount` value."
  },
  {
    "Statement": "\"sortedT t ⟶ sorted (inorder t)\"",
    "Description": "If the tree t is sorted, then the inorder traversal of t is also sorted."
  },
  {
    "Statement": "import Control.Exception",
    "Description": "Import the Control.Exception module."
  },
  {
    "Statement": "drop :: Int -> Seq a -> Seq a",
    "Description": "Declare a function drop that removes the specified number of elements from the beginning of a sequence."
  },
  {
    "Statement": "readUntilWithState ending = execStateT (aux ending) 0",
    "Description": "Define the `readUntilWithState` function by executing the `aux` computation within the `StateT` monad transformer, using `execStateT` to discard the result value and return the final state (the count)."
  },
  {
    "Statement": "case maybe_val of",
    "Description": "Start a case expression on maybe_val."
  },
  {
    "Statement": "where",
    "Description": "Begin the definition of the `contains` abbreviation."
  },
  {
    "Statement": "type State s = StateT s Identity",
    "Description": "Declare a type alias State s, which is equivalent to StateT s Identity, representing a state monad transformer with the Identity monad."
  },
  {
    "Statement": "quicksort (x:xs) = quicksort [y | y <- xs, y <= x] ++ [x] ++ quicksort [y | y <- xs, y > x]",
    "Description": "Otherwise, sort the list using the quicksort algorithm."
  },
  {
    "Statement": "liftIOm :: IO a -> IOMaybe a",
    "Description": "Define a function liftIOm that takes an IO a and returns an IOMaybe a."
  },
  {
    "Statement": "if input == ending then return () else readUntil ending",
    "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `readUntil` with the same `ending` string."
  },
  {
    "Statement": "f :: Int -> Int -> Int\nf x y = y + square x",
    "Description": "Define a function f that takes two integers x and y, computes the square of x using the square function, and returns the sum of y and the square of x."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "Define the splice function for an empty list and a non-empty list ys to return the list ys."
  },
  {
    "Statement": "checkInput :: String -> Bool",
    "Description": "Define a function checkInput that takes a String and returns a Bool indicating whether the input is valid or not."
  },
  {
    "Statement": "sorted (x:y:xs) = x <= y 8& sorted (y:xs)",
    "Description": "If the first element is less than or equal to the second element and the rest of the list is sorted, return True."
  },
  {
    "Statement": "Nothing >>= _ = Nothing",
    "Description": "If the input to the bind operation is Nothing, return Nothing."
  },
  {
    "Statement": "data Calculation = Add Int Int | Sub Int Int | Mul Int Int | Div Int Int",
    "Description": "Define a datatype 'Calculation' with constructors 'Add', 'Sub', 'Mul', and 'Div', each taking two 'Int' arguments."
  },
  {
    "Statement": "apply (induct t)",
    "Description": "Begin the proof by induction over tree t."
  },
  {
    "Statement": "splice [] [] = []",
    "Description": "The base case for splicing two empty lists, which returns an empty list."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "if checkInput input",
    "Description": "Check if the input is valid using the checkInput function."
  },
  {
    "Statement": "instance Monad IO",
    "Description": "Create an instance of the Monad typeclass for the IO data type, which represents computations that can perform side effects."
  },
  {
    "Statement": "example = runMaybeT $ do",
    "Description": "Define a value `example` by running a `MaybeT` computation using `runMaybeT`."
  },
  {
    "Statement": "(Just v) -> f v",
    "Description": "If maybe_val is Just v, apply the function f to v and return the result."
  },
  {
    "Statement": "import Data.Either",
    "Description": "Imports the 'Data.Either' module."
  },
  {
    "Statement": "func :: Int -> Int",
    "Description": "Define a function named `func` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "suffixes = tails",
    "Description": "The implementation of 'suffixes' simply applies the 'tails' function to the input list."
  },
  {
    "Statement": "type IOMaybe a = IO (Maybe a)",
    "Description": "Define a new type synonym IOMaybe a that represents a computation that can perform side effects and either succeed with a value of type a or fail without a value."
  },
  {
    "Statement": "inorder (Node l v f) = (inorder l) @ [v] @ (inorder r)",
    "Description": "Otherwise, return the list obtained by concatenating the inorder traversal of the left branch, `v`, and the inorder traversal of the right branch."
  },
  {
    "Statement": "con \"lengthList\" (length :: [a] -> Int),",
    "Description": "Include the 'lengthList' function signature."
  },
  {
    "Statement": "\"[]\" ([] :: [A])",
    "Description": "Declare the constant '[]' as an empty list."
  },
  {
    "Statement": "preOrder Leaf = []",
    "Description": "If the input tree is Leaf, return an empty list."
  },
  {
    "Statement": "fun fromList (x#xs) = insert x (fromList xs)",
    "Description": "Otherwise, insert each element of the list into the tree."
  },
  {
    "Statement": "lefts :: [Either a b] -> [a]",
    "Description": "Define a function 'lefts' that takes a list of 'Either' values and returns a list containing only the 'Left' values."
  },
  {
    "Statement": "apply (auto)",
    "Description": "Use the `auto` tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "height :: Tree a -> Int",
    "Description": "Define a function named height which takes a Tree of elements of type a and returns the height of the tree as an Int."
  },
  {
    "Statement": "name arg1 arg2 ... argn = \"<expr>",
    "Description": "Define a function named 'name' with 'n' arguments 'arg1' to 'argn' that evaluates to the expression '<expr>'."
  },
  {
    "Statement": "main :: 10 ()",
    "Description": "Define the 'main' function."
  },
  {
    "Statement": "case maybe_val of",
    "Description": "Begin a case expression to handle the two possible cases of maybe_val: Nothing or Just v."
  },
  {
    "Statement": "fromList [] = Leaf;",
    "Description": "If the list is empty, return a 'Leaf'."
  },
  {
    "Statement": "insert :: Ord a => a -> [a] -> [a]",
    "Description": "Define 'insert' as a function which inserts an element into a sorted list, keeping it sorted."
  },
  {
    "Statement": "case maybe_val of",
    "Description": "Start a case expression on maybe_val."
  },
  {
    "Statement": "sum (x:xs) = x + sum xs",
    "Description": "Recursive case: If the list is not empty, sum the head of the list 'x' with the sum of the rest of the list 'xs'."
  },
  {
    "Statement": "runStateT :: StateT s m a -> s -> m (a, s)",
    "Description": "Declare a function `runStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning the result value `a` and the final state `s`."
  },
  {
    "Statement": "name <args> = ... name <args'> ...",
    "Description": "Define a recursive function named 'name' that takes arguments '<args>' and recurses on itself with arguments '<args>'."
  },
  {
    "Statement": "type SomeData = Either Int String,[Left 1, Right \"Hello\"] :: [SomeData]",
    "Description": "Define a type synonym 'SomeData' for 'Either Int String', and creates a list containing a 'Left' value with 1 and a 'Right' value with 'Hello'."
  },
  {
    "Statement": "instance Monad [] where\n    return x = [x]\n    xs >>= f = concat (map f xs)\n    (>>) = (*>)",
    "Description": "Provide an instance of the 'Monad' type class for the list data type '[]'. This instance allows for sequencing and combining list computations."
  },
  {
    "Statement": "lemma contains_take: \"contains P (take n xs) ⟶ contains P xs\"",
    "Description": "Define a lemma asserting that if `P` holds for an element in the taken list, then `P` holds for that element in the original list."
  },
  {
    "Statement": "case Nil",
    "Description": "If the case is an empty list."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "If the second list is empty, return the first list xs as the result of splicing."
  },
  {
    "Statement": "case Nil",
    "Description": "If the case is an empty list."
  },
  {
    "Statement": "splice [] [] = []",
    "Description": "The base case for splicing two empty lists, which returns an empty list."
  },
  {
    "Statement": "listCase :: [a] -> Either () (a, [a])\nlistCase [] = Left ()\nlistCase (x:xs) = Right (x, xs)",
    "Description": "Define a function 'listCase' that takes a list and returns either an empty tuple '()' (for the empty list) or a pair containing the head and tail of the list."
  },
  {
    "Statement": "add x y = x+y",
    "Description": "Define the 'add' function such that it takes two arguments 'x' and 'y', then returns their sum."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
  },
  {
    "Statement": "liftIOm io :: io >>= returnIOM",
    "Description": "Implement the liftIOm function by binding the result of the IO computation io to the returnIOM function, which wraps the value in a successful IOMaybe computation."
  },
  {
    "Statement": "    where (xs, ys) = unzip xys",
    "Description": "Define the recursive case of the unzip function. It separates the rest of the list of pairs into the first and second components of the resulting pair."
  },
  {
    "Statement": "import Data.List (tails)\n\nsuffixes :: [a] -> [[a]]",
    "Description": "Define a function 'suffixes' that takes a list of elements of any type 'a' and returns a list of all suffixes (remaining segments) of the input list, including the empty list and the input list itself. Import the 'tails' function from the 'Data.List' module."
  },
  {
    "Statement": "(+) :: a -> a -> a",
    "Description": "Define the addition operation '+' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
  },
  {
    "Statement": "foldr1 :: (a -> a -> a) -> [a] -> a",
    "Description": "Define 'foldr1' as a function which takes a binary function and a list, and applies the function in a right-associative manner to the elements of the list, assuming that the list is non-empty."
  },
  {
    "Statement": "where\n  arr :: (b -> c) -> a b c\n  first :: a b c -> a (b, d) (c, d)\n  second :: a b c -> a (d, b) (d,c)\n  (***) :: a b c -> a b' c' -> a (b, b') (c, c')\n  (&&&) :: a b c -> a b c' -> a b (c, c')",
    "Description": "Specify the methods that instances of the 'Arrow' type class must implement: 'arr' lifts a function to an arrow; 'first' and 'second' apply an arrow to the first or second component of a pair; '***' combines two arrows in parallel; '&&&' combines two arrows in parallel, keeping the input shared."
  },
  {
    "Statement": "return x;",
    "Description": "Return the value of 'x' if 'z' is true."
  },
  {
    "Statement": "union :: Set a -> Set a -> Set a",
    "Description": "Declare a function union that combines two sets."
  },
  {
    "Statement": "(>>=) x f = join (map f x)\n\n(>>) m k = m >>= (\\\\_ -> k)\n\nreturn x = unit x",
    "Description": "Define the member functions of the Monad typeclass: (>>=) is defined in terms of join and map, (>>) is defined using (>>=) and an anonymous function, and return is defined as unit."
  },
  {
    "Statement": "fun fromList [] = Leaf",
    "Description": "If the list is empty, return an empty tree."
  },
  {
    "Statement": "exitWith code = System.Exit.exitWith code",
    "Description": "Implement the 'exitWith' function using 'System.Exit.exitWith'."
  },
  {
    "Statement": "and = foldr (&&) True",
    "Description": "Define 'and' as a fold operation using the '&&' operator and starting with an initial accumulator of 'True'."
  },
  {
    "Statement": "    | otherwise = x : insert y xs",
    "Description": "Define the condition for the recursive case of the insert function. If the element 'y' is greater than the current element 'x', it keeps 'x' and recursively inserts 'y' into the rest of the list."
  },
  {
    "Statement": "class Arrow a => ArrowApply (a :: _->_ -> *)\n  where\n    app :: a (a b c, b) c",
    "Description": "Define a type class 'ArrowApply' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowApply' class specifies a single method 'app' for applying an arrow to its input."
  },
  {
    "Statement": "]",
    "Description": "End the list definition."
  },
  {
    "Statement": "\"(Vrv e setT r. rv > v)\"",
    "Description": "Assume that for every `rv` in the set of `r`, `rv` is greater than `v`."
  },
  {
    "Statement": "guard :: Alternative f => Bool -> f ()\nguard True  = pure ()\nguard False = empty",
    "Description": "Define a function 'guard' that takes a boolean value and returns an empty structure if the value is false, otherwise returns a structure containing a unit value, using the 'Alternative' operations."
  },
  {
    "Statement": "capitalize [] = []",
    "Description": "For an empty string, 'capitalize' returns an empty string."
  },
  {
    "Statement": "con \"gcd\" (gcd :: Int -> Int -> Int),",
    "Description": "Include the 'gcd' function signature."
  },
  {
    "Statement": "readUntilWithState ending = execStateT (aux ending) 0",
    "Description": "Define the `readUntilWithState` function by executing the `aux` computation within the `StateT` monad transformer, using `execStateT` to discard the result value and return the final state (the count)."
  },
  {
    "Statement": "    | p x = x : takeWhile p xs",
    "Description": "Define the condition for the recursive case of the takeWhile function. If the predicate 'p' holds true for the current element 'x', it adds 'x' to the result."
  },
  {
    "Statement": "\"sortedT t At = (Node l v r) → sortedT 1 A sortedT r\"",
    "Description": "If the tree t is sorted, then for every Node l v r, l and r are sorted."
  },
  {
    "Statement": "zip :: Seq a -> Seq b -> Seq (a, b)",
    "Description": "Declare a function zip that combines two sequences into a sequence of pairs."
  },
  {
    "Statement": "case Nil",
    "Description": "If the case is an empty list."
  },
  {
    "Statement": "mempty = Any False",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Any a' as an 'Any' value wrapping 'False'."
  },
  {
    "Statement": "newChan :: IO (Chan a)",
    "Description": "Create a new unbounded channel of type Chan a, which can be used for communication between threads."
  },
  {
    "Statement": "flattenBinTree (Node x l r) = x : (flattenBinTree l ++ flattenBinTree r)",
    "Description": "Define a function 'flattenBinTree' that takes a binary tree of type 'Tree a' and returns a list of all the values in the tree, represented in a flattened form."
  },
  {
    "Statement": "(<**>) :: Monoidal f => f (a -> b) -> f a -> f b",
    "Description": "Declare the '(<**>)' operator signature for the 'Monoidal' type class, which takes a value of type 'f (a -> b)' and a value of type 'f a', and returns a value of type 'f b' by applying the functions in the first argument to the values in the second argument."
  },
  {
    "Statement": "Nothing >> Just 1",
    "Description": "Perform the (>>) operation with Nothing and Just 1, resulting in Nothing."
  },
  {
    "Statement": "foldl' :: (a -> b -> a) -> a -> [b] -> a",
    "Description": "Define the type signature for the foldl' function, which takes a function (a -> b -> a), an initial value of type a, and a list of elements of type b, and returns a value of type a."
  },
  {
    "Statement": "z :: Float",
    "Description": "Declare a variable 'z' with type Float."
  },
  {
    "Statement": "fac n = aux n 1 where aux n acc | n <= 1 = acc | otherwise = aux (n-1) (nacc)",
    "Description": "Define a function 'fac' that calculates the factorial of 'n' using an accumulator. It initializes the accumulator to 1 and calls the auxiliary function 'aux' with 'n' and the accumulator. The 'aux' function recursively calculates the factorial by updating 'n' and 'acc' until 'n' becomes less than or equal to 1, at which point it returns the accumulator."
  },
  {
    "Statement": "have sorted left: \"sortedT l\" using 2 sorted node by blast",
    "Description": "declare that 'l' is sorted."
  },
  {
    "Statement": "quicksort :: Ord a => [a] -> [a]",
    "Description": "Define a function 'quicksort' that takes a list of elements of type 'a' (which must be an instance of the 'Ord' typeclass) and returns a sorted list."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "sum (x: xs) = x + sum xs",
    "Description": "Sum the first element x with the sum of the remaining elements xs recursively."
  },
  {
    "Statement": "pure :: Monoidal f => a -> f a\n\npure x = fmap (\\\\_ -> x) unit",
    "Description": "Define a function pure that takes a value x and a Monoidal functor f and returns a functor f x, using the fmap and unit functions from the Monoidal and Functor typeclasses."
  },
  {
    "Statement": "input <- liftIO getLine",
    "Description": "Read a line of input from the user within the `IO` monad, lifted into the `StateT` monad using `liftIO`."
  },
  {
    "Statement": "append (Cons x xs) ys = Cons x (append xs ys)",
    "Description": "Otherwise, prepend the head of the first list to the result of recursively calling append with the tail of the first list and the second list."
  },
  {
    "Statement": "mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()",
    "Description": "Define 'mapM_' which maps each element of a structure to a monadic action, and evaluates these actions from left to right, discarding the results."
  },
  {
    "Statement": "Induction Base",
    "Description": "Define induction base."
  },
  {
    "Statement": "inOrder (Node x l r) = inOrder l ++ [x] ++ inOrder r",
    "Description": "Otherwise, return the concatenation of the in order traversal of the left subtree, a singleton list containing the value at the root, and the in-order traversal of the right subtree."
  },
  {
    "Statement": "minimum (x:xs) = min x (minimum xs)",
    "Description": "Otherwise, return the minimum of the first element and the minimum of the rest of the list."
  },
  {
    "Statement": "if input == ending then return () else aux ending",
    "Description": "Check if the input string is equal to the ending string. If it is, return an empty tuple. Otherwise, recursively call aux with the ending string."
  },
  {
    "Statement": "getName = do",
    "Description": "Begin the definition of the `getName` function using the do notation for monadic computations."
  },
  {
    "Statement": "unlines [] = \"\"",
    "Description": "Define the base case of the unlines function where an empty list is given, it returns an empty string."
  },
  {
    "Statement": "data Maybe a = Nothing | Just a",
    "Description": "Define a data type named Maybe which is either Nothing or Just containing an element of type a."
  },
  {
    "Statement": "| otherwise = elem y xs",
    "Description": "Otherwise, check the rest of the list."
  },
  {
    "Statement": "sorted [x] = True",
    "Description": "If the list has one element, return True."
  },
  {
    "Statement": "less eq:: a →> a -> Bool;",
    "Description": "Define 'less' as a function which takes two arguments of type 'a' and returns a Bool."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "The base case for summing an empty list, which returns 0."
  },
  {
    "Statement": "import Data.List (nub)\n\nremoveDuplicates :: Ord a => [a] -> [a]",
    "Description": "Define a function 'removeDuplicates' that takes a list of elements of any type 'a' that implements the 'Ord' typeclass, and returns a list of unique elements. Import the 'nub' function from the 'Data.List' module."
  },
  {
    "Statement": "toGraph nodes = buildG (0, length nodes - 1) edges",
    "Description": "Implement 'toGraph' by calling 'buildG' with the appropriate node range and a list of edges derived from the node list."
  },
  {
    "Statement": "drop n xs | n <= 0 = xs",
    "Description": "If `n` is less than or equal to 0, return the entire list."
  },
  {
    "Statement": "dropWhile' :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function dropWhile' that takes a predicate p and a list xs, and returns the suffix of xs after the longest prefix that satisfies p."
  },
  {
    "Statement": "rseq :: Strategy a",
    "Description": "Create a Strategy that evaluates the given value to weak head normal form."
  },
  {
    "Statement": "get :: m s",
    "Description": "Declare a function `get` that retrieves the current state value within the base monad `m`."
  },
  {
    "Statement": "zip3' :: [a] -> [b] -> [c] -> [(a, b, c)]",
    "Description": "Define a function zip3' that takes three lists xs, ys, and zs, and returns a list of triples, where each triple contains one element from each list."
  },
  {
    "Statement": "lift $ putStrLn $ \"Your name is \" ++ name",
    "Description": "Print a message that includes the user's name, using `lift` to lift the `IO` action into the `MaybeT` monad."
  },
  {
    "Statement": "runState :: States a →>s -> (a, s)",
    "Description": "Declare a function runState that takes a State computation and an initial state, and returns a tuple containing the final result and the final state."
  },
  {
    "Statement": "- )",
    "Description": "End of the comment."
  },
  {
    "Statement": "sortBy cmp (x:xs) = sortBy cmp (filter (\\y -> cmp y x == LT) xs) ++ [x] ++ sortBy cmp (filter (\\y -> cmp y x /= LT) xs)",
    "Description": "Define the recursive case of the sortBy function where a non-empty list is given. It sorts the list using the comparison function 'cmp'."
  },
  {
    "Statement": "count <- get",
    "Description": "Retrieve the current count value from the state using the `get` function."
  },
  {
    "Statement": "instance Semigroup [a]",
    "Description": "Provide an instance of Semigroup for lists, where the (<>) operation is defined as list concatenation (++)."
  },
  {
    "Statement": "insert x (y:ys) | x <= y = x : y : ys",
    "Description": "If x is less than or equal to the head of the list, prepend x and the head to the tail of the list."
  },
  {
    "Statement": "map [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "return (if null input then Nothing else Just input)",
    "Description": "Check if the input is null. If it is, return Nothing. Otherwise, return the input wrapped in a Just constructor."
  },
  {
    "Statement": "    | otherwise = False",
    "Description": "Define the condition for the recursive case of the isPrefixOf function. If the current elements 'x' and 'y' are not equal, it returns False."
  },
  {
    "Statement": "deriving (Eq, Ord)",
    "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Dual' data type."
  },
  {
    "Statement": "factorial n = product [1..n]",
    "Description": "Calculate the factorial of the input integer `n` using a list comprehension and the `product` function."
  },
  {
    "Statement": "in_range min max x = x >= min && x <= max",
    "Description": "Checks if the value of x is within the range specified by min and max"
  },
  {
    "Statement": "filterString :: String -> String",
    "Description": "Define a function filterString that takes a String and removes non-alphabetic characters."
  },
  {
    "Statement": "in_range min max x = if ilb then iub else False",
    "Description": "Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'. It returns True if 'x' is within the range [min, max], otherwise False."
  },
  {
    "Statement": "rev::\n[a] -> [a]",
    "Description": "Define 'rev' as a function which takes a list of 'a' and returns a list of 'a'."
  },
  {
    "Statement": "insert x (y:ys) | otherwise = y : insert x ys",
    "Description": "Otherwise, prepend the head of the list to the result of recursively calling insert with x and the tail of the list."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
  },
  {
    "Statement": "data Point = D2 {x :: Int, y :: Int} | D3 {x :: Int, y :: Int, z :: Int}",
    "Description": "Define a datatype 'Point' with two constructors: 'D2' taking 'x' and 'y' coordinates, and 'D3' taking 'x', 'y', and 'z' coordinates."
  },
  {
    "Statement": "elemIndexL :: Eq a => a -> Seq a -> Maybe Int",
    "Description": "Declare a function elemIndexL that returns the index of the first occurrence of an element in a sequence."
  },
  {
    "Statement": "insertionSort (x:xs) = insert x (insertionSort xs)",
    "Description": "Otherwise, recursively call insertionSort with the tail of the list and insert the head of the list into the sorted result."
  },
  {
    "Statement": "partition _ [] = ([], [])",
    "Description": "Define the base case of the partition function where an empty list is given, it returns a pair of empty lists."
  },
  {
    "Statement": "let ncount = count + 1",
    "Description": "Calculate the new count by incrementing the current count by 1, and bind it to the variable ncount."
  },
  {
    "Statement": "insert x (y:ys) | x <= y = x : y : ys",
    "Description": "If x is less than or equal to the head of the list, prepend x and the head to the tail of the list."
  },
  {
    "Statement": "reverse (Cons x xs) = append (reverse xs) (Cons x Nil)",
    "Description": "Otherwise, recursively call reverse with the tail of the list and prepend the head of the list to the result."
  },
  {
    "Statement": "monadd mx y = mx >>= (\\x -> my >>= (\\y -> return $ x+y))",
    "Description": "Use bind operator `(>>=)` and `return` to sequentially extract values from `mx` and `my`, add them, and wrap the result in the monadic context."
  },
  {
    "Statement": "zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]",
    "Description": "Define 'zipWith' as a function which takes a function and two lists, and returns a list of the results of applying the function to each pair of corresponding elements."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "product :: [Int] -> Int",
    "Description": "Define a function named `product` which takes a list of `Int` and returns an `Int`."
  },
  {
    "Statement": "con \"split\" (splitOn :: Eq a => a -> [a] -> [[a]]),",
    "Description": "Include the 'split' function signature."
  },
  {
    "Statement": "evalStateT :: Monad m => StateT s m a -> s -> m a",
    "Description": "Declare a function `evalStateT` that takes a `StateT` computation and an initial state, and runs the computation within the base monad `m`, returning only the result value `a` (discarding the final state)."
  },
  {
    "Statement": "prop xs = not (null xs) ==> (length $ tail xs) === ((length xs) -1)",
    "Description": "Define a property named prop that states if xs is not null, then the length of the tail of xs is equal to the length of xs minus one."
  },
  {
    "Statement": "lift3 f a b c = lift2 f a b <\\*\\*> c",
    "Description": "Define a function lift3 that takes three arguments f, a, b, and c. It applies the lift2 function to f, a, and b, and then applies the <\\*\\*> operator to the result and c."
  },
  {
    "Statement": "or :: [Bool] -> Bool",
    "Description": "Return True if at least one element in the list is True, otherwise False."
  },
  {
    "Statement": "import Data.Maybe (catMaybes)\n\nremoveNothings :: [Maybe a] -> [a]",
    "Description": "Define a function 'removeNothings' that takes a list of 'Maybe' values of any type 'a' and returns a list containing only the 'Just' values, discarding any 'Nothing' values. Import the 'catMaybes' function from the 'Data.Maybe' module."
  },
  {
    "Statement": "con \"addToSet\" ((\\/) :: [a] -> [a] -> [a]),",
    "Description": "Include the 'addToSet' function signature."
  },
  {
    "Statement": "greet (Person name_) = \"Hi\" ++ name_",
    "Description": "Define 'greet' function pattern matching on 'Person' constructor with 'name_' as its argument, concatenating \"Hi\" with 'name_'."
  },
  {
    "Statement": "app f x = f x",
    "Description": "Implement the 'app' function by applying the function 'f' to the value 'x'."
  },
  {
    "Statement": "\"(Vlv € setT l. lv ≤ v)\"",
    "Description": "Assume that for every lv in the set of l, lv is less than or equal to v."
  },
  {
    "Statement": "reverseString :: String -> String",
    "Description": "Define a function reverseString that takes a String and reverses it."
  },
  {
    "Statement": "length (_:xs) = 1 + length xs",
    "Description": "Define the length of a list as 1 plus the length of the rest of the list."
  },
  {
    "Statement": "Module.name",
    "Description": "Accesses the entity 'name' from the module 'Module'."
  },
  {
    "Statement": "(<>) = coerce ((&&) :: a -> a -> a)",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'All a' by converting the '(&&)' function for type 'a' to the appropriate type using 'coerce'."
  },
  {
    "Statement": "]",
    "Description": "End the 'treeSig1' list definition."
  },
  {
    "Statement": "topMost :: TreeZipper a -> Tree a",
    "Description": "Define a function 'topMost' that returns the topmost tree from a 'TreeZipper a'."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "The base case for summing an empty list, which returns 0."
  },
  {
    "Statement": "con \"even\" (even :: Int -> Bool),",
    "Description": "Include the 'even' function signature."
  },
  {
    "Statement": "case (Cons x xs)",
    "Description": "If the case is a non-empty list."
  },
  {
    "Statement": "revSig\n:: [Sigl",
    "Description": "Define 'revSig' as a list of Sig."
  },
  {
    "Statement": "import Module",
    "Description": "Imports all the entities (functions, types, etc.) from the module 'Module' into the current namespace."
  },
  {
    "Statement": "dropWhile :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define 'dropWhile' as a function which removes elements from a list while the predicate holds."
  },
  {
    "Statement": "unfoldr :: (b -> Maybe (a, b)) -> b -> [a]",
    "Description": "Define a function unfoldr that takes a function f, an initial value x, and generates a list by repeatedly applying f to the current value and using the result to generate the next value, until f returns Nothing."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
  },
  {
    "Statement": "x:xs",
    "Description": "Represent a list where 'x' is the first element and 'xs' is the rest of the list."
  },
  {
    "Statement": "apply (induct xs)",
    "Description": "Begin the proof by induction over the list `xs`."
  },
  {
    "Statement": "con \"fromist\" (fromlist:: [OrdA] -> Tree OrdA),",
    "Description": "Include the 'fromlist' function signature in 'treesig2'."
  },
  {
    "Statement": "abs :: a -> a",
    "Description": "Define the absolute value operation 'abs' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
  },
  {
    "Statement": "addsig - [\ncon\n((+) :: Int -> Int -> Int),",
    "Description": "Declare the signature for addition '(+) :: Int -> Int -> Int'."
  },
  {
    "Statement": "instance Monad ((->) r) where\n    return = const\n    m >>= k = \\r -> k (m r) r\n    (>>) = (*>)",
    "Description": "Provide an instance of the 'Monad' type class for the function type constructor '(->) r'. This instance allows for sequencing and combining computations that take a value of type 'r' as input."
  },
  {
    "Statement": "newtype Endo a = Endo { appEndo :: a -> a }",
    "Description": "Define a new data type called 'Endo' with a single constructor 'Endo' that wraps a function of type 'a -> a'. The 'appEndo' function applies the wrapped function to an argument of type 'a'."
  },
  {
    "Statement": "complexSig :: [Sig]",
    "Description": "Define 'complexSig' as a list of Sig."
  },
  {
    "Statement": "Lemma sorted node:",
    "Description": "Define a lemma named sorted_node."
  },
  {
    "Statement": "apply (induct t)",
    "Description": "Begin the proof by induction over tree `t`."
  },
  {
    "Statement": "int func(int arg) {",
    "Description": "Start the definition of a function named 'func' that takes an integer argument 'arg'."
  },
  {
    "Statement": "maybe_val <- iom",
    "Description": "Bind the result of the first IOMaybe computation iom to the variable maybe_val."
  },
  {
    "Statement": "insertionSort :: Ord a => [a] -> [a]",
    "Description": "Define a function named insertionSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
  },
  {
    "Statement": "right = drop (length xs `div` 2) xs",
    "Description": "Define 'right' as the second half of the list."
  },
  {
    "Statement": "lift $ putStrLn $ \"Your name is \" ++ name",
    "Description": "Print a message that includes the user's name, using `lift` to lift the `IO` action into the `MaybeT` monad."
  },
  {
    "Statement": "transposeMatrix = transpose",
    "Description": "The implementation of 'transposeMatrix' simply applies the 'transpose' function, which transposes the input matrix."
  },
  {
    "Statement": "unit :: a -> Maybe a\n\nunit x = Just x",
    "Description": "Define a function unit that takes a value x and returns Just x, representing the unit value of the Maybe functor."
  },
  {
    "Statement": "in_range min max x = x >= min && x <= max",
    "Description": "Define the 'in_range' function to check if 'x' is within the range [min, max]."
  },
  {
    "Statement": "begin",
    "Description": "Begin the theory."
  },
  {
    "Statement": "checkInput (x:_) = isUpper x",
    "Description": "If the input String is non-empty, check if the first character is an uppercase letter using the isUpper function, and return the result as a Bool."
  },
  {
    "Statement": "instance Num a => Semigroup (Sum a) where",
    "Description": "Define a 'Semigroup' instance for the 'Sum' data type, constrained by the 'Num' type class constraint on 'a'."
  },
  {
    "Statement": "} else {",
    "Description": "Handle the else part of the conditional Statement."
  },
  {
    "Statement": "ghci> :i Exception",
    "Description": "View the information about the Exception class in GHCi."
  },
  {
    "Statement": "getProgname :: IO String",
    "Description": "Define a function 'getProgname' which returns the program name as an IO action."
  },
  {
    "Statement": "readUntilWithState :: String -> IO Int",
    "Description": "Declare a function named `readUntilWithState` that takes a `String` argument and returns an `IO Int` computation, which reads input from the user until a specific ending string is entered and returns the number of lines read, using the `StateT` monad transformer."
  },
  {
    "Statement": "descSort x = reverse (sort x)",
    "Description": "Define 'descSort' as a function that takes an argument 'x' and returns the reverse of the sorted 'x'."
  },
  {
    "Statement": "]",
    "Description": "End of the list."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "init :: [a] -> [a]",
    "Description": "Return all elements of a list except the last one."
  },
  {
    "Statement": "revAcc = aux []",
    "Description": "Define 'revAcc' as an auxiliary function."
  },
  {
    "Statement": "applyTwice :: (a -> a) -> a -> a",
    "Description": "Define a function applyTwice that takes a function f and an argument x, and applies the function f to x twice."
  },
  {
    "Statement": "topologicalSort nodes = map (nodes !!) (topSort (toGraph nodes))",
    "Description": "Implement 'topologicalSort' by converting the node list into a graph, performing a topological sort using 'topSort', and then mapping the indices back to the original node list."
  },
  {
    "Statement": "inorder Leaf = []",
    "Description": "If the tree is empty, return an empty list."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "Define the base case of the sum function where an empty list is given, it returns 0."
  },
  {
    "Statement": "checkInput (x:_) = isUpper x",
    "Description": "If the input string is non-empty, check if the first character is uppercase and return the result."
  },
  {
    "Statement": "concatMapSig - [\ncon \"map\" (map :: (a -> b) →› [A] -> (B]),",
    "Description": "Declare the signature for 'map' function."
  },
  {
    "Statement": "get :: m s",
    "Description": "Declare a function `get` that retrieves the current state value within the base monad `m`."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "The base case for summing an empty list, which returns 0."
  },
  {
    "Statement": "calc (Mul x y) = xy",
    "Description": "Define the 'calc' function pattern matching on the 'Mul' constructor, returning the product of 'x' and 'y'."
  },
  {
    "Statement": "instance Arrow (->) where\n  arr = id\n  (***) f g (x,y) = (f x, g y)\n  a :: (Arrow a, Num c) => a c c\n  a = arr (+1)\n  b :: (Arrow a, Num c) => a c c\n  b = arr (*2)\n  comb :: (Arrow a, Num c ) => a (c, c) c\n  comb = arr (\\(x,y) -> x + y)\n  c :: (Arrow cat, Num c) => cat c c\n  c = a &&& b >>> comb",
    "Description": "Provide an instance of the 'Arrow' type class for the function type constructor '(->) a b'. It also defines several arrows: 'a' is an arrow that increments a number, 'b' is an arrow that doubles a number, 'comb' is an arrow that adds two numbers, and 'c' is an arrow that combines 'a' and 'b' in parallel and then adds the results using 'comb'."
  },
  {
    "Statement": "class Functor f => Applicative (f :: _\\->_ )\n\nwhere\n\n    pure :: a -> f a\n\n    (<\\*>) :: f (a -> b) -> f a -> f b",
    "Description": "Define a typeclass Applicative that extends the Functor typeclass. It has two member functions: pure that takes a value a and returns a functor f a, and (<\\*>) that takes a functor of functions f (a -> b) and a functor f a and returns a functor f b."
  },
  {
    "Statement": "(<>) (NonEmpty (x, xs)) (NonEmpty (y, ys)) = NonEmpty (x, xs ++ [y] ++ ys)",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'NonEmpty a' to concatenate two 'NonEmpty' lists."
  },
  {
    "Statement": "maximum = foldl1 max",
    "Description": "Define 'maximum' as a function which finds the maximum element of a non-empty list using the 'max' function."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "module Main whene",
    "Description": "Define the module 'Main' with a typo in 'where'."
  },
  {
    "Statement": "qed",
    "Description": "Close the current proof."
  },
  {
    "Statement": "case Nil",
    "Description": "If the case is the first list being empty."
  },
  {
    "Statement": "case (Cons x xs)",
    "Description": "If the case is a non-empty first list."
  },
  {
    "Statement": "case (Cons x xs)",
    "Description": "If the case is a non-empty list."
  },
  {
    "Statement": "permutations' = permutations",
    "Description": "The implementation of 'permutations'' simply applies the 'permutations' function to the input list."
  },
  {
    "Statement": "or = foldr (||) False",
    "Description": "Define 'or' as a fold operation using the '||' operator and starting with an initial accumulator of 'False'."
  },
  {
    "Statement": "left = take (length xs `div` 2) xs",
    "Description": "Define 'left' as the first half of the list."
  },
  {
    "Statement": "calc (Sub x y) = x-y",
    "Description": "Define the 'calc' function pattern matching on the 'Sub' constructor, returning the difference of 'x' and 'y'."
  },
  {
    "Statement": "where aux ending count = do",
    "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string and the current `count` as arguments."
  },
  {
    "Statement": "    | otherwise = x : deleteBy eq y xs",
    "Description": "Define the condition for the recursive case of the deleteBy function. If the predicate 'eq' is not satisfied by the current element 'x' and 'y', it keeps 'x' and recursively processes the rest of the list."
  },
  {
    "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Dual a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
  },
  {
    "Statement": "tryJust :: Exception e => (e -> Maybe b) -> IO a > IO (Either b a)",
    "Description": "Create an IO action that attempts to run the given IO action, using the provided function to filter the exceptions. If the function returns Just b, the action returns Left b, otherwise it returns Right a."
  },
  {
    "Statement": "liftIOm :: IO a -> IOMaybe a",
    "Description": "Define a function liftIOm that takes an IO computation and lifts it into the IOMaybe context, allowing for side effects while still preserving the possibility of failure."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "Define the splice function for an empty list and a non-empty list ys to return the list ys."
  },
  {
    "Statement": "exitSuccess = System.Exit.exitSuccess",
    "Description": "Implement the 'exitSuccess' function using 'System.Exit.exitSuccess'."
  },
  {
    "Statement": "permutations' :: [a] -> [[a]]",
    "Description": "Define a function permutations' that takes a list xs and returns a list of all possible permutations of xs."
  },
  {
    "Statement": "import Data.List (isInfixOf)\n\ncontains :: Eq a => [a] -> [a] -> Bool",
    "Description": "Define a function 'contains' that takes two lists of elements of any type 'a' that implements the 'Eq' typeclass, and returns 'True' if the first list is a substring (infix) of the second list, and 'False' otherwise. Import the 'isInfixOf' function from the 'Data.List' module."
  },
  {
    "Statement": "instance (Monoid w, Monad m) => MonadWriter w (StateT s m) where\n    tell w = state $ \\s -> ((), s `mappend` w)\n    listen (StateT m) = StateT $ \\s -> do\n        ((a, s'), w) <- listen (m s)\n        return ((a, w), s')\n    pass (StateT m) = StateT $ \\s -> do\n        ((a, f), s') <- pass (m s)\n        return (a, f s')",
    "Description": "Provide an instance of the 'MonadWriter' type class for the 'StateT' monad transformer, assuming that 'm' is an instance of the 'Monad' type class and 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value within the 'StateT' monad transformer."
  },
  {
    "Statement": "\"sortedT t ⟶ sortedT (insert v t)\"",
    "Description": "If the tree t is sorted, then inserting v into t will result in a sorted tree."
  },
  {
    "Statement": "lemma setT insert: \"setT (insert v t) = setT t U {v}\"",
    "Description": "Define a lemma asserting the set of a tree after inserting `v` is equal to the set of the original tree unioned with `{v}`."
  },
  {
    "Statement": "]",
    "Description": "End the 'treesig2' list definition."
  },
  {
    "Statement": "propRev xs = reverse xs === rev xs",
    "Description": "Define a property named propRev that checks if reversing a list xs using the reverse function is equal to reversing it using the custom rev function."
  },
  {
    "Statement": "map (\\(x,y) -> x+y) [(1,2), (2,3), (3,4)]",
    "Description": "Applly the anonymous function ((x,y) -> x+y) to each tuple in the list [(1,2), (2,3), (3,4)] using 'map', resulting in [3,5,7]."
  },
  {
    "Statement": "data Tree a = Leaf | Node a (Tree a) (Tree a)",
    "Description": "Define a data type named Tree which is either Leaf or a Node containing an element of type a and two subtrees of the same type."
  },
  {
    "Statement": "readUntilWithState :: String -> 10 Int",
    "Description": "Declare a function readUntilWithState that takes a String argument and returns an IO Int value."
  },
  {
    "Statement": "checkFirstChar (x:_) = isUpper x",
    "Description": "If the input string is non-empty, check if the first character is uppercase and return the result."
  },
  {
    "Statement": "f xs = map (\\x -> x+1) $ filter (\\x -> x>1) xs",
    "Description": "Define the function 'f' where the '$' operator is used to replace the parentheses, indicating that the result of 'filter' is passed as an argument to 'map'."
  },
  {
    "Statement": "add = (\\x -> (\\y -> x+y))",
    "Description": "Define the 'add' function as a composition of two lambda functions, the outer one taking 'x' and the inner one taking 'y', returning their sum."
  },
  {
    "Statement": "failing = do throw Error",
    "Description": "Define the failing function to throw an exception of type Error."
  },
  {
    "Statement": "greet person = \"Hi\" ++ name person",
    "Description": "Define 'greet' function to concatenate \"Hi\" with the name of the person passed as argument."
  },
  {
    "Statement": "catch :: Exception e => IO a -> (e -> IO a) -> IO a",
    "Description": "Define the type signature for the catch function, which takes an IO action and a handler function (e -> IO a), and returns an IO action that either executes the original action or the handler if an exception of type e is thrown."
  },
  {
    "Statement": "input <- liftIo getLine",
    "Description": "Read a line of input from the user and bind it to the variable input, using liftIo to lift the IO action into the StateT monad."
  },
  {
    "Statement": "con \"insert\" (insert :: OrdA -› Tree OrdA -> Tree OrdA)",
    "Description": "Include the 'insert' function signature in 'treeSig1'."
  },
  {
    "Statement": "putStrLn \"Please enter input: \"",
    "Description": "Print the prompt \"Please enter input: \" to the user."
  },
  {
    "Statement": "lift2 f x = (<**>) (fmap f x)",
    "Description": "Define the 'lift2' function by applying 'fmap' to the input function 'f' and the input value 'x' of type 'f a', and then using the '(<**>)' operator to apply the resulting functions to the input value 'x'."
  },
  {
    "Statement": "newtype StateT s (m :: * -> *) a",
    "Description": "Declare a new type constructor `StateT` that represents a state transformer monad, parameterized by the state type `s`, a base monad `m`, and the result type `a`."
  },
  {
    "Statement": "mergeSort [] = []",
    "Description": "For an empty list, 'mergeSort' returns an empty list."
  },
  {
    "Statement": "then returnIOM input",
    "Description": "If the input is valid, return a successful IOMaybe computation with the input String."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "unwords' :: [String] -> String",
    "Description": "Define a function unwords' that takes a list of words and joins them together using whitespace characters."
  },
  {
    "Statement": "f (Right \"Hello\")",
    "Description": "Applies 'f' to a 'Right' value with 'Hello', resulting in 'Hello'."
  },
  {
    "Statement": "import Data.List (sort, group)\n\npackConsecutive :: Ord a => [a] -> [[a]]",
    "Description": "Define a function 'packConsecutive' that takes a list of elements of any type 'a' that implements the 'Ord' typeclass, and returns a list of lists, where each sublist contains consecutive duplicate elements from the input list. Import the 'sort' and 'group' functions from the 'Data.List' module."
  },
  {
    "Statement": "splice [] [] = []",
    "Description": "The base case for splicing two empty lists, which returns an empty list."
  },
  {
    "Statement": "map :: (a -> b) -> [a] -> [b]",
    "Description": "Define a function named `map` which takes a function `(a -> b)` and a list of `a` and returns a list of `b`."
  },
  {
    "Statement": "splitWords = filter (not . null) . map (filter (not . isSpace)) . groupBy ((==) on isSpace)",
    "Description": "The implementation of 'splitWords' uses a pipeline of functions: first, group the characters in the input string into lists based on whether they are whitespace or not using 'groupBy' and the 'isSpace' predicate; then, for each group, filter out the whitespace characters using 'filter' and 'isSpace'; finally, remove any empty strings from the resulting list of words using 'filter' and 'null'."
  },
  {
    "Statement": "instance Monoid (Endo a) where",
    "Description": "Define a 'Monoid' instance for the 'Endo' data type."
  },
  {
    "Statement": "joinWith :: String -> [String] -> String",
    "Description": "Define a function 'joinWith' that takes a separator string and a list of strings, and returns a single string with the elements of the list joined by the separator."
  },
  {
    "Statement": "append Nil ys = ys",
    "Description": "If the first input list is Nil, return the second list."
  },
  {
    "Statement": "snd :: (a,b) -> b",
    "Description": "Return the second element of a tuple."
  },
  {
    "Statement": "sum :: Num p => [p] -> p",
    "Description": "Define a function 'sum' which takes a list of values of type 'p' belonging to the 'Num' typeclass and returns a single value of type 'p'."
  },
  {
    "Statement": "import Data.List (foldl')\n\nfilter' :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function 'filter'' that takes a predicate function 'p :: a -> Bool' and a list of elements of type 'a', and returns a list containing only the elements that satisfy the predicate. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "(- Simple laws about addition -)",
    "Description": "Start of the comment 'Simple laws about addition'."
  },
  {
    "Statement": "getName = do",
    "Description": "Begin the implementation of the getName function using the do notation."
  },
  {
    "Statement": "add1 = \\x -> x+1",
    "Description": "Bind the anonymous function \\x -> x+1 to the name 'add1'."
  },
  {
    "Statement": "instance Semigroup (NonEmpty a) where",
    "Description": "Define a 'Semigroup' instance for the 'NonEmpty' data type."
  },
  {
    "Statement": "($) :: (a -> b) -> a -> b",
    "Description": "Define the type signature for the ($) operator, which takes a function (a -> b) and a value of type a, and returns a value of type b."
  },
  {
    "Statement": "x (D2 1 2)",
    "Description": "Access the 'x' coordinate of a 2D point, yielding '1'."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "Define the splice function for a non-empty list xs and an empty list to return the list xs."
  },
  {
    "Statement": "liftIOm io :: io >>= retrunIOM",
    "Description": "Implement the liftIOm function by binding the result of the IO computation io to the returnIOM function, which wraps the value in a successful IOMaybe computation."
  },
  {
    "Statement": "getName :: IOMaybe String",
    "Description": "Define a function getName that returns an IOMaybe String."
  },
  {
    "Statement": "postOrder Leaf = []",
    "Description": "If the input tree is Leaf, return an empty list."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "proof (induction t rule:insert.induct)",
    "Description": "Apply induction on the tree with the rule for the 'insert' function."
  },
  {
    "Statement": "    | eq x y = xs",
    "Description": "Define the condition for the recursive case of the deleteBy function. If the predicate 'eq' is satisfied by the current element 'x' and 'y', it returns the rest of the list."
  },
  {
    "Statement": "                       [] -> []",
    "Description": "Define the condition for the recursive case of the lines function. If the remaining string is empty, it returns an empty list."
  },
  {
    "Statement": "readUntilWithCount :: String -> IO Int",
    "Description": "Declare a function readUntilWithCount that takes a String argument and returns an IO Int value."
  },
  {
    "Statement": "con \"notEqual\" ((/=) :: Int -> Int -> Bool),",
    "Description": "Include the 'notEqual' operator signature."
  },
  {
    "Statement": "getName :: MaybeT IO String",
    "Description": "Declare a function named `getName` that returns a `MaybeT IO String` value, which represents a computation that may fail to produce a `String` value within the `IO` monad."
  },
  {
    "Statement": "and' :: [Bool] -> Bool",
    "Description": "Define a function and' that takes a list of Booleans and returns True if all the elements are True, otherwise False."
  },
  {
    "Statement": "count ‹- get",
    "Description": "Get the current count from the state and bind it to the variable count."
  },
  {
    "Statement": "import Data.List (elemIndex)\n\nfirstIndexOf :: Eq a => a -> [a] -> Maybe Int",
    "Description": "Define a function 'firstIndexOf' that takes an element and a list of elements of the same type 'a' that implements the 'Eq' typeclass, and returns the index (zero-based) of the first occurrence of the element in the list, wrapped in a 'Maybe' data type. Import the 'elemIndex' function from the 'Data.List' module."
  },
  {
    "Statement": "readUntilWithCount ending = aux ending 0",
    "Description": "Define the `readUntilWithCount` function by calling an auxiliary function `aux` with the `ending` string and an initial count of `0`."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user and bind it to the variable input."
  },
  {
    "Statement": "let (x,y) = (1,2) in x",
    "Description": "Bind the tuple (1,2) to variables x and y, then returns the value of x, which is 1."
  },
  {
    "Statement": "scanl1 :: (a -> a -> a) -> Seq a -> Seq a",
    "Description": "Declare a function scanl1 that scans a non-empty sequence from the left with a binary function."
  },
  {
    "Statement": "mempty = NonEmpty (undefined, [])",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'NonEmpty a' as a 'NonEmpty' value wrapping an empty tuple and an empty list."
  },
  {
    "Statement": "length (_:xs) = 1 + length xs",
    "Description": "Define the length of a non-empty list as 1 plus the length of the remaining elements (xs)."
  },
  {
    "Statement": "sum []",
    "Description": "Define the sum of an empty list as 0."
  },
  {
    "Statement": "case (Cons x xs)",
    "Description": "If the case is a non-empty list."
  },
  {
    "Statement": "WithProgName :: String -> IO a -> IO a",
    "Description": "Define a function 'WithProgName' which takes a string representing a new program name and an IO action, and executes the action with the specified program name."
  },
  {
    "Statement": "fibonacci 0 = 0",
    "Description": "The Fibonacci of 0 is 0."
  },
  {
    "Statement": "(**) :: f a -> f b -> f (a,b)",
    "Description": "Declare the '(**)' operator signature for the 'Monoidal' type class, which takes two values of types 'f a' and 'f b', and returns a value of type 'f (a,b)' representing their monoidal product."
  },
  {
    "Statement": "join :: Maybe (Maybe a) -> Maybe a\n\njoin (Just x) = x\n\njoin Nothing = Nothing",
    "Description": "Define a function join that takes a nested Maybe (Maybe a) and flattens it to a single Maybe a, either by unwrapping the inner Just value or returning Nothing if the outer value is Nothing."
  },
  {
    "Statement": "\"assumes 'sortedT l'\"",
    "Description": "Assume that l is sorted."
  },
  {
    "Statement": "prop x y = ((x <> y) <> mempty) === (x <> (y <> mempty))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'All a' by comparing the results of two equivalent expressions involving '<>' and 'mempty'."
  },
  {
    "Statement": "intersperse :: a -> Seq a -> Seq a",
    "Description": "Declare a function intersperse that intersperses an element between the elements of a sequence."
  },
  {
    "Statement": "foldl' :: (a -> b -> a) -> a -> [b] -> a",
    "Description": "Define a function foldl' that takes a function f, an initial value z, and a list xs, and applies f to each element of xs, starting with the initial value z and the first element of xs, and then applying f to the result and the second element, and so on."
  },
  {
    "Statement": "otherwise = n * fac (n-1)",
    "Description": "Otherwise, return `n * fac (n-1)`."
  },
  {
    "Statement": "elem _ [] = False",
    "Description": "If the list is empty, return `False`."
  },
  {
    "Statement": "instance Monad Maybe where\n    return = Just\n    Nothing >>= _ = Nothing\n    Just x >>= f  = f x\n    (>>) = (*>)",
    "Description": "Provide an instance of the 'Monad' type class for the 'Maybe' data type. This instance allows for sequencing and combining 'Maybe' computations."
  },
  {
    "Statement": "  return :: a -> m a",
    "Description": "Wrap a value into the monadic context."
  },
  {
    "Statement": "case (2 v l tv r)",
    "Description": "If the case is (2 v l tv r),"
  },
  {
    "Statement": "append Nil ys = ys",
    "Description": "If the first input list is Nil, return the second list."
  },
  {
    "Statement": "instance Monad List where",
    "Description": "Define an instance of the Monad typeclass for the List data type."
  },
  {
    "Statement": "shuffleString :: String -> IO String",
    "Description": "Define a function shuffleString that takes a String and shuffles its characters randomly."
  },
  {
    "Statement": "isleft :: Either a b -> Bool",
    "Description": "Define a function 'isleft' that checks whether the given 'Either' value is of the 'Left' type."
  },
  {
    "Statement": "data MyError = Error deriving Show",
    "Description": "Define a data type MyError with a single constructor Error, and derive the Show instance for it."
  },
  {
    "Statement": "foldl' :: (a -> b -> a) -> a -> Seq b -> a",
    "Description": "Declare a function foldl' that folds a sequence strictly from the left with a binary function."
  },
  {
    "Statement": "using sorted.simps(2) sizeT append by blast",
    "Description": "Use the given sorted lemma to solve the subgoals."
  },
  {
    "Statement": "Just 1 >> Just 2",
    "Description": "Perform the (>>) operation with Just 1 and Just 2, resulting in Just 2."
  },
  {
    "Statement": "(>>) :: Monad m => m a -> m b -> m b",
    "Description": "Define the (>>) operator for any monad, taking two monadic values of types m a and m b respectively, and producing a monadic value of type m b."
  },
  {
    "Statement": "Nothing -> return Nothing",
    "Description": "If maybe_val is Nothing, return a failed IOMaybe computation by returning Nothing."
  },
  {
    "Statement": "toLowerString = map toLower",
    "Description": "Use the `map` function with `toLower` to convert each character in the input string to lowercase."
  },
  {
    "Statement": "showsPrec :: Int -> a -> ShowS",
    "Description": "Define a function 'showsPrec' within the 'Show' typeclass which takes an integer and a value of type 'a', and returns a 'ShowS' function."
  },
  {
    "Statement": "putStrLn \"Hello World\"",
    "Description": "Prints 'Hello World' to the console."
  },
  {
    "Statement": "add :: Int -> Int -> Int",
    "Description": "Define a function 'add' which takes two 'Int' arguments and returns an 'Int'."
  },
  {
    "Statement": "bubbleUp x (y:ys) | otherwise = x : y : ys",
    "Description": "Otherwise, prepend x and the head of the accumulator to the tail of the accumulator."
  },
  {
    "Statement": "quickSort [] = []",
    "Description": "If the input list is empty, return an empty list."
  },
  {
    "Statement": "instance Exception MyError",
    "Description": "Make the MyError data type an instance of the Exception class."
  },
  {
    "Statement": "stimes n (Any a) = Any (a || n)",
    "Description": "Define the 'stimes' function that takes an integer 'n' and an 'Any a' value, and returns a new 'Any' value where the wrapped value 'a' is 'OR'ed 'n' times."
  },
  {
    "Statement": "fromList:: forall a. (Linorder a) => [a] -> Tree a;",
    "Description": "Define a function 'fromList' which takes a list of 'a' and returns a 'Tree a'."
  },
  {
    "Statement": "bindIOM :: IOMaybe a -> (a -> IOMaybe b) -> IOMaybe b",
    "Description": "Define a function bindIOM that takes an IOMaybe computation and a function that takes a value of type a and returns an IOMaybe computation of type b, and returns a new IOMaybe computation of type b that combines the two computations."
  },
  {
    "Statement": "lookup :: Path -> Tree a -> Maybe (Tree a)",
    "Description": "Define a function 'lookup' that takes a path ('Path') and a tree ('Tree a'), and returns the subtree at that path, if it exists."
  },
  {
    "Statement": "prop xs = (length $ tail xs) == ((length xs) -1)",
    "Description": "Define a property named prop that checks if the length of the tail of a list xs is equal to the length of xs minus one."
  },
  {
    "Statement": "take' n xs = foldl' (\\acc x -> if length acc < n then acc ++ [x] else acc) [] xs",
    "Description": "The implementation of 'take'' uses 'foldl'' to fold the input list 'xs' using an anonymous function that appends the current element 'x' to the accumulator 'acc' if the length of 'acc' is less than 'n'. The initial accumulator is an empty list '[]'."
  },
  {
    "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
    "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
  },
  {
    "Statement": "import Data.List (permutations)\n\npermutations' :: [a] -> [[a]]",
    "Description": "Define a function 'permutations'' that takes a list of elements of any type 'a' and returns a list of all permutations of the input list. Import the 'permutations' function from the 'Data.List' module."
  },
  {
    "Statement": "name arg1 arg2 ... argn",
    "Description": "Define a function named 'name' with 'n' arguments 'arg1' to 'argn'."
  },
  {
    "Statement": "checkInput (x:_) = isUpper x",
    "Description": "If the input String is non-empty, check if the first character is an uppercase letter using the isUpper function, and return the result as a Bool."
  },
  {
    "Statement": "instance Semigroup (Any a) where",
    "Description": "Define a 'Semigroup' instance for the 'Any' data type."
  },
  {
    "Statement": "intersperse' :: a -> [a] -> [a]",
    "Description": "Define a function intersperse' that takes an element x and a list xs, and returns a new list where x is inserted between every pair of elements in xs."
  },
  {
    "Statement": "import Data.Char (isSpace, toLower)",
    "Description": "Import the 'isSpace' and 'toLower' functions from the Data.Char module."
  },
  {
    "Statement": "treeToSet Leaf = empty",
    "Description": "For an empty tree, return an empty set."
  },
  {
    "Statement": "deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]",
    "Description": "Define 'deleteFirstsBy' as a function which removes the first occurrence of each element in the second list from the first list, where equality is determined by the given predicate."
  },
  {
    "Statement": "[1,2,3,4,5]",
    "Description": "Define a list containing integers 1 through 5 using the cons operator (:)."
  },
  {
    "Statement": "by auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "in_range 0 5 3",
    "Description": "Check if the value 3 is within the range [0, 5]."
  },
  {
    "Statement": "calc (Div x y) = div x y",
    "Description": "Define the 'calc' function pattern matching on the 'Div' constructor, returning the division of 'x' by 'y'."
  },
  {
    "Statement": "unzip [] = ([], [])",
    "Description": "Define the base case of the unzip function where an empty list is given, it returns a pair of empty lists."
  },
  {
    "Statement": "delete' :: Eq a => a -> [a] -> [a]",
    "Description": "Define a function delete' that takes an element x and a list xs, and returns a new list with the first occurrence of x removed from xs."
  },
  {
    "Statement": "(Just v) -> f v",
    "Description": "If maybe_val is Just v, apply the function f to the value v and return the resulting IOMaybe computation."
  },
  {
    "Statement": "concat (xs:xss) = xs ++ concat xss",
    "Description": "Define the recursive case of the concat function where a non-empty list of lists is given. It concatenates the first list with the result of recursively concatenating the rest of the lists."
  },
  {
    "Statement": "sum :: Num p => [p] -> p",
    "Description": "sum is a function which takes a list of values of type 'p' belonging to the 'Num' typeclass and returns a single value of type 'p'."
  },
  {
    "Statement": "func x = if x == 0 then ( else f (x-1))",
    "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
  },
  {
    "Statement": "apply (induct t)",
    "Description": "Begin the proof by induction over tree t."
  },
  {
    "Statement": "(**) :: f a -> f b -> f (a,b)",
    "Description": "Declare the '(**)' operator signature for the 'Monoidal' type class, which takes two values of types 'f a' and 'f b', and returns a value of type 'f (a,b)' representing their monoidal product."
  },
  {
    "Statement": "shuffleString xs = do",
    "Description": "Begin the definition of the `shuffleString` function using the do notation for monadic computations."
  },
  {
    "Statement": "sum :: [Int] -> Int",
    "Description": "Define a function 'sum' that takes a list of integers and returns their sum."
  },
  {
    "Statement": "con \"reverseList\" (reverse :: [a] -> [a]),",
    "Description": "Include the 'reverseList' function signature."
  },
  {
    "Statement": "export_Statement insert fromList inorder in Haskell module_name SortedTreel",
    "Description": "Export the functions 'insert', 'fromList', and 'inorder' in Haskell module 'SortedTreel'."
  },
  {
    "Statement": "f = either (\\l -> \"Number\") (\\r -> r)",
    "Description": "Define a function 'f' which uses the 'either' function to map 'Left' values to 'Number' and 'Right' values to themselves."
  },
  {
    "Statement": "die :: String -> IO a",
    "Description": "Define a function 'die' which takes a string argument and performs an IO action that terminates the program with a failure status and prints the specified string as an error message."
  },
  {
    "Statement": "instance Monad IO",
    "Description": "Create an instance of the Monad typeclass for the IO data type, which represents computations that can perform side effects."
  },
  {
    "Statement": "instance Applicative ((->) r) where\n    pure = const\n    f <*> g = \\x -> f x (g x)\n    (*>) = (>>)\n    (<*) = const",
    "Description": "Provide an instance of the 'Applicative' type class for the function type constructor '(->) r'. This instance allows for applying and combining computations that take a value of type 'r' as input."
  },
  {
    "Statement": "import Data.List (foldl')\n\nreverse' :: [a] -> [a]",
    "Description": "Define a function 'reverse'' that takes a list of elements of any type 'a' and returns the reversed list. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "(+) :: Num a => a -> a -> a",
    "Description": "Define an operator '+' which takes two arguments of type 'a' belonging to the 'Num' typeclass and returns a value of the same type."
  },
  {
    "Statement": "getName :: IOMaybe String",
    "Description": "Define a function getName that returns an IOMaybe String."
  },
  {
    "Statement": "con \"[]\" ([] :: [A]),",
    "Description": "Declare the constant '[]' as an empty list."
  },
  {
    "Statement": "fibonacci :: Int -> Integer",
    "Description": "Define a function fibonacci that takes an Int and returns the nth Fibonacci number."
  },
  {
    "Statement": "by (metis inorder.simps (2) sorted_append)",
    "Description": "Use the given sorted lemma to solve the subgoal."
  },
  {
    "Statement": "con \"odd\" (odd :: Int -> Bool),",
    "Description": "Include the 'odd' function signature."
  },
  {
    "Statement": "data Calculation = Add Int Int | Sub Int Int | Mul Int Int | Div Int Int",
    "Description": "Define a datatype 'Calculation' with constructors 'Add', 'Sub', 'Mul', and 'Div', each taking two 'Int' arguments."
  },
  {
    "Statement": "where types = (x :: NonEmpty Int, y :: NonEmpty Int, z :: NonEmpty Int)",
    "Description": "Specify the types of 'x', 'y', and 'z' as 'NonEmpty' lists of integers for the 'prop' function."
  },
  {
    "Statement": "(-) :: a -> a -> a",
    "Description": "Define the subtraction operation '-' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
  },
  {
    "Statement": "exitWith :: ExitCode -> IO a",
    "Description": "Define a function 'exitWith' which takes an ExitCode and performs an IO action that terminates the program with the specified exit code."
  },
  {
    "Statement": "frequencies (x:xs) = insert x (1 + (maybe 0 id (lookup x m))) m",
    "Description": "For a non-empty list, 'frequencies' inserts the first element into the map, with its frequency being 1 plus the frequency of that element in the remaining elements (or 0 if it doesn't exist)."
  },
  {
    "Statement": "difference :: Set a -> Set a -> Set a",
    "Description": "Declare a function difference that returns the difference between two sets."
  },
  {
    "Statement": "mempty = All True",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'All a' as an 'All' value wrapping 'True'."
  },
  {
    "Statement": "length [] = 0",
    "Description": "Define the length of an empty list as 0."
  },
  {
    "Statement": "lemma tree_intersection:",
    "Description": "Define a lemma named tree_intersection."
  },
  {
    "Statement": "main = Lib.helloworld",
    "Description": "Call the 'helloworld' function from 'Lib' when 'main' is executed."
  },
  {
    "Statement": "in_range min max x = x >= min && x <= max",
    "Description": "Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'. It returns true if 'x' is within the range [min, max] (inclusive), otherwise false."
  },
  {
    "Statement": "stimes n (Product a) = Product (a ^ n)",
    "Description": "Define the 'stimes' function that takes an integer 'n' and a 'Product a' value, and returns a new 'Product' value where the wrapped value 'a' is raised to the power of 'n'."
  },
  {
    "Statement": "partition' :: (a -> Bool) -> [a] -> ([a], [a])",
    "Description": "Define a function partition' that takes a predicate p and a list xs, and returns a pair of lists, where the first list contains all elements of xs that satisfy p, and the second list contains all elements that do not satisfy p."
  },
  {
    "Statement": "calc :: Calculation -> Int",
    "Description": "Define a function 'calc' which takes a 'Calculation' and returns an 'Int'."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "instance ArrowApply (->) where\n  app (f, x) = f x\n\ninstance Monad m => ArrowApply (Kleisli m) where\n  app = Kleisli (\\(Kleisli f, x) -> f x)",
    "Description": "Provide instances of the 'ArrowApply' type class for the function type constructor '(->) a b' and the 'Kleisli' newtype, assuming that 'm' is an instance of the 'Monad' type class."
  },
  {
    "Statement": "sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a",
    "Description": "Declare a function sortBy that sorts the elements of a sequence using a custom comparison function."
  },
  {
    "Statement": "import Data. List hiding ( insert )",
    "Description": "Import the Data.List module and hide the 'insert' function."
  },
  {
    "Statement": "readUntilWithCount :: String -> IO Int",
    "Description": "Declare a function readUntilWithCount that takes a String argument and returns an IO Int value."
  },
  {
    "Statement": "preOrder (Node x l r) = [x] ++ preOrder l ++ preOrder r",
    "Description": "Otherwise, return the concatenation of a singleton list containing the value at the root, the pre-order traversal of the left subtree, and the pre-order traversal of the right subtree."
  },
  {
    "Statement": "(<**>) mf mx = fmap (\\(f,x) -> f x) (mf ** mx)",
    "Description": "Define the '(<**>)' operator for the 'Monoidal' type class by applying the functions in 'mf' to the values in 'mx' using the '(**)' operator and 'fmap'."
  },
  {
    "Statement": "import Data.List (subsequences)\n\nsubsequences' :: [a] -> [[a]]",
    "Description": "Define a function 'subsequences'' that takes a list of elements of any type 'a' and returns a list of all subsequences (segments in any order) of the input list, including the empty list and the input list itself. Import the 'subsequences' function from the 'Data.List' module."
  },
  {
    "Statement": "    | otherwise = (ys, x:zs)",
    "Description": "Define the condition for the recursive case of the partition function. If the predicate 'p' is not satisfied by the current element 'x', it is added to the second component of the resulting pair."
  },
  {
    "Statement": "con \"lowercase\" (map toLower :: String -> String),",
    "Description": "Include the 'lowercase' function signature."
  },
  {
    "Statement": "import Data.Graph (Graph, buildG, topSort)",
    "Description": "Import the 'Graph' data type and related functions from the 'Data.Graph' module, which provides graph data structures and algorithms."
  },
  {
    "Statement": "hn = n",
    "Description": "Assign `hn` the value of `n`."
  },
  {
    "Statement": "class Functor f => Monoidal f where",
    "Description": "Define a type class 'Monoidal' with a superclass constraint 'Functor f', representing monoidal functors."
  },
  {
    "Statement": "subsequences' = subsequences",
    "Description": "The implementation of 'subsequences'' simply applies the 'subsequences' function to the input list."
  },
  {
    "Statement": "if checkInput input",
    "Description": "Check if the input is valid using the checkInput function."
  },
  {
    "Statement": "(Sum 500) <> (Sum 400) <> (Sum 100)",
    "Description": "Compute the result of combining three Sum values using the Semigroup (<>) operation, which should be Sum {getSum = 1000}."
  },
  {
    "Statement": "product' :: Num a => [a] -> a",
    "Description": "Define a function product' that takes a list of numbers and returns the product of all the numbers in the list."
  },
  {
    "Statement": "filter (\\(x,y) -> x/=y) [(1,2), (2,2)]",
    "Description": "Filter the list of tuples [(1,2), (2,2)] using the predicate function ((x,y) -> x/=y), resulting in [(1,2)]."
  },
  {
    "Statement": "groupBy :: (a -> a -> Bool) -> Seq a -> Seq (Seq a)",
    "Description": "Declare a function groupBy that groups elements in a sequence using a custom equality function."
  },
  {
    "Statement": "cycle xs = xs ++ cycle xs",
    "Description": "Otherwise, concatenate the list with itself infinitely."
  },
  {
    "Statement": "lift2 :: ( a -> b -> c ) -> (f a -> f b -> f c )",
    "Description": "Declare the 'lift2' function signature, which takes a binary function '(a -> b -> c)' and returns a function that lifts the binary function to operate on values of types 'f a' and 'f b', returning a value of type 'f c'."
  },
  {
    "Statement": "delete :: a -> Set a -> Set a",
    "Description": "Declare a function delete that removes an element from a set."
  },
  {
    "Statement": "con \"inorder\" (inorder :: Tree OrdA -> [OrdA]),",
    "Description": "Include the 'inorder' function signature in 'treesig2'."
  },
  {
    "Statement": "(1,2) :: (Int, Int)",
    "Description": "Represent a tuple containing two integers."
  },
  {
    "Statement": "lines' :: String -> [String]",
    "Description": "Define a function lines' that takes a string s and returns a list of strings by splitting s at newline characters."
  },
  {
    "Statement": "instance Num a => Semigroup (Sum a) where\n  (<>) = coerce ((+) :: a -> a -> a)\n  stimes n (Sum a) = Sum (fromIntegral n * a)",
    "Description": "Provide an instance of Semigroup for the Sum data type, where the (<>) operation is defined as the addition of the wrapped values, and stimes is defined as scalar multiplication of the wrapped value by an integer."
  },
  {
    "Statement": "partition p (x:xs)",
    "Description": "Define the recursive case of the partition function where a non-empty list is given. It separates the list into two lists: one containing the elements that satisfy the predicate and the other containing the elements that do not."
  },
  {
    "Statement": "con \"factorial\" (factorial :: Int -> Int),",
    "Description": "Include the 'factorial' function signature."
  },
  {
    "Statement": "app f x = f x",
    "Description": "Implement the 'app' function by applying the function 'f' to the value 'x'."
  },
  {
    "Statement": "newtype StateT s (m :: * -> *) a",
    "Description": "Declare a new type constructor `StateT` that represents a state transformer monad, parameterized by the state type `s`, a base monad `m`, and the result type `a`."
  },
  {
    "Statement": "\"shows 'sorted (inorder l @ [v] @ inorder r)'\"",
    "Description": "Show that the inorder traversal of l, followed by v, followed by the inorder traversal of r, is sorted."
  },
  {
    "Statement": "instance Semigroup (Last a) where",
    "Description": "Define a 'Semigroup' instance for the 'Last' data type."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "height Leaf = 0",
    "Description": "If the input tree is Leaf, return 0."
  },
  {
    "Statement": "instance Num a => Monoid (Sum a) where\n  mempty = Sum 0",
    "Description": "Provide an instance of Monoid for the Sum data type, where the mempty is the Sum wrapping 0."
  },
  {
    "Statement": "\"sortedT t At = (Node l v r) → sortedT 1 A sortedT r\"",
    "Description": "If the tree `t` is sorted, then for every `Node l v r`, `l` and `r` are sorted."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "returnIOM :: a -> IOMaybe a",
    "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
  },
  {
    "Statement": "where",
    "Description": "Begin the definition of helper functions for 'trim'."
  },
  {
    "Statement": "| × < y = Z",
    "Description": "If `x * y` is less than `y`, return `Z`."
  },
  {
    "Statement": "input <- lift getLine",
    "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "else readUntil ending",
    "Description": "If the input is not the ending string, recursively call readUntil with the ending string."
  },
  {
    "Statement": "fac n | n <= 1  =1 | otherwise = n * fac (n-1)",
    "Description": "Define a function 'fac' that calculates the factorial of 'n'. If 'n' is less than or equal to 1, return 1; otherwise, return 'n' multiplied by the factorial of 'n-1'."
  },
  {
    "Statement": "main :: IO ()",
    "Description": "Define the 'main' function."
  },
  {
    "Statement": "input <- liftIO getLine",
    "Description": "Read a line of input from the user within the `IO` monad, lifted into the `StateT` monad using `liftIO`."
  },
  {
    "Statement": "map2D :: (a -> b) -> [[a]] -> [[b]]",
    "Description": "Declare 'map2D' as a function taking a function from 'a' to 'b' and a list of lists of 'a's, returning a list of lists of 'b's."
  },
  {
    "Statement": "    | y == x = Just 0",
    "Description": "Define the condition for the recursive case of the elemIndex function. If the element 'y' is equal to the current element 'x', it returns Just 0."
  },
  {
    "Statement": "treeToSet :: Ord a => Tree a -> Set a",
    "Description": "Define a function 'treeToSet' that converts a binary tree of type 'Tree a' into a set ('Set a'), assuming the type 'a' is an instance of the 'Ord' class."
  },
  {
    "Statement": "quickSort :: Ord a => [a] -> [a]",
    "Description": "Define a function named quickSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
  },
  {
    "Statement": "apply (simp add: sizeT_append)",
    "Description": "Apply the simp tactic with the additional information sizeT_append."
  },
  {
    "Statement": "apply blast",
    "Description": "Use the blast tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "data MyError = ErrorA | ErrorB deriving Show",
    "Description": "Define a data type MyError with two constructors ErrorA and ErrorB, and derive the Show instance for it."
  },
  {
    "Statement": "func :: Int -> Int",
    "Description": "Define a function named `func` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "lookup p (Node _ m) = M.lookup p m",
    "Description": "For a non-leaf node, look up the path in the map and return the corresponding subtree, if it exists."
  },
  {
    "Statement": "foldl1 :: (a -> a -> a) -> Seq a -> a",
    "Description": "Declare a function foldl1 that folds a non-empty sequence from the left with a binary function."
  },
  {
    "Statement": "takeMVar :: MVar a -> IO a",
    "Description": "Take the value from the given MVar, blocking until a value is available."
  },
  {
    "Statement": "instance Monad m => Arrow (Kleisli m) where\n  arr f = Kleisli (return . f)\n  first (Kleisli f) = Kleisli (\\ -(b,d) -> f b >>= \\c -> return (c, d))\n  second (Kleisli f) = Kleisli (\\ -(d,b) -> f b >>= \\c -> return (d, c))\n  (***) = ...",
    "Description": "Provide an instance of the 'Arrow' type class for the 'Kleisli' newtype, assuming that 'm' is an instance of the 'Monad' type class. The instance defines the 'arr', 'first', 'second', and '***' methods for 'Kleisli' arrows."
  },
  {
    "Statement": "splitAt' :: Int -> [a] -> ([a], [a])",
    "Description": "Define a function splitAt' that takes an integer n and a list xs, and returns a pair of lists, where the first list contains the first n elements of xs, and the second list contains the remaining elements."
  },
  {
    "Statement": "module SortingAlgorithms",
    "Description": "Define a module named SortingAlgorithms."
  },
  {
    "Statement": "map f = foldr ((:) . f) []",
    "Description": "Define 'map' as a fold operation that applies function 'f' to each element of the list and constructs a new list."
  },
  {
    "Statement": "instance Semigroup (First a) where",
    "Description": "Define a 'Semigroup' instance for the 'First' data type."
  },
  {
    "Statement": "filterString = filter isAlpha",
    "Description": "Use the `filter` function with `isAlpha` to remove non-alphabetic characters from the input string."
  },
  {
    "Statement": "cycle :: [a] -> [a]",
    "Description": "Define a function named `cycle` which takes a list of any type and returns a list of the same type."
  },
  {
    "Statement": "else readUntil ending",
    "Description": "If the input is not the ending string, recursively call readUntil with the ending string."
  },
  {
    "Statement": "readUntilWithState ending = execStateT (aux ending) 0",
    "Description": "Define the implementation of readUntilWithState by calling execStateT with the auxiliary function aux (using the ending string as an argument) and an initial state of 0."
  },
  {
    "Statement": "liftIOm io :: io >>= retrunIOM",
    "Description": "Define liftIOm io as io >>= returnIOM."
  },
  {
    "Statement": "con \"imagPart\" (imagPart :: Complex Float -> Float),",
    "Description": "Include the 'imagPart' function signature in 'complexSig'."
  },
  {
    "Statement": "\"assumes 'sortedT r'\"",
    "Description": "Assume that r is sorted."
  },
  {
    "Statement": "import Data.Char (isSpace)\n\nsplitWords :: String -> [String]",
    "Description": "Define a function 'splitWords' that takes a string and returns a list of words (substrings separated by whitespace). Import the 'isSpace' function from the 'Data.Char' module."
  },
  {
    "Statement": "foldr' :: (a -> b -> b) -> b -> Seq a -> b",
    "Description": "Declare a function foldr' that folds a sequence strictly from the right with a binary function."
  },
  {
    "Statement": "z = func3 arg",
    "Description": "Define a variable 'z' which is assigned the result of calling function 'func3' with argument 'arg'."
  },
  {
    "Statement": "words' :: String -> [String]",
    "Description": "Define a function words' that takes a string s and returns a list of words by splitting s at whitespace characters."
  },
  {
    "Statement": "func x = if x == 0 then ( else f (x-1))",
    "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
  },
  {
    "Statement": "con \"removeDuplicates\" (nub :: Eq a => [a] -> [a]),",
    "Description": "Include the 'removeDuplicates' function signature."
  },
  {
    "Statement": "instance Semigroup a => Semigroup (Dual a) where",
    "Description": "Define a 'Semigroup' instance for the 'Dual' data type, constrained by the 'Semigroup' instance of the inner type 'a'."
  },
  {
    "Statement": "p n= n≥ 0",
    "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
  },
  {
    "Statement": "length :: List a -> Int",
    "Description": "Define a function named length which takes a List of elements of type a and returns the length of the list as an Int."
  },
  {
    "Statement": "con \"isEmpty\" (null :: [a] -> Bool),",
    "Description": "Include the 'isEmpty' function signature."
  },
  {
    "Statement": "foldr1' :: (a -> a -> a) -> Seq a -> a",
    "Description": "Declare a function foldr1' that folds a non-empty sequence strictly from the right with a binary function."
  },
  {
    "Statement": "mempty = Endo id",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Endo a' as an 'Endo' value wrapping the 'id' function."
  },
  {
    "Statement": "unfoldr f b = case f b of",
    "Description": "Define the 'unfoldr' function with the initial seed value 'b'. It applies the function 'f' to the seed value and processes the result."
  },
  {
    "Statement": "fac n = if n <= 1 then 1 else n * fac (n-1)",
    "Description": "Define a recursive function 'fac' that calculates the factorial of 'n'. If 'n' is less than or equal to 1, return 1; otherwise, return 'n' multiplied by the factorial of 'n-1'."
  },
  {
    "Statement": "    | otherwise = []",
    "Description": "Define the condition for the recursive case of the takeWhile function. If the predicate 'p' does not hold true for the current element 'x', it terminates the list."
  },
  {
    "Statement": "fst :: (a,b) -> a",
    "Description": "Return the first element of a tuple."
  },
  {
    "Statement": "f c acc@(x:xs) | isSpace c = []:acc",
    "Description": "If the current character is whitespace, 'f' starts a new substring in the accumulator."
  },
  {
    "Statement": "mempty = Last Nothing",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'Last a' as a 'Last' value wrapping 'Nothing'."
  },
  {
    "Statement": "sorted [] = True",
    "Description": "If the list is empty, return True."
  },
  {
    "Statement": "isEven n",
    "Description": "Define `isEven` with parameter `n`."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "import Data.List (drop, take)\n\nsplitAt :: Int -> [a] -> ([a], [a])",
    "Description": "Define a function 'splitAt' that takes an index and a list of elements of any type 'a', and returns a tuple containing two lists: the first list contains the elements up to (but not including) the given index, and the second list contains the remaining elements. Import the 'drop' and 'take' functions from the 'Data.List' module."
  },
  {
    "Statement": "..."
  },
  {
    "Statement": "reverse :: List a -> List a",
    "Description": "Define a function named reverse which takes a List of elements of type a and returns a List of the same type with the elements in reverse order."
  },
  {
    "Statement": "replicate :: Int -> a -> [a]",
    "Description": "Define a function named `replicate` which takes an `Int`, a value of any type, and returns a list of that type."
  },
  {
    "Statement": "main = Lib.helloworld",
    "Description": "Call the 'helloworld' function from 'Lib' when 'main' is executed."
  },
  {
    "Statement": "sum' :: Num a => [a] -> a",
    "Description": "Define a function sum' that takes a list of numbers and returns the sum of all the numbers in the list."
  },
  {
    "Statement": "then returnIOM input",
    "Description": "If the condition is satisfied, return the input wrapped in a Just constructor using returnIOM."
  },
  {
    "Statement": "Nothing >>= _ = Nothing",
    "Description": "If the input to the bind operation is Nothing, return Nothing."
  },
  {
    "Statement": "put :: s -> m ()",
    "Description": "Declare a function `put` that takes a new state value and updates the current state within the base monad `m`."
  },
  {
    "Statement": "name <- getLine",
    "Description": "Read a line of input from the user and bind it to name."
  },
  {
    "Statement": "drop' n xs = foldl' (\\acc x -> if n == 0 then acc ++ [x] else acc) [] xs",
    "Description": "The implementation of 'drop'' uses 'foldl'' to fold the input list 'xs' using an anonymous function that appends the current element 'x' to the accumulator 'acc' if 'n' is equal to 0. The initial accumulator is an empty list '[]'."
  },
  {
    "Statement": "func :: Int -> Int -> Int -> Int",
    "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
  },
  {
    "Statement": "insert x [] = [x]",
    "Description": "If the input list is empty, return a singleton list containing x."
  },
  {
    "Statement": "datatype 'a Tree = Leaf | Node \"'a Tree\" 'a \"'a Tree\"",
    "Description": "Define a datatype named `Tree` that takes a type parameter `'a`."
  },
  {
    "Statement": "where types = (x :: [Int], y :: [Int])",
    "Description": "Specify the types of 'x' and 'y' as lists of integers for the 'prop' function."
  },
  {
    "Statement": "con \":>\" ((>) :: Int -> Int -> Bool),",
    "Description": "Include the ':>' operator signature."
  },
  {
    "Statement": "try :: Exception e => IO a -> IO (Either e a)",
    "Description": "Create an IO action that attempts to run the given IO action, returning either an exception of type e or the result of type a, wrapped in the Either data type."
  },
  {
    "Statement": "returnIOM = return . Just",
    "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
  },
  {
    "Statement": "proof (induction xs arbitrary: P)",
    "Description": "Apply induction on the list with an arbitrary predicate `P`."
  },
  {
    "Statement": "take :: Int -> [a] -> [a]",
    "Description": "Define a function named `take` which takes an `Int` and a list of any type and returns a list of the same type."
  },
  {
    "Statement": "returnIOM = return . Just",
    "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
  },
  {
    "Statement": "Nothing -> return Nothing",
    "Description": "If maybe_val is Nothing, return Nothing."
  },
  {
    "Statement": "complexSig = [",
    "Description": "Assign the following list of Sig to 'complexSig'."
  },
  {
    "Statement": "split :: String -> [String]",
    "Description": "Define a function 'split' that takes a string and returns a list of substrings separated by whitespace."
  },
  {
    "Statement": "newtype All a = All { getAll :: a }",
    "Description": "Define a new data type called 'All' with a single constructor 'All' that wraps a value of type 'a'. The 'getAll' function extracts the value of type 'a' from the 'All' constructor."
  },
  {
    "Statement": "    | p x = dropWhile p xs",
    "Description": "Define the condition for the recursive case of the dropWhile function. If the predicate 'p' holds true for the current element 'x', it recursively processes the rest of the list."
  },
  {
    "Statement": "zip [] _ = []",
    "Description": "If the first list is empty, return an empty list."
  },
  {
    "Statement": "import Data.Sequence (Seq, empty, singleton, viewl, viewr, (><))",
    "Description": "Import the 'Seq' data type and related functions from the 'Data.Sequence' module, which provides a finger-tree-based sequence data structure."
  },
  {
    "Statement": "fibonacci 1 = 1",
    "Description": "The Fibonacci of 1 is 1."
  },
  {
    "Statement": "concat' :: [[a]] -> [a]",
    "Description": "Define a function concat' that takes a list of lists xss, and returns a new list containing the elements of all the lists in xss concatenated together."
  },
  {
    "Statement": "cross = (,)",
    "Description": "Implement the 'cross' function using the tuple constructor '(,)'."
  },
  {
    "Statement": "else aux ending ncount",
    "Description": "If the input string is not equal to the ending string, recursively call aux with the ending string and the new count."
  },
  {
    "Statement": "apply blast",
    "Description": "Use the blast tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "import Control.Exception",
    "Description": "Import the Control.Exception module."
  },
  {
    "Statement": "con \"deleteAt\" (delete :: Eq a => a -> [a] -> [a]),",
    "Description": "Include the 'deleteAt' function signature."
  },
  {
    "Statement": "maybeadd mx y = mx >>= (\\x -> Just $ x+y)",
    "Description": "Use bind operator `(>>=)` to extract the value from `mx`, adds `y` to it, and wraps the result in a Just context."
  },
  {
    "Statement": "checkInput [] = False",
    "Description": "If the input string is empty, return False."
  },
  {
    "Statement": "import qualified Module",
    "Description": "Imports all entities from the module 'Module' but qualifies them with the module name, so they need to be accessed using the module name prefix."
  },
  {
    "Statement": "instance Monoidal [] where",
    "Description": "Define a 'Monoidal' instance for the list type constructor '[]'."
  },
  {
    "Statement": "reverseString = reverse",
    "Description": "Use the `reverse` function to reverse the input string."
  },
  {
    "Statement": "bindIOM iom f = do",
    "Description": "Begin the definition of bindIOM by using a do block."
  },
  {
    "Statement": "toUpperCase = map toUpper",
    "Description": "Use the `map` function with `toUpper` to convert each character in the input string to uppercase."
  },
  {
    "Statement": "length :: Seq a -> Int",
    "Description": "Declare a function length that returns the length of a sequence."
  },
  {
    "Statement": "maximum :: Ord a => Seq a -> a",
    "Description": "Declare a function maximum that returns the maximum element of a sequence."
  },
  {
    "Statement": "return x = Cons x Nil",
    "Description": "Define the return function for the List monad, which creates a singleton list containing the input value."
  },
  {
    "Statement": "return y;",
    "Description": "Return the value of 'y' if 'z' is false."
  },
  {
    "Statement": "(<>) a _ = a",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Last a' to handle the case where the last value is 'Nothing'."
  },
  {
    "Statement": "either :: (a ->c) -> (b -> c) -> Either a b -> c",
    "Description": "Define the 'either' function which takes two functions and an 'Either' value, applies the first function to the 'Left' value or the second function to the 'Right' value, and returns the result."
  },
  {
    "Statement": "return x = Cons x Nil",
    "Description": "Define the return function for the List monad, which creates a singleton list containing the input value."
  },
  {
    "Statement": "return ncount",
    "Description": "If the input string is equal to the ending string, return the final count."
  },
  {
    "Statement": "checkInput :: String -> Bool",
    "Description": "Define a function checkInput that takes a String and returns a Bool."
  },
  {
    "Statement": "con \"tailElements\" (tail :: [a] -> [a]),",
    "Description": "Include the 'tailElements' function signature."
  },
  {
    "Statement": "replicate :: Int -> a -> Seq a",
    "Description": "Declare a function replicate that creates a sequence with a specified length and the same value repeated."
  },
  {
    "Statement": "instance Monoid w => Monad ((,) w) where\n    return x = (mempty, x)\n    (u, a) >>= k = let (v, b) = k a in (u `mappend` v, b)\n    (>>) = (*>)",
    "Description": "Provide an instance of the 'Monad' type class for the tuple type constructor '(,) w', assuming that 'w' is an instance of the 'Monoid' type class. This instance allows for sequencing and combining computations."
  },
  {
    "Statement": "lemma filter_contains: \"contains P (filter Q xs) ⟷ (contains (λx. Q x ∧ P x) xs)\"",
    "Description": "Define a lemma asserting that `P` holds for an element in the filtered list if and only if `Q` holds for that element in the original list."
  },
  {
    "Statement": "maybeadd (Just 2) (Just 1)",
    "Description": "Applly `maybeadd` function with `Just 2` and `Just 1`, resulting in Just 3."
  },
  {
    "Statement": "apply (induction t)",
    "Description": "Begin the proof by induction over tree t."
  },
  {
    "Statement": "return ncount",
    "Description": "If the input string is equal to the ending string, return the final count."
  },
  {
    "Statement": "notElem :: Eq a => a -> Seq a -> Bool",
    "Description": "Declare a function notElem that checks if an element is not in a sequence."
  },
  {
    "Statement": "isPalindrome :: String -> Bool",
    "Description": "Define a function isPalindrome that takes a String and returns True if it's a palindrome, otherwise False."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "int y = func2 (arg);",
    "Description": "Define a variable 'y' of type integer which is assigned the result of calling function 'func2' with argument 'arg'."
  },
  {
    "Statement": "greet :: Person -> String",
    "Description": "Define a function 'greet' which takes a 'Person' and returns a greeting string."
  },
  {
    "Statement": "any' :: (a -> Bool) -> [a] -> Bool",
    "Description": "Define a function any' that takes a predicate p and a list xs, and returns True if at least one element of xs satisfies the predicate p, otherwise False."
  },
  {
    "Statement": "func :: Int -> Int -> Int -> Int",
    "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
  },
  {
    "Statement": "class Applicative m => Monad (m :: * -> *) where\n    (>>=) :: m a -> (a -> m b) -> m b\n    (>>) :: m a -> m b -> m b\n    return :: a -> m a",
    "Description": "Define a type class 'Monad' parameterized by 'm', which must be an instance of the 'Applicative' type class. The 'Monad' class specifies methods '>>=', '>>', and 'return' for sequencing and combining computations."
  },
  {
    "Statement": "n == 0 =1",
    "Description": "If `n` is equal to 0, return 1."
  },
  {
    "Statement": "sum (x:xs) = x + sum xs",
    "Description": "Define the recursive case of the sum function where a non-empty list is given. It adds the first element 'x' to the result of recursively summing the rest of the list 'xs'."
  },
  {
    "Statement": "con \":<\" ((<) :: Int -> Int -> Bool),",
    "Description": "Include the ':<' operator signature."
  },
  {
    "Statement": "instance Num a => Monoid (Product a) where",
    "Description": "Define a 'Monoid' instance for the 'Product' data type, constrained by the 'Num' type class constraint on 'a'."
  },
  {
    "Statement": "topMost (TreeZipper t _ _) = t",
    "Description": "Implement 'topMost' by extracting the current subtree from the 'TreeZipper a' data structure."
  },
  {
    "Statement": "bindIOM iom f = do",
    "Description": "Begin the definition of bindIOM by using a do block."
  },
  {
    "Statement": "reverse [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "takeWhile :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function named `takeWhile` which takes a function and a list and returns a list."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "runEval $ do\n  a <- rpar (f x)\n  b <- rseq (f y)\n  rseq a\n  rseq b\n  return (a,b)",
    "Description": "Run a parallel computation that evaluates (f x) and (f y) in parallel, and returns a pair (a, b) where a and b are the results of the parallel computations."
  },
  {
    "Statement": "[1,2,3,4,5] :: [Integer]",
    "Description": "Define a list containing integers 1 through 5."
  },
  {
    "Statement": "removeDuplicates = nub",
    "Description": "The implementation of 'removeDuplicates' simply applies the 'nub' function, which removes duplicate elements from the input list."
  },
  {
    "Statement": "greet :: IO ()",
    "Description": "Declares a function 'greet' that performs IO actions."
  },
  {
    "Statement": "inOrder :: Tree a -> [a]",
    "Description": "Define a function named inOrder which takes a Tree of elements of type a and returns a list of the elements in in-order traversal order."
  },
  {
    "Statement": "add x = (\\y -> x+y)",
    "Description": "Define the 'add' function where it partially applies 'x' to a lambda function taking 'y' as argument, returning their sum."
  },
  {
    "Statement": "hw = putStrLn \"Hello World\"",
    "Description": "Define a function 'hw' that prints 'Hello World' to the console when called."
  },
  {
    "Statement": "sum (x:xs) = x + sum xs",
    "Description": "Define the recursive case of the sum function where a non-empty list is given. It adds the first element 'x' to the result of recursively summing the rest of the list 'xs'."
  },
  {
    "Statement": "dropWhile p xs",
    "Description": "Drop elements from the list as long as the predicate `p` holds true."
  },
  {
    "Statement": "reverse (x:xs) = reverse xs ++ [x]",
    "Description": "Otherwise, reverse the rest of the list and append the first element."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}",
    "Description": "Define a new type 'Kleisli' parameterized by 'm', 'a', and 'b'. 'Kleisli' is a newtype wrapper around a function 'a -> m b', where 'm' is a monad."
  },
  {
    "Statement": "fromMaybe :: a -> Maybe a  -> a",
    "Description": "Define a function 'fromMaybe' which takes a default value and a 'Maybe' value. If the 'Maybe' value is 'Just', it returns the contained value, otherwise it returns the default value."
  },
  {
    "Statement": "less :: a →> a -> Bool;",
    "Description": "Define 'less' as a function which takes two arguments of type 'a' and returns a Bool."
  },
  {
    "Statement": "unzip :: Seq (a, b) -> (Seq a, Seq b)",
    "Description": "Declare a function unzip that splits a sequence of pairs into two sequences."
  },
  {
    "Statement": "unzip [] = ([], [])",
    "Description": "If the list is empty, return a pair of empty lists."
  },
  {
    "Statement": "sum = foldr (+) 0",
    "Description": "Define 'sum' as a fold operation using the '+' operator and starting with an initial accumulator of '0'."
  },
  {
    "Statement": "quickSort [] = []",
    "Description": "If the input list is empty, return an empty list."
  },
  {
    "Statement": "deriving (Eq, Ord, ..... )",
    "Description": "Derive instances of various type classes (such as 'Eq', 'Ord', etc.) for the 'Product' data type."
  },
  {
    "Statement": "(>>>=) = bindIOM",
    "Description": "Define the (>>>=) operator as bindIOM."
  },
  {
    "Statement": "someAction = do ... ... ... return $! f x",
    "Description": "Perform some actions, and then evaluate the result of f x strictly before returning it."
  },
  {
    "Statement": "have \"insert v (Node l tv r) = Node (insert v l) tv r\" by (simp add: True)",
    "Description": "then prove the equation 'insert v (Node l tv r) = Node (insert v l) tv r'."
  },
  {
    "Statement": "isPrefixOf [] _ = True",
    "Description": "Define the case of the isPrefixOf function where the first list is empty, it returns True."
  },
  {
    "Statement": "hw :: IO ()",
    "Description": "Declares the type of 'hw' as IO action that returns nothing."
  },
  {
    "Statement": "insert' :: Ord a => a -> [a] -> [a]",
    "Description": "Define a function insert' that takes an element x and a sorted list xs, and returns a new sorted list with x inserted into xs, maintaining the ordering."
  },
  {
    "Statement": "lemma contains_append: \"contains P (xs @ ys) ⟷ (contains P xs) ∨ (contains P ys)\"",
    "Description": "Define a lemma asserting that `P` holds for an element in the concatenated list if and only if `P` holds for an element in either of the original lists."
  },
  {
    "Statement": "    | otherwise = x : delete y xs",
    "Description": "Define the condition for the recursive case of the delete function. If the element 'y' is not equal to the current element 'x', it keeps the current element and recursively processes the rest of the list."
  },
  {
    "Statement": "endsWith :: Eq a => [a] -> [a] -> Bool",
    "Description": "Define a function 'endsWith' that takes two lists of elements of type"
  },
  {
    "Statement": "instance ArrowApply (->) where\n  app (f, x) = f x\n\ninstance Monad m => ArrowApply (Kleisli m) where\n  app = Kleisli (\\(Kleisli f, x) -> f x)",
    "Description": "Provide instances of the 'ArrowApply' type class for the function type constructor '(->) a b' and the 'Kleisli' newtype, assuming that 'm' is an instance of the 'Monad' type class."
  },
  {
    "Statement": "con \"isElement\" (elem :: Eq a => a -> [a] -> Bool),",
    "Description": "Include the 'isElement' function signature."
  },
  {
    "Statement": "in_range min max x =",
    "Description": "Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x'."
  },
  {
    "Statement": "name :: <type>",
    "Description": "Declare the type signature of a value or function named 'name' as '<type>'."
  },
  {
    "Statement": "treesig2 :: [Sig)",
    "Description": "Define 'treesig2' as a list of Sig."
  },
  {
    "Statement": "scanl :: (a -> b -> a) -> a -> Seq b -> Seq a",
    "Description": "Declare a function scanl that scans a sequence from the left with a binary function."
  },
  {
    "Statement": "func x = if x == 0 then ( else f (x-1))",
    "Description": "Define `func` to return `f (x-1)` if `x` is equal to 0."
  },
  {
    "Statement": "unlines (l:ls) = l ++ \"\\n\" ++ unlines ls",
    "Description": "Define the recursive case of the unlines function where a non-empty list is given. It joins the first line with a newline and then recursively processes the rest of the list."
  },
  {
    "Statement": "con \"logicalNot\" (not :: Bool -> Bool),",
    "Description": "Include the 'logicalNot' function signature."
  },
  {
    "Statement": "ones = 1 : 1 : ones",
    "Description": "Define an infinite list named ones where the first two elements are both 1, followed by itself, creating an infinite cycle."
  },
  {
    "Statement": "getName = do",
    "Description": "Begin the definition of the `getName` function using the do notation for monadic computations."
  },
  {
    "Statement": "unlines :: [String] -> String",
    "Description": "Define 'unlines' as a function which joins lines, after appending a terminating newline to each."
  },
  {
    "Statement": "unwords (w:ws) = w ++ \" \" ++ unwords ws",
    "Description": "Define the recursive case of the unwords function where a list of words is given. It joins the first word with a space and then recursively processes the rest of the list."
  },
  {
    "Statement": "isNumeric = all isDigit",
    "Description": "Define 'isNumeric' as the composition of the 'all' function (which checks if a predicate holds for all elements of a list) and the 'isDigit' function (which checks if a character is a digit)."
  },
  {
    "Statement": "newtype NonEmpty a = NonEmpty { getNonEmpty :: (a, [a]) }",
    "Description": "Define a new data type called 'NonEmpty' with a single constructor 'NonEmpty' that wraps a tuple containing a value of type 'a' and a list of type '[a]'. The 'getNonEmpty' function extracts the tuple from the 'NonEmpty' constructor."
  },
  {
    "Statement": "fromList (x : xs) = insert x (fromList xs) ;",
    "Description": "Insert each element of the list into the tree."
  },
  {
    "Statement": "import Data.List (foldl')\n\nand' :: [Bool] -> Bool",
    "Description": "Define a function 'and'' that takes a list of boolean values and returns their logical conjunction (AND). Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "proof (induction xs arbitrary: n)",
    "Description": "Apply induction on the list with an arbitrary number `n`."
  },
  {
    "Statement": "find :: (a -> Bool) -> [a] -> Maybe a",
    "Description": "Define 'find' as a function which finds the first element in the list that satisfies the predicate."
  },
  {
    "Statement": "liftIOm :: IO a -> IOMaybe a",
    "Description": "Define a function liftIOm that takes an IO computation and lifts it into the IOMaybe context, allowing for side effects while still preserving the possibility of failure."
  },
  {
    "Statement": "(==) (F f) (C c) = (1.8c + 32) == f",
    "Description": "Define the equality operator '==' for comparing a temperature in Fahrenheit with a temperature in Celsius. It returns true if the Celsius temperature, when converted to Fahrenheit, is equal to the given Fahrenheit temperature."
  },
  {
    "Statement": "else return Nothing",
    "Description": "If the input is not valid, return a failed IOMaybe computation by returning Nothing."
  },
  {
    "Statement": "fun fromList :: \"('a :: linorder) list → 'a Tree\"",
    "Description": "Define a function named `fromList` which takes a list of type `('a :: linorder)` and returns a `Tree 'a`."
  },
  {
    "Statement": "lemma setT insert: \"setT (insert v t) = setT t U {v}\"",
    "Description": "Define a lemma asserting the set of a tree after inserting v is equal to the set of the original tree unioned with {v}."
  },
  {
    "Statement": "instance MonadFix m => MonadFix (ReaderT r m) where\n    mfix f = ReaderT $ \\r -> mfix (\\a -> runReaderT (f a) r)",
    "Description": "Provide an instance of the 'MonadFix' type class for the 'ReaderT' monad transformer, assuming that 'm' is an instance of the 'MonadFix' type class. This instance allows for creating recursive computations within the 'ReaderT' monad transformer."
  },
  {
    "Statement": "addTuples [(1,2), (2,3), (100,100)]",
    "Description": "Call the function 'addTuples' with a list of tuples [(1,2), (2,3), (100,100)], resulting in [3,5,200]."
  },
  {
    "Statement": "drop n (_:xs) = drop (n-1) xs",
    "Description": "Otherwise, drop `n` elements from the list."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "Nil >>= _ = Nil",
    "Description": "If the input to the bind operation is Nil, return Nil."
  },
  {
    "Statement": "or' :: [Bool] -> Bool",
    "Description": "Define a function or' that takes a list of Booleans and returns True if at least one of the elements is True, otherwise False."
  },
  {
    "Statement": "isPrefixOf (x:xs) (y:ys)",
    "Description": "Define the recursive case of the isPrefixOf function where two non-empty lists are given. It checks if the first list is a prefix of the second list."
  },
  {
    "Statement": "addTuples xs = [ x+y | (x,y) <- xs ]",
    "Description": "Generate a list by adding the first and second elements of each tuple in the input list."
  },
  {
    "Statement": "    | y <= x = y : x : xs",
    "Description": "Define the condition for the recursive case of the insert function. If the element 'y' is less than or equal to the current element 'x', it inserts 'y' before 'x'."
  },
  {
    "Statement": "instance Monad Maybe",
    "Description": "Define a Monad instance for Maybe type."
  },
  {
    "Statement": "(==) (F n) (F m) = n == m",
    "Description": "Define the equality operator '==' for comparing two temperatures in Fahrenheit. It returns true if their values are equal."
  },
  {
    "Statement": "dropWhileEnd :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function dropWhileEnd that takes a predicate p and a list xs, and returns the list xs after removing the longest suffix that satisfies p."
  },
  {
    "Statement": "apply blast",
    "Description": "Use the `blast` tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "proof (induction xs)",
    "Description": "Apply induction on the first list."
  },
  {
    "Statement": "reverse (x:xs) = reverse xs ++ [x]",
    "Description": "Otherwise, reverse the rest of the list and append the first element."
  },
  {
    "Statement": "mempty = First Nothing",
    "Description": "Define the 'mempty' value for the 'Monoid' instance of 'First a' as a 'First' value wrapping 'Nothing'."
  },
  {
    "Statement": "loop (Kleisli f) = Kleisli (liftM fst . mfix . f')",
    "Description": "Define the loop function for the Arrowloop instance of Kleisli m, which applies the mfix function to a modified version of the original function f, and then lifts the first component of the result using liftM fst."
  },
  {
    "Statement": "maybeadd :: Num b => Maybe b -> b -> Maybe b",
    "Description": "Define a function maybeadd that adds a value to a Maybe-wrapped value."
  },
  {
    "Statement": "instance Monadfix m => Arrowloop (Kleisli m)",
    "Description": "Create an instance of the Arrowloop typeclass for the Kleisli m newtype, given that m is an instance of the Monadfix class."
  },
  {
    "Statement": "module Main where",
    "Description": "Define the module 'Main'."
  },
  {
    "Statement": "(>>=) :: Monad m => m a -> (a -> m b) -> m b",
    "Description": "Define the bind operator (>>=) which sequences two monadic actions."
  },
  {
    "Statement": "readUntilWithCount ending = aux ending 0",
    "Description": "Define the implementation of readUntilWithCount by calling the auxiliary function aux with the ending string and an initial count of 0."
  },
  {
    "Statement": "capitalize (x:xs) = if isUpper x then x:xs else toUpper x : xs",
    "Description": "If the first character 'x' of the input string is already uppercase, leave it unchanged and process the remaining characters 'xs'. Otherwise, convert 'x' to uppercase using 'toUpper' and prepend it to the remaining characters 'xs'."
  },
  {
    "Statement": "prop x y z = ((x <> y) <> z) === (x <> (y <> z))",
    "Description": "Define a property 'prop' that checks if the associative law holds for the 'Semigroup' instance of 'Endo a' by comparing the results of two equivalent expressions involving '<>'."
  },
  {
    "Statement": "loop f b = let (c, d) = f(b, d) in c",
    "Description": "Define the loop function for the ArrowApply instance of (->) that takes a function f and a value b, applies f to (b, d) where d is some undefined value, and returns the first component of the result."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user and bind it to input."
  },
  {
    "Statement": "isright :: Either a b -> Bool",
    "Description": "Define a function 'isright' that checks whether the given 'Either' value is of the 'Right' type."
  },
  {
    "Statement": "then show ?case by simp",
    "Description": "then show the current case."
  },
  {
    "Statement": "lemma setT insert: \"setT (insert v t) = setT t ∪ {v}\"",
    "Description": "Define a lemma asserting the set of a tree after inserting v is equal to the set of the original tree unioned with {v}."
  },
  {
    "Statement": "import Control.Exception",
    "Description": "Import the Control.Exception module."
  },
  {
    "Statement": "import Data.Char (isLower)\n\nuncapitalize :: String -> String",
    "Description": "Define a function 'uncapitalize' that takes a string and returns a new string with the first character converted to lowercase (if it is a letter) and the remaining characters unchanged. Import the 'isLower' function from the 'Data.Char' module."
  },
  {
    "Statement": "                  Just (a, b') -> a : unfoldr f b'",
    "Description": "Define the 'unfoldr' function. If the result of 'f' is Just (a, b'), it adds 'a' to the result and recursively applies 'f' to 'b'."
  },
  {
    "Statement": "data TreeZipper a = TreeZipper (Tree a) [TreePos] [TreePos]",
    "Description": "Define a data type 'TreeZipper a' that represents a zipper for navigating and modifying a tree of type 'Tree a', containing the current subtree, the path to the current subtree, and the remaining paths."
  },
  {
    "Statement": "insert v Leaf = Node Leaf v Leaf;",
    "Description": "If the tree is a 'Leaf', then insert 'v' into it."
  },
  {
    "Statement": "sum [] = 0",
    "Description": "The base case for summing an empty list, which returns 0."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "group' :: Eq a => [a] -> [[a]]",
    "Description": "Define a function group' that takes a list xs and returns a list of lists, where each inner list contains consecutive equal elements of xs."
  },
  {
    "Statement": "proof (induction t rule:insert. induct)",
    "Description": "Apply induction on the tree with the rule for the 'insert' function."
  },
  {
    "Statement": "sumInts = foldl' (+) 0",
    "Description": "The implementation of 'sumInts' uses 'foldl'' to fold the input list of integers using the '+' operator and an initial accumulator value of 0."
  },
  {
    "Statement": "con \"sum\" (sum :: [Int] -> Int),",
    "Description": "Include the 'sum' function signature."
  },
  {
    "Statement": "};",
    "Description": "End of the class definition."
  },
  {
    "Statement": "import Module hiding (name1, name2)",
    "Description": "Imports all entities from the module 'Module' into the current namespace except for 'name1' and 'name2'."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "main = putstrun \"Hello World!\"",
    "Description": "Print 'Hello World!' when 'main' is executed."
  },
  {
    "Statement": "data ExitCode = ExitSuccess | ExitFailure Int",
    "Description": "Define a custom data type 'ExitCode' which represents the status of program termination, either success or failure with an integer code."
  },
  {
    "Statement": "instance Monadfix m => Arrowloop (Kleisli m)",
    "Description": "Create an instance of the Arrowloop typeclass for the Kleisli m newtype, given that m is an instance of the Monadfix class."
  },
  {
    "Statement": "data Point = D2 {x :: Int, y :: Int} | D3 {x :: Int, y :: Int, z :: Int}",
    "Description": "Define a datatype 'Point' with two constructors: 'D2' taking 'x' and 'y' coordinates, and 'D3' taking 'x', 'y', and 'z' coordinates."
  },
  {
    "Statement": "insertionSort [] = []",
    "Description": "If the input list is empty, return an empty list."
  },
  {
    "Statement": "con \"minimum\" (minimum :: [Int] -> Int),",
    "Description": "Include the 'minimum' function signature."
  },
  {
    "Statement": "quicksort :: Ord a => [a] -> [a]",
    "Description": "Define a function quicksort that takes a list of elements and returns a new list with the same elements, sorted in ascending order."
  },
  {
    "Statement": "con \"sortBy\" (sortBy :: (a -> a -> Ordering) -> [a] -> [a]),",
    "Description": "Include the 'sortBy' function signature."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "Define the splice function for an empty list and a non-empty list ys to return the list ys."
  },
  {
    "Statement": "capitalize :: String -> String",
    "Description": "Define a function 'capitalize' that takes a string and returns a new string with the first character capitalized."
  },
  {
    "Statement": "class Category a => Arrow (a :: _->_ -> *)",
    "Description": "Define a type class 'Arrow' parameterized by 'a' which must be an instance of the 'Category' type class. The 'Arrow' type is a higher-kinded type constructor that takes two type arguments and returns a type."
  },
  {
    "Statement": "input ‹- getLine",
    "Description": "Read a line of input from the user and bind it to the variable input."
  },
  {
    "Statement": "sorted :: Ord a => [a] -> Bool",
    "Description": "Define 'sorted' as a function which takes a list of 'a' and returns a boolean."
  },
  {
    "Statement": "fmap :: (a -> b) -> f a -> f b",
    "Description": "Declare the 'fmap' function signature for the 'Functor' type class, which takes a function '(a -> b)' and a value of type 'f a', and returns a value of type 'f b'."
  },
  {
    "Statement": "cycle [] = error \"empty list\"",
    "Description": "If the list is empty, return an error."
  },
  {
    "Statement": "sizeT Leaf = 0",
    "Description": "Define sizeT for the Leaf as 0."
  },
  {
    "Statement": "execStateT :: Monad m => StateT sm a -> s -> m s",
    "Description": "Declare a function execStateT that takes a StateT computation and an initial state, and returns a monadic computation that produces the final state, discarding the final result."
  },
  {
    "Statement": "f :: Ord a => [a] -> [a]",
    "Description": "Specify the type of f to be a function taking a list of Ord type a and returning a list of the same type."
  },
  {
    "Statement": "toGraph :: [Node a] -> Graph",
    "Description": "Define a function 'toGraph' that takes a list of nodes '[Node a]' and converts it into a 'Graph' data structure."
  },
  {
    "Statement": "drop _ [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "descSort = reverse . sort",
    "Description": "Define 'descSort' as the composition of 'reverse' and 'sort' functions."
  },
  {
    "Statement": "by auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "forkIO :: IO () -> IO ThreadId",
    "Description": "Create a new concurrent thread that runs the given IO action, returning the ThreadId of the newly created thread."
  },
  {
    "Statement": "safeHeadOr :: a -> [a] -> a",
    "Description": "Define a function 'safeHeadOr' that takes a default value of type 'a' and a list of elements of type 'a', and returns the first element of the list or the default value if the list is empty."
  },
  {
    "Statement": "otherwise = n * fac (n-1)",
    "Description": "Otherwise, return `n * fac (n-1)`."
  },
  {
    "Statement": "treeToSeq Leaf = empty",
    "Description": "For an empty tree, return an empty sequence."
  },
  {
    "Statement": "Just 1 >>= (\\x -> Just x)",
    "Description": "Bind the value 1 wrapped in a Just context to the function (\\x -> Just x), resulting in Just 1."
  },
  {
    "Statement": "notElem' :: Eq a => a -> [a] -> Bool",
    "Description": "Define a function notElem' that takes an element x and a list xs, and returns True if x is not an element of xs, otherwise False."
  },
  {
    "Statement": "instance Monoidal [] where",
    "Description": "Define a 'Monoidal' instance for the list type constructor '[]'."
  },
  {
    "Statement": "case True",
    "Description": "If the case is True,"
  },
  {
    "Statement": "insert x (y:ys) | otherwise = y : insert x ys",
    "Description": "Otherwise, prepend the head of the list to the result of recursively calling insert with x and the tail of the list."
  },
  {
    "Statement": "data Person = person {name :: String, age :: Int}",
    "Description": "Define a datatype 'Person' with record syntax having fields 'name' of type 'String' and 'age' of type 'Int'."
  },
  {
    "Statement": "topologicalSort :: [Node a] -> [Node a]",
    "Description": "Define a function 'topologicalSort' that takes a list of nodes '[Node a]' and returns a topologically sorted list of nodes."
  },
  {
    "Statement": "where aux ending = do",
    "Description": "Begin the definition of the `aux` function using the do notation for monadic computations. The `aux` function takes the `ending` string as an argument."
  },
  {
    "Statement": "\"(Vlv € setT l. lv ≤ v)\"",
    "Description": "Assume that for every `lv` in the set of `l`, `lv` is less than or equal to `v`."
  },
  {
    "Statement": "dropWhile :: (a -> Bool) -> [a] -> [a]",
    "Description": "Define a function named `dropWhile` which takes a function and a list and returns a list."
  },
  {
    "Statement": "lines s = let (l, s') = break (== '\\n') s",
    "Description": "Define the recursive case of the lines function where a non-empty string is given. It breaks the string at the first newline character and returns the line as the first element of the resulting list."
  },
  {
    "Statement": "if input == ending then return ncount else aux ending ncount",
    "Description": "Check if the input is equal to the `ending` string. If so, return the current `ncount` value. Otherwise, recursively call `aux` with the same `ending` string and the updated `ncount` value."
  },
  {
    "Statement": "productInts = foldl' () 1",
    "Description": "The implementation of 'productInts' uses 'foldl'' to fold the input list of integers using the '' operator and an initial accumulator value of 1."
  },
  {
    "Statement": "reverse' = foldl' (flip (:)) []",
    "Description": "The implementation of 'reverse'' uses 'foldl'' to fold the input list using the 'flip (:)' function (which prepends an element to a list) and an initial accumulator value of an empty list '[]'."
  },
  {
    "Statement": "scanl' :: (a -> b -> a) -> a -> [b] -> [a]",
    "Description": "Define a function scanl' that takes a function f, an initial value z, and a list xs, and returns a list of successive reduced values from the left, starting with the initial value z."
  },
  {
    "Statement": "lift2 f x = (<**>) (fmap f x)",
    "Description": "Define the 'lift2' function by applying 'fmap' to the input function 'f' and the input value 'x' of type 'f a', and then using the '(<**>)' operator to apply the resulting functions to the input value 'x'."
  },
  {
    "Statement": "listCase :: [a] -> Either () (a, [a])\nlistCase [] = Left ()\nlistCase (x:xs) = Right (x, xs)",
    "Description": "Define a function 'listCase' that takes a list and returns either an empty tuple '()' (for the empty list) or a pair containing the head and tail of the list."
  },
  {
    "Statement": "abbreviation sortedT :: \"('a :: linorder) Tree → bool*\"",
    "Description": "Define an abbreviation named sortedT which takes a Tree of type ('a :: linorder) and returns a bool."
  },
  {
    "Statement": "removeDuplicates :: Eq a => [a] -> [a]",
    "Description": "Define a function 'removeDuplicates' that takes a list of elements of type 'a' (which must be an instance of the 'Eq' typeclass) and returns a list with duplicates removed."
  },
  {
    "Statement": "Nil >>= _ = Nil",
    "Description": "If the input to the bind operation is Nil, return Nil."
  },
  {
    "Statement": "data Person = person {name :: String, age :: Int}",
    "Description": "Define a datatype 'Person' with record syntax having fields 'name' of type 'String' and 'age' of type 'Int'."
  },
  {
    "Statement": "quicksort [] = []",
    "Description": "If the list is empty, return an empty list."
  },
  {
    "Statement": "filter' p = foldl' (\\acc x -> if p x then acc ++ [x] else acc) []",
    "Description": "The implementation of 'filter'' uses 'foldl'' to fold the input list using an anonymous function that appends the current element 'x' to the accumulator 'acc' if 'p x' is 'True'. The initial accumulator is an empty list '[]'."
  },
  {
    "Statement": "zip' xs ys = foldl' (\\acc (x, y) -> acc ++ [(x, y)]) [] (zip xs ys)",
    "Description": "The implementation of 'zip'' uses 'foldl'' to fold the list of pairs '(x, y)' obtained from the built-in 'zip' function, using an anonymous function that appends each pair to the accumulator 'acc'. The initial accumulator is an empty list '[]'."
  },
  {
    "Statement": "\"sizeT l < sizeT (Node l v r)\"",
    "Description": "Assume that the size of l is less than the size of the node."
  },
  {
    "Statement": "maybeadd Nothing (Just 1)",
    "Description": "Applly `maybeadd` function with `Nothing` and `Just 1`, resulting in Nothing."
  },
  {
    "Statement": "proof (induction xs arbitrary: n)",
    "Description": "Apply induction on the list with an arbitrary number `n`."
  },
  {
    "Statement": "instance MonadIO m => MonadIO (WriterT w m) where\n    liftIO = lift . liftIO",
    "Description": "Provide an instance of the 'MonadIO' type class for the 'WriterT' monad transformer, assuming that 'm' is an instance of the 'MonadIO' type class. This instance allows for lifting 'IO' computations into the 'WriterT' monad transformer."
  },
  {
    "Statement": "| otherwise = n * fac (n-1)",
    "Description": "Otherwise, return `n * fac (n-1)`."
  },
  {
    "Statement": "or' = foldl' (||) False",
    "Description": "The implementation of 'or'' uses 'foldl'' to fold the input list"
  },
  {
    "Statement": "return ncount",
    "Description": "If the input string is equal to the ending string, return the final count."
  },
  {
    "Statement": "prefixes = inits",
    "Description": "The implementation of 'prefixes' simply applies the 'inits' function to the input list."
  },
  {
    "Statement": "instance (Monoid w, Monad m) => MonadWriter w (ReaderT r m) where\n    tell _ = return ()\n    listen (ReaderT m) = ReaderT $ \\r -> do\n        (a, w) <- listen (m r)\n        return ((a, w), w)\n    pass (ReaderT m) = ReaderT $ \\r -> do\n        (a, f) <- pass (m r)\n        return (a, f)",
    "Description": "Provide an instance of the 'MonadWriter' type class for the 'ReaderT' monad transformer, assuming that 'm' is an instance of the 'Monad' type class and 'w' is an instance of the 'Monoid' type class. This instance allows for working with computations that produce a log along with a value within the 'ReaderT' monad transformer."
  },
  {
    "Statement": "    | x == y = isPrefixOf xs ys",
    "Description": "Define the condition for the recursive case of the isPrefixOf function. If the current elements 'x' and 'y' are equal, it recursively checks the remaining lists."
  },
  {
    "Statement": "length (x:xs) =?= foldr (const (+1)) 0 (x:xs)",
    "Description": "State that the length of a non-empty list (x:xs) is equal to foldr (const (+1)) 0 (x:xs)."
  },
  {
    "Statement": "foldr :: (a -> b -> b) -> b -> Seq a -> b",
    "Description": "Declare a function foldr that folds a sequence from the right with a binary function."
  },
  {
    "Statement": "lookup :: Eq a => a -> [(a, b)] -> Maybe b",
    "Description": "Define 'lookup' as a function which finds the first value associated with the given key in the list of key-value pairs."
  },
  {
    "Statement": "fromright :: b -> Either a b -> b",
    "Description": "Define a function 'fromright' that extracts the value from a 'Right' constructor or returns a default value."
  },
  {
    "Statement": "rpar :: Strategy a",
    "Description": "Create a Strategy that sparks a new thread to compute the given value in parallel."
  },
  {
    "Statement": "age :: Person -> Int",
    "Description": "Define a function 'age' which takes a 'Person' and returns their age."
  },
  {
    "Statement": "Nothing -> return Nothing",
    "Description": "If maybe_val is Nothing, return a failed IOMaybe computation by returning Nothing."
  },
  {
    "Statement": "where types = (x :: Maybe Int, y :: Maybe Int)",
    "Description": "Specify the types of 'x' and 'y' as 'Maybe' integers for the 'prop' function."
  },
  {
    "Statement": "returnIOM :: a -> IOMaybe a",
    "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
  },
  {
    "Statement": "assumes",
    "Description": "Specify assumptions for the lemma."
  },
  {
    "Statement": "returnIOM :: a -> IOMaybe a",
    "Description": "Define a function returnIOM that takes a value of type a and returns a successful IOMaybe computation with that value."
  },
  {
    "Statement": "data DataType = A | B | C\nimport Module (dataType(...))",
    "Description": "Define a data type 'DataType' with constructors 'A', 'B', and 'C'. Then imports only the specified data type constructors from the module 'Module'."
  },
  {
    "Statement": "con \"dropFirst\" (drop :: Int -> [a] -> [a]),",
    "Description": "Include the 'dropFirst' function signature."
  },
  {
    "Statement": "frequencies [] = empty",
    "Description": "For an empty list, 'frequencies' returns an empty map."
  },
  {
    "Statement": "transpose' :: [[a]] -> [[a]]",
    "Description": "Define a function transpose' that takes a list of lists xss, and returns a new list of lists where the rows and columns of xss are swapped."
  },
  {
    "Statement": "joinWith sep = intercalate sep",
    "Description": "Define 'joinWith' as the 'intercalate' function, which takes a separator string and a list of strings, and returns a single string with the elements of the list joined by the separator."
  },
  {
    "Statement": "hn = n",
    "Description": "Assign `hn` the value of `n`."
  },
  {
    "Statement": "revAcc :: [a] -> [a]",
    "Description": "Define 'revAcc' as a function which takes a list of 'a' and returns a list of 'a'."
  },
  {
    "Statement": "liftIOm :: IO a -> IOMaybe a",
    "Description": "Define a function liftIOm that takes an IO computation and lifts it into the IOMaybe context, allowing for side effects while still preserving the possibility of failure."
  },
  {
    "Statement": "import qualified Data.ByteString as B",
    "Description": "Import the 'Data.ByteString' module qualified as 'B'."
  },
  {
    "Statement": "instance Applicative IO where\n\n    pure = return\n\n    a <\\*> b = do\n\n        f <- a\n\n        x <- b\n\n        return (f x)",
    "Description": "Define an instance of the Applicative typeclass for the IO monad. The pure function is implemented using return, and the (<\\*>) operator is implemented using a do block that first gets a function f from a, then a value x from b, and finally applies f to x and returns the result."
  },
  {
    "Statement": "map (\\x -> x+1) [1,2,3,4,5]",
    "Description": "Applly the anonymous function (\\x -> x+1) to each element of the list [1,2,3,4,5] using 'map', resulting in [2,3,4,5,6]."
  },
  {
    "Statement": "(<>) _ b = b",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'First a' to handle the case where the first value is 'Nothing'."
  },
  {
    "Statement": "instance Monad Maybe",
    "Description": "Create an instance of the Monad typeclass for the Maybe data type, which represents computations that can either succeed with a value of type a or fail without a value."
  },
  {
    "Statement": "if input == ending then return () else readUntil ending",
    "Description": "Check if the input is equal to the `ending` string. If so, return the unit value `()` to indicate successful completion. Otherwise, recursively call `readUntil` with the same `ending` string."
  },
  {
    "Statement": "elem :: Eq a => a -> Seq a -> Bool",
    "Description": "Declare a function elem that checks if an element is in a sequence."
  },
  {
    "Statement": "splice (x:xs) (y:ys) = x : y : splice xs ys",
    "Description": "Prepend the first elements of the two lists x and y, and then recursively splice the remaining elements xs and ys."
  },
  {
    "Statement": "x (D2 1 2)",
    "Description": "Access the 'x' coordinate of a 2D point, yielding '1'."
  },
  {
    "Statement": "unlines' :: [String] -> String",
    "Description": "Define a function unlines' that takes a list of strings and joins them together using newline characters."
  },
  {
    "Statement": "(<>) = coerce ((<>) :: a -> a -> a)",
    "Description": "Define the '<>' operator for the 'Semigroup' instance of 'Dual a' by converting the '(<>)' function for type 'a' to the appropriate type using 'coerce'."
  },
  {
    "Statement": "fac n",
    "Description": "Define `fac` with parameter `n`."
  },
  {
    "Statement": "    | otherwise = find p xs",
    "Description": "Define the condition for the recursive case of the find function. If the predicate 'p' is not satisfied by the current element 'x', it recursively searches in the rest of the list."
  },
  {
    "Statement": "length :: [a] -> Int",
    "Description": "Return the number of elements in a list."
  },
  {
    "Statement": "where",
    "Description": "Begin definition of the sortedT abbreviation."
  },
  {
    "Statement": "data Tree a = Leaf | Node a (Tree a) (Tree a)",
    "Description": "Define a data type named Tree which is either Leaf or a Node containing an element of type a and two subtrees of the same type."
  },
  {
    "Statement": "fac n",
    "Description": "Define `fac` with parameter `n`."
  },
  {
    "Statement": "putStr \"Please enter your name: \"",
    "Description": "Print the prompt \"Please enter your name: \" to the user."
  },
  {
    "Statement": "| × < y = Z",
    "Description": "If `x * y` is less than `y`, return `Z`."
  },
  {
    "Statement": "then show ?case",
    "Description": "then show the current case."
  },
  {
    "Statement": "class (Order a) => Linorder a where {",
    "Description": "Define a class 'Linorder' with type variable 'a' which is a subclass of 'Order', where,"
  },
  {
    "Statement": "    | p x = Just x",
    "Description": "Define the condition for the recursive case of the find function. If the predicate 'p' is satisfied by the current element 'x', it returns Just x."
  },
  {
    "Statement": "checkInput :: String -> Bool",
    "Description": "Define a function checkInput that takes a String and returns a Bool indicating whether the input is valid or not."
  },
  {
    "Statement": "[ (x,y) | x <- [1,2,3], y <- ['a','b']]",
    "Description": "Generate a list of tuples where each tuple contains an element from the list [1,2,3] paired with each element from the list ['a','b']."
  },
  {
    "Statement": "name arg1 arg2 ... argn",
    "Description": "Calls the function 'name' with 'n' arguments."
  },
  {
    "Statement": "class Arrow a => ArrowLoop (a :: _->_ -> *)\n  where\n    loop :: a (b, d) (c, d) -> a b c",
    "Description": "Define a type class 'ArrowLoop' parameterized by 'a', which must be an instance of the 'Arrow' type class. The 'ArrowLoop' class specifies a single method 'loop' for creating feedback loops."
  },
  {
    "Statement": "packConsecutive = group . sort",
    "Description": "The implementation of 'packConsecutive' uses function composition: first, sort the input list using 'sort', then group consecutive duplicate elements into sublists using 'group'."
  },
  {
    "Statement": "lift $ putStr \"Please enter your name: \"",
    "Description": "Print the prompt \"Please enter your name: \" to the user within the `IO` monad, using `lift` to lift the `IO` action into the `MaybeT` monad."
  },
  {
    "Statement": "checkInput [] = False",
    "Description": "If the input String is empty, return False."
  },
  {
    "Statement": "deleteFirstsBy _ xs [] = xs",
    "Description": "Define the case of the deleteFirstsBy function where the second list is empty, it returns the first list."
  },
  {
    "Statement": "safeHead :: [a] -> Maybe a",
    "Description": "Define a function 'safeHead' that takes a list and returns the first element of the list wrapped in a 'Maybe' value, or 'Nothing' if the list is empty."
  },
  {
    "Statement": "deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]",
    "Description": "Define 'deleteBy' as a function which removes the first occurrence of an element that satisfies a predicate from a list."
  },
  {
    "Statement": "Lemma sorted node:",
    "Description": "Define a lemma named `sorted_node`."
  },
  {
    "Statement": "data List a = Nil | Cons a (List a)",
    "Description": "Define a data type named List which is either Nil or a Cons cell containing an element of type a and a List of the same type."
  },
  {
    "Statement": "drop' :: Int -> [a] -> [a]",
    "Description": "Define a function drop' that takes an integer n and a list xs, and returns the list xs with the first n elements removed."
  },
  {
    "Statement": "postOrder :: Tree a -> [a]",
    "Description": "Define a function named postOrder which takes a Tree of elements of type a and returns a list of the elements in post-order traversal order."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
  },
  {
    "Statement": "sortBy cmp (x:xs) = sortBy cmp (filter (\\y -> cmp y x == LT) xs) ++ [x] ++ sortBy cmp (filter (\\y -> cmp y x /= LT) xs)",
    "Description": "Define the recursive case of the sortBy function where a non-empty list is given. It sorts the list using the comparison function 'cmp'."
  },
  {
    "Statement": "f xs = map (\\x -> x+1) (filter (\\x -> x>1) xs)",
    "Description": "Define the function 'f' which takes a list 'xs' and applies a mapping and filtering operation sequentially."
  },
  {
    "Statement": "p n= n≥ 0",
    "Description": "Define `p` as a function that takes `n` and returns `True` if `n` is greater than or equal to 0."
  },
  {
    "Statement": "};",
    "Description": "End of the class definition."
  },
  {
    "Statement": "splitEithers = partitionEithers",
    "Description": "The implementation of 'splitEithers' simply applies the 'partitionEithers' function to the input list of 'Either' values."
  },
  {
    "Statement": "return (if checkFirstChar name then Just name else Nothing)",
    "Description": "Check if the input satisfies the checkFirstChar condition. If it does, return the input wrapped in a Just constructor. Otherwise, return Nothing."
  },
  {
    "Statement": "get :: m s",
    "Description": "Declare a function `get` that retrieves the current state value within the base monad `m`."
  },
  {
    "Statement": "checkInput (x:_) = isUpper x",
    "Description": "If the input String is non-empty, check if the first character is an uppercase letter using the isUpper function, and return the result as a Bool."
  },
  {
    "Statement": "| otherwise = func (x-y) (y*2) (z+1)",
    "Description": "Otherwise, recursively call `func` with `(x-y)`, `(y*2)`, and `(z+1)`."
  },
  {
    "Statement": "scanr :: (a -> b -> b) -> b -> Seq a -> Seq b",
    "Description": "Declare a function scanr that scans a sequence from the right with a binary function."
  },
  {
    "Statement": "main :: 10 (",
    "Description": "Define the 'main' function."
  },
  {
    "Statement": "loop (Kleisli f) = Kleisli (liftM fst . mfix . f')",
    "Description": "Define the loop function for the Arrowloop instance of Kleisli m, which applies the mfix function to a modified version of the original function f, and then lifts the first component of the result using liftM fst."
  },
  {
    "Statement": "and :: [Bool] -> Bool",
    "Description": "Return True if all elements in the list are True, otherwise False."
  },
  {
    "Statement": "foldl :: (a -> b -> a) -> a -> Seq b -> a",
    "Description": "Declare a function foldl that folds a sequence from the left with a binary function."
  },
  {
    "Statement": "con \"concat\"\n(concat:: [[A]]",
    "Description": "Declare the signature for 'concat' function."
  },
  {
    "Statement": "lemma contains_filter: \"contains P (filter Q xs) ⟷ contains P xs ∧ (∃x ∈ set xs. Q x)\"",
    "Description": "Define a lemma asserting that `P` holds for an element in the filtered list if and only if `P` holds for the original list and there exists an element in the set of the original list satisfying `Q`."
  },
  {
    "Statement": "calc (Sub x y) = x-y",
    "Description": "Define the 'calc' function pattern matching on the 'Sub' constructor, returning the difference of 'x' and 'y'."
  },
  {
    "Statement": "lemma \"mirror (mirror t) = t\"",
    "Description": "Define a lemma asserting that mirroring a mirrored tree results in the original tree."
  },
  {
    "Statement": "instance MonadIO m => MonadIO (ReaderT r m) where\n    liftIO = lift . liftIO",
    "Description": "Provide an instance of the 'MonadIO' type class for the 'ReaderT' monad transformer, assuming that 'm' is an instance of the 'MonadIO' type class. This instance allows for lifting 'IO' computations into the 'ReaderT' monad transformer."
  },
  {
    "Statement": "background [ prelude ]",
    "Description": "Include the Prelude module in the background."
  },
  {
    "Statement": "return v = Just v",
    "Description": "Define the return function for the Maybe monad, which takes a value v and wraps it in a Just constructor."
  },
  {
    "Statement": "getName = do",
    "Description": "Begin the implementation of the getName function using the do notation."
  },
  {
    "Statement": "(==) (F n) (F m) = n == m",
    "Description": "Define the equality operator '==' for comparing two temperatures in Fahrenheit. It returns true if their values are equal."
  },
  {
    "Statement": "sum (X : XS) = X + sum XS",
    "Description": "Define a function 'sum' that takes a non-empty list as input, where X is the head of the list and XS is the tail. It recursively calculates the sum of the elements in the list by adding the head (X) to the sum of the tail (sum XS)."
  },
  {
    "Statement": "getName :: IOMaybe String",
    "Description": "Define a function getName that represents an IOMaybe computation that can get a valid name from the user."
  },
  {
    "Statement": "next",
    "Description": "Move to the next case."
  },
  {
    "Statement": "newtype Sum a = Sum { getSum :: a }",
    "Description": "Define a new data type called 'Sum' with a single constructor 'Sum' that wraps a value of type 'a'. The 'getSum' function extracts the value of type 'a' from the 'Sum' constructor."
  },
  {
    "Statement": "reverse :: List a -> List a",
    "Description": "Define a function named reverse which takes a List of elements of type a and returns a List of the same type with the elements in reverse order."
  },
  {
    "Statement": "firstIndexOf x = elemIndex x",
    "Description": "The implementation of 'firstIndexOf' simply applies the 'elemIndex' function to the element 'x' and the input list."
  },
  {
    "Statement": "insertionSort :: Ord a => [a] -> [a]",
    "Description": "Define a function named insertionSort which takes a list of elements of type a, where a is an instance of the Ord typeclass, and returns a sorted list of the same elements."
  },
  {
    "Statement": "monadd :: (Monad m, Num b) => m b -> m b -> m b",
    "Description": "Define a function `monadd` that adds two monadic values."
  },
  {
    "Statement": "newtype Sum a = Sum { getSum :: a }\nderiving (Eq, Ord, ..... )",
    "Description": "Define a new data type Sum that wraps a value of type a, and derives various type class instances for it, such as Eq, Ord, etc."
  },
  {
    "Statement": "main = do\n i <- getLine\n if i /= \"quit\" then do\n    putStrLn (\"Input: \"++ i)\n    main\n else\n    return ()",
    "Description": "Define the main function which repeatedly prompts the user for input until 'quit' is entered, then terminates."
  },
  {
    "Statement": "delete w = arr words >>> arr (filter (/= w)) >>> arr unwords",
    "Description": "Define a function delete that takes a word w and returns a new function that removes all occurrences of w from a given string, using the point-free style and the arr function from the Arrow typeclass."
  },
  {
    "Statement": "in_range min max x = ilb && iub",
    "Description": "Define a function 'in_range' that takes three arguments: 'min', 'max', and 'x', and returns whether 'x' is within the range [min, max]."
  },
  {
    "Statement": "    where (ys, zs) = partition p xs",
    "Description": "Define the recursive case of the partition function. It separates the rest of the list into two lists."
  },
  {
    "Statement": "mergeUnique xs ys = union xs ys",
    "Description": "The implementation of 'mergeUnique' simply applies the 'union' function to the two input lists 'xs' and 'ys'."
  },
  {
    "Statement": "insertionSort [] = []",
    "Description": "If the input list is empty, return an empty list."
  },
  {
    "Statement": "Lemma set_contains: \"(∃x ∈ set xs. P x) ⟶ contains P xs\"",
    "Description": "Define a lemma asserting that if an element is in the set of the list, then `P` holds for that element in the list."
  },
  {
    "Statement": "\"assumes 'sortedT r'\"",
    "Description": "Assume that r is sorted."
  },
  {
    "Statement": "import Test.QuickCheck",
    "Description": "Import the Test.QuickCheck module."
  },
  {
    "Statement": "mergeSort xs = merge (mergeSort left) (mergeSort right)",
    "Description": "For a non-empty list, 'mergeSort' divides the list into two halves, recursively sorts each half, and then merges the sorted halves using the 'merge' function."
  },
  {
    "Statement": "if z then x else y",
    "Description": "Conditional Statement that evaluates 'z'. If 'z' is true, evaluates 'x'; otherwise, evaluates 'y'."
  },
  {
    "Statement": "where",
    "Description": "Begin the definition of helper functions for 'frequencies'."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "If the first list is empty, return the second list ys as the result of splicing."
  },
  {
    "Statement": "returnIOM = return . Just",
    "Description": "Implement the returnIOM function by composing the Just constructor with the return function from the Monad typeclass."
  },
  {
    "Statement": "unzip :: [(a, b)] -> ([a], [b])",
    "Description": "Define a function named `unzip` which takes a list of pairs and returns a pair of lists."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "finally :: IO a -> IO b -> IO a",
    "Description": "Create an IO action that runs the first IO action, then runs the second IO action, and finally returns the result of the first IO action, regardless of whether an exception was thrown or not."
  },
  {
    "Statement": "m>>n = m >>= \\_-> n",
    "Description": "Define the implementation of (>>) operator, which sequences two monadic computations. It applies the first computation m, discards its result using a lambda function, and then proceeds to execute the second computation n."
  },
  {
    "Statement": "negate :: a -> a",
    "Description": "Define the negation operation 'negate' within the 'Num' typeclass which takes a value of type 'a' and returns a value of type 'a'."
  },
  {
    "Statement": "fac n",
    "Description": "Define `fac` with parameter `n`."
  },
  {
    "Statement": "import Data.List",
    "Description": "Import the Data.List module which provides list manipulation functions."
  },
  {
    "Statement": "foldl1 f (x:xs) = foldl f x xs",
    "Description": "Define 'foldl1' as a function that applies a binary function in a left-associative manner to the elements of a non-empty list, using the first element as the starting value."
  },
  {
    "Statement": "calc (Mul x y) = xy",
    "Description": "Define the 'calc' function pattern matching on the 'Mul' constructor, returning the product of 'x' and 'y'."
  },
  {
    "Statement": "module Main where",
    "Description": "Define the module 'Main'."
  },
  {
    "Statement": "Just x -> f x",
    "Description": "If m is Just x, then apply the function f to the value x inside the Just constructor."
  },
  {
    "Statement": "in_upper_bound = max >= x;",
    "Description": "Check if 'x' is less than or equal to 'max' and assign the result to 'in_upper_bound'."
  },
  {
    "Statement": "isPalindrome str = str == reverse str",
    "Description": "Check if the input string is equal to its reverse to determine if it's a palindrome."
  },
  {
    "Statement": "isSubsetOf :: Set a -> Set a -> Bool",
    "Description": "Declare a function isSubsetOf that checks if one set is a subset of another."
  },
  {
    "Statement": "lemma tree_exists:",
    "Description": "Define a lemma named tree_exists."
  },
  {
    "Statement": "import Data.Char (toUpper)",
    "Description": "Import the 'toUpper' function from the Data.Char module, which converts a character to its uppercase equivalent."
  },
  {
    "Statement": "in_range 0 5 3 <-- correct",
    "Description": "Call the 'in_range' function with arguments 0, 5, and 3. This is a correct usage."
  },
  {
    "Statement": "(+) :: a -> a -> a",
    "Description": "Define the addition operation '+' within the 'Num' typeclass which takes two values of type 'a' and returns a value of type 'a'."
  },
  {
    "Statement": "class Functor f => Applicative (f :: * -> *) where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n    (*>) :: f a -> f b -> f b\n    (<*) :: f a -> f b -> f a",
    "Description": "Define a type class 'Applicative' parameterized by 'f', requiring 'f' to be an instance of the 'Functor' type class. The 'Applicative' class specifies methods 'pure', '<*>', '*>', and '<*' for applying and combining computations."
  },
  {
    "Statement": "by auto",
    "Description": "Use the `auto` tactic to solve the subgoal."
  },
  {
    "Statement": "(<**>) :: Monoidal f => f (a -> b) -> f a -> f b",
    "Description": "Declare the '(<**>)' operator signature for the 'Monoidal' type class, which takes a value of type 'f (a -> b)' and a value of type 'f a', and returns a value of type 'f b' by applying the functions in the first argument to the values in the second argument."
  },
  {
    "Statement": "}",
    "Description": "End the conditional Statement and the function definition."
  },
  {
    "Statement": "map f (x:xs) = f x : map f xs",
    "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
  },
  {
    "Statement": "Nothing -> return Nothing",
    "Description": "If maybe_val is Nothing, return a failed IOMaybe computation by returning Nothing."
  },
  {
    "Statement": "null :: [a] -> Bool",
    "Description": "Return True if a list is empty, otherwise False."
  },
  {
    "Statement": "\"∀t1 t2. sortedT t1 ⟶ sortedT t2 ⟶ sortedT (t1 ∪ t2)\"",
    "Description": "For all trees t1 and t2, if t1 and t2 are sorted, then the union of t1 and t2 is also sorted."
  },
  {
    "Statement": "asc 1 3",
    "Description": "Call the 'asc' function with arguments 1 and 3, resulting in the list [1,2,3]."
  },
  {
    "Statement": "checkInput (x:_ = isUpper x",
    "Description": "If the input string is non-empty, check if the first character is uppercase and return the result."
  },
  {
    "Statement": "quicksort :: Ord a => [a] -> [a]",
    "Description": "Define a function 'quicksort' that takes a list of elements of any type 'a' that implements the 'Ord' typeclass, and returns a sorted list of the same type."
  },
  {
    "Statement": "length Nil = 0",
    "Description": "If the input list is Nil, return 0."
  },
  {
    "Statement": "con \"subtract\" ((-) :: Int -> Int -> Int),",
    "Description": "Include the 'subtract' function signature."
  },
  {
    "Statement": "length (Cons _ xs) = 1 + length xs",
    "Description": "Otherwise, return 1 plus the length of the tail of the list."
  },
  {
    "Statement": "checkInput :: String -> Bool",
    "Description": "Define a function checkInput that takes a String and returns a Bool."
  },
  {
    "Statement": "zip (x:xs) (y:ys) = (x, y) : zip xs ys",
    "Description": "Otherwise, pair corresponding elements of the two lists."
  },
  {
    "Statement": "splice xs [] = xs",
    "Description": "If the second list is empty, return the first list xs as the result of splicing."
  },
  {
    "Statement": "insert :: Ord a => a -> Tree a -> Tree a",
    "Description": "Define a function insert that takes an element x and a binary search tree t, and inserts x into t, maintaining the ordering of the tree."
  },
  {
    "Statement": "where",
    "Description": "Begin definition of the `sortedT` abbreviation."
  },
  {
    "Statement": "doubleList = map (\\x -> 2x)",
    "Description": "Define the 'doubleList' function using 'map' with a lambda function that doubles its argument."
  },
  {
    "Statement": "import Data.List (elemIndices)\n\nindicesOf :: Eq a => a -> [a] -> [Int]",
    "Description": "Define a function 'indicesOf' that takes an element and a list of elements of the same type 'a' that implements the 'Eq' typeclass, and returns a list of indices (zero-based) at which the element occurs in the list. Import the 'elemIndices' function from the 'Data.List' module."
  },
  {
    "Statement": "then returnIOM input",
    "Description": "If the condition is satisfied, return the input wrapped in a Just constructor using returnIOM."
  },
  {
    "Statement": "fun mirror Leaf = Leaf",
    "Description": "If the tree is empty, return an empty tree."
  },
  {
    "Statement": "func :: Int -> Int -> Int -> Int",
    "Description": "Define a function named `func` which takes three `Int` parameters and returns an `Int`."
  },
  {
    "Statement": "import Data.Complex",
    "Description": "Import the Data.Complex module."
  },
  {
    "Statement": "safeHead [] = Nothing",
    "Description": "For an empty list, 'safeHead' returns 'Nothing'."
  },
  {
    "Statement": "input <- getLine",
    "Description": "Read a line of input from the user within the `IO` monad, and bind the result to the `input` variable."
  },
  {
    "Statement": "background [\npredicate \"<\" ((<) :: Int -> Int -> Bool),",
    "Description": "Declare the signature for the '<' function."
  },
  {
    "Statement": "let ncount = count + 1",
    "Description": "Calculate the new count by incrementing the current count by 1, and bind it to the variable ncount."
  },
  {
    "Statement": "import Data.List (foldl')\n\nzip' :: [a] -> [b] -> [(a, b)]",
    "Description": "Define a function 'zip'' that takes two lists of elements of types 'a' and 'b', and returns a list of pairs '(a, b)' containing the corresponding elements from the input lists. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "import Data.List (isPrefixOf, isSuffixOf)",
    "Description": "Import the 'isPrefixOf' and 'isSuffixOf' functions from the Data.List module, which check if a list is a prefix or suffix of another list, respectively."
  },
  {
    "Statement": "where types = (x :: Bool, y :: Bool)",
    "Description": "Specify the types of 'x' and 'y' as boolean values for the 'prop' function."
  },
  {
    "Statement": "else return Nothing",
    "Description": "If the input is not valid, return a failed IOMaybe computation by returning Nothing."
  },
  {
    "Statement": "Derived equivalence:",
    "Description": "Describe the derived equivalence for the 'Eq' instance of the 'Temperature' datatype."
  },
  {
    "Statement": "type IOMaybe a = IO (Maybe a)",
    "Description": "Define a new type synonym IOMaybe a that represents a computation that can perform side effects and either succeed with a value of type a or fail without a value."
  },
  {
    "Statement": "con \":~\" ((++) :: String -> String -> String),",
    "Description": "Include the ':~' operator signature."
  },
  {
    "Statement": "import Data.List (foldl')\n\nunzip' :: [(a, b)] -> ([a], [b])",
    "Description": "Define a function 'unzip'' that takes a list of pairs '(a, b)' and returns a tuple '([a], [b])' containing two lists: one with the first elements of the pairs, and one with the second elements of the pairs. Import the 'foldl'' function from the 'Data.List' module, which is a strict (non-lazy) version of 'foldl'."
  },
  {
    "Statement": "readUntil :: String -> IO ()",
    "Description": "Declare a function named `readUntil` that takes a `String` argument and returns an `IO ()` computation, which reads input from the user until a specific ending string is entered."
  },
  {
    "Statement": "splice [] ys = ys",
    "Description": "If the first list is empty, return the second list ys as the result of splicing."
  },
  {
    "Statement": "unit = [()]",
    "Description": "Define the 'unit' value for the 'Monoidal' instance of '[]' as a list containing the unit value '()'."
  },
  {
    "Statement": "contains xs ys = isInfixOf xs ys",
    "Description": "The implementation of 'contains' simply applies the 'isInfixOf' function to the two input lists 'xs' and 'ys'."
  },
  {
    "Statement": "data Either a b = Left a | Right b",
    "Description": "Define a data type 'Either' which represents a value of one of two possible types, 'a' or 'b', typically used for error handling where 'Left' indicates an error and 'Right' indicates a successful result."
  },
  {
    "Statement": "otherwise = n * fac (n-1)",
    "Description": "Otherwise, return `n * fac (n-1)`."
  },
  {
    "Statement": "instance MonadError e m => MonadError e (ReaderT r m) where\n    throwError = lift . throwError\n    catchError (ReaderT f) g = ReaderT $ \\r -> catchError (f r) (\\e -> runReaderT (g e) r)",
    "Description": "Provide an instance of the 'MonadError' type class for the 'ReaderT' monad transformer, assuming that 'm' is an instance of the 'MonadError' type class. This instance allows for handling errors within the 'ReaderT' monad transformer."
  },
  {
    "Statement": "drop :: Int -> [a] -> [a]",
    "Description": "Define a function named `drop` which takes an `Int` and a list of any type and returns a list of the same type."
  },
  {
    "Statement": "map f (x:xs) = f x : map f xs",
    "Description": "Otherwise, apply function `f` to the first element `x` and recursively apply `map` to the rest of the list."
  },
  {
    "Statement": "bindIOM iom f = do",
    "Description": "Begin the implementation of the bindIOM function using the do notation."
  },
  {
    "Statement": "foldl' _ z [] = z",
    "Description": "Define the base case for foldl', which returns the initial value z when applied to an empty list."
  },
  {
    "Statement": "n == 0 =1",
    "Description": "If `n` is equal to 0, return 1."
  },
  {
    "Statement": "import Data.Maybe (mapMaybe)\n\nfilterJust :: (a -> Maybe b) -> [a] -> [b]",
    "Description": "Define a function 'filterJust' that takes a function from 'a' to 'Maybe b' and a list of 'a' values, and returns a list containing only the 'Just' values resulting from applying the function to each element of the input list. Import the 'mapMaybe' function from the 'Data.Maybe' module."
  },
  {
    "Statement": "lemma map_contains: \"contains P (map f xs) ⟷ contains (λx. P (f x)) xs\"",
    "Description": "Define a lemma asserting that `P` holds for an element in the mapped list if and only if `P` holds for the original list."
  },
  {
    "Statement": "capitalize [] = []",
    "Description": "If the input string is empty, return an empty string."
  },
  {
    "Statement": "unit = [()]",
    "Description": "Define the 'unit' value for the 'Monoidal' instance of '[]' as a list containing the unit value '()'."
  },
  {
    "Statement": "readUntil ending = do",
    "Description": "Begin the definition of the `readUntil` function using the do notation for monadic computations."
  },
  {
    "Statement": "takeWhile _ [] = []",
    "Description": "Define the case of the takeWhile function where an empty list is given, it returns an empty list."
  },
  {
    "Statement": "apply auto",
    "Description": "Use the auto tactic to automatically solve the generated subgoals."
  },
  {
    "Statement": "instance Exception MyError",
    "Description": "Make the MyError data type an instance of the Exception class."
  },
  {
    "Statement": "showList :: [a] -> ShowS",
    "Description": "Define a function 'showList' within the 'Show' typeclass which takes a list of values of type 'a' and returns a 'ShowS' function."
  },
  {
    "Statement": "| x == y    = True",
    "Description": "If the first element of the list is `y`, return `True`."
  },
  {
    "Statement": "nodeIndex (Node _ _) = error \"nodeIndex: not implemented\"",
    "Description": "Define a placeholder function 'nodeIndex' that throws an error, as its implementation is not provided in this example."
  },
  {
    "Statement": "data Either a b = Left a | Right b",
    "Description": "Define a data type 'Either' which represents a value of one of two possible types, 'a' or 'b'."
  },
  {
    "Statement": "have \"Viv € setT (insert v l). iv ≤ tv\" by (simp add: setT_ insert tv disjunct True)",
    "Description": "assert that all the elements in the setT (insert v l) are less than or equal to 'tv'."
  },
  {
    "Statement": "data Temperature = C Float | F Float deriving (Show, Eq)",
    "Description": "Define a datatype 'Temperature' with two constructors 'C' and 'F' representing temperatures in Celsius and Fahrenheit respectively. Also, derive instances for the 'Show' and 'Eq' typeclasses for the Temperature datatype."
  },
  {
    "Statement": "data Maybe a = Nothing | Just a",
    "Description": "Define a data type named Maybe which is either Nothing or Just containing an element of type a."
  },
  {
    "Statement": "    | otherwise = lookup y xys",
    "Description": "Define the condition for the recursive case of the lookup function. If the key 'y' is not found, it recursively searches in the rest of the list."
  },
  {
    "Statement": "span' :: (a -> Bool) -> [a] -> ([a], [a])",
    "Description": "Define a function span' that takes a predicate p and a list xs, and returns a pair of lists, where the first list contains the longest prefix of xs that satisfies p, and the second list contains the remaining elements."
  },
  {
    "Statement": "fac n",
    "Description": "Define `fac` with parameter `n`."
  },
  {
    "Statement": "name <- getName",
    "Description": "Call the `getName` function and bind the result (if successful) to the `name` variable."
  },
  {
    "Statement": "m = frequencies xs",
    "Description": "Define 'm' as the map of frequencies for the remaining elements."
  },
  {
    "Statement": "fac :: Int -> Int",
    "Description": "Define a function named `fac` which takes an `Int` and returns an `Int`."
  },
  {
    "Statement": "reverse :: [a] -> [a]",
    "Description": "Define a function named `reverse` which takes a list of any type and returns a list of the same type."
  }
]